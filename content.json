[{"title":"基于Travis CI实现github开源项目在线持续集成和版本发布","date":"2017-08-23T12:28:00.000Z","path":"2017/08/23/Travis-ci-github/","text":"开启github项目的Travis CI 访问https://travis-ci.org/，使用github账号登录 开启github项目CI开关 配置自动编译脚本:.travis.yml ubuntu环境，安装ruby，gem，通过gem安装Travis$ gem install travis 通过Travis的travis setup releases命令生成并配置.travis.yml（需要输入github账号和密码）在您的github项目工程根目录下，执行如下命令，就会自动在根目录生成一个.travis.yml（中间会提示输入github账号密码等信息）：$ travis setup releases这里提供一份参考解释:123456789101112131415161718192021222324252627language: androidsudo: falseandroid: components: - build-tools-25.0.2 - android-25 - extra-android-m2repository - extra-android-support # before install any dependencies requiredbefore_install:- chmod +x gradlew # run the build scriptscript:- \"./gradlew assembleRelease\" # deploy stage base on tagsdeploy: provider: releases api_key: secure: eY1MPVqsgMQs0deLMeHH0hJrkdxgP8VauCc0AW3MEDy+89EkPQiWK+mQgnNVExGL54ajMurYAs3Y3evRZNNxeIUnhXiFLTLTg9sZlbT1lhK+/0wjQ0pQ6B2RbQLeNUq5dXrJbgLEWTpDgvABZomnYvDiUll7iJESX1Eo2NOZ/YKsjkPXILnm63P37UOrxBzOi45ZTZ5hd4L+E1oDq9k0fI0YEh7HKJYR5RfpFK3fvcNqyoAPG2cBlwGS33dfg4LeZN2Yxb+7cNMraEipj7ZjiiaYFXeGOgBz8xWWqcG+k8MjqpxOKJtlSqKjxFYpa0J97yFxxmmMtIEJX+lExc6XMbm9xeYKMqeJJLwSpmNFk6ggkk/vUsTzMy8+LdczyuQhBvCGMRt/IZRSxGIOznZD3KbmK5/Ceex3aXgin2pEhNA4LmwSLf+zMhniJNIZj3b2cF8u18LR1lGTNxTD03w170lDtX1fizmUQYFSiPJHeBiGp3W5HD9uTLbJfnh9tfJnOIhlKMN5C1Nl2HUyeV4KXCnkl4q73DtMuuNBn66JnFUhuzh0diFVpdAUK0KhwYTGew6DNz3GsnxFuPr/6MnrpUKKxSucDjprA2G0bfd7XbrVSw9BYR3wk5mU3ust5HXqh0erTIh6kRkin6NphPm+NLyQTvvbeXc/+M/zkXWAU9w= file: \"app/build/outputs/apk/app-release-unsigned.apk\" skip_cleanup: true on: tags: true repo: wangfuda/nebula 以上配置主要实现了：编译前，先授权了gradlew的执行权限然后执行编译脚本：./gradlew assembleRelease最后基于tag触发，发布apk文件至github release中以上配置中的具体含义可参考官方文档 其中，api_key中的secure为travis setup releases命令执行中基于github账号密码自动生成的。注：其实Travis CI提供了多种账号加密token的形式，但是其他几种均存在一些bug导致账号校验有问题，目前亲测这种可行。 配置Bintray oss账号并发布版本至Bintray Bintray上注册账号，或用github账号登录，地址为：https://bintray.com/signup/oss，而非这个地址：https://bintray.com/signup （注意，开源项目必须要用OSS账号，否则会因鉴权问题导致无法上传发布版本） 配置bintray.gradle（即发布版本的gradle脚本）注：这里可以无需显示提供账号，可使用Travis CI上的该项目的环境变量来设置 在gradle中基于Travis CI环境变量实现共用一套配置：12345bintray &#123; user = project.hasProperty(\"BINTRAY_USER\") ? BINTRAY_USER : System.getenv(\"BINTRAY_USER\") key = project.hasProperty(\"BINTRAY_KEY\") ? BINTRAY_KEY : System.getenv(\"BINTRAY_KEY\") ...&#125;","comments":true,"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"https://wangfuda.github.io/tags/Travis-CI/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wangfuda.github.io/tags/GitHub/"}]},{"title":"replugin源码解析之replugin-plugin-gradle（插件的gradle插件）","date":"2017-07-20T14:21:00.000Z","path":"2017/07/20/replugin-plugin-gradle/","text":"前言 replugin-plugin-gradle 是 RePlugin 插件框架中提供给replugin插件用的gradle插件，是一种动态编译方案实现。主要在插件应用的编译期，基于Transform api 注入到编译流程中, 再通过Java字节码类库对编译中间环节的 Java 字节码文件进行修改，以便实现编译期动态修改插件应用的目的。RePlugin 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。 注 ：文件会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念： replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。 gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。 结构概览replugin-plugin-gradle，针对插件应用编译期的注入任务：动态修改插件中的调用代码，改为调用replugin-plugin-library中的代码（如Activity的继承、Provider的重定向等） LoaderActivityInjector 动态将插件中的Activity的继承相关代码 修改为 replugin-plugin-library 中的XXPluginActivity父类 LocalBroadcastInjector 替换插件中的LocalBroadcastManager调用代码 为 插件库的调用代码。 ProviderInjector 替换 插件中的 ContentResolver 调用代码 为 插件库的调用代码 ProviderInjector2 替换 插件中的 ContentProviderClient 调用代码 为 插件库的调用代码 GetIdentifierInjector 替换 插件中的 Resource.getIdentifier 调用代码的参数 为 动态适配的参数 replugin-plugin-gradle插件的工作流：基于Gradle的Transform API，在编译期的构建任务流中，class转为dex之前，插入一个Transform，并在此Transform流中，基于Javassist实现对字节码文件的注入。 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\\qihoo\\replugin\\replugin-plugin-gradle\\src└─main ├─groovy │ └─com │ └─qihoo360 │ └─replugin │ └─gradle │ └─plugin │ │ AppConstant.groovy # 程序常量定义区 │ │ ReClassPlugin.groovy # 插件动态编译方案入口 │ │ │ ├─debugger │ │ PluginDebugger.groovy # 用于插件调试的gradle task实现 │ │ │ ├─injector │ │ │ BaseInjector.groovy # 注入器基类 │ │ │ IClassInjector.groovy # 注入器接口类 │ │ │ Injectors.groovy # 注入器枚举类，定义了全部注入器 │ │ │ │ │ ├─identifier │ │ │ GetIdentifierExprEditor.groovy # javassist 允许修改方法里的某个表达式，此类为替换 getIdentifier 方法中表达式的实现类 │ │ │ GetIdentifierInjector.groovy # GetIdentifier 方法注入器 │ │ │ │ │ ├─loaderactivity │ │ │ LoaderActivityInjector.groovy # Activity代码注入器 │ │ │ │ │ ├─localbroadcast │ │ │ LocalBroadcastExprEditor.groovy # 替换几个广播相关方法表达式的实现类 │ │ │ LocalBroadcastInjector.groovy # 广播代码注入器 │ │ │ │ │ └─provider │ │ ProviderExprEditor.groovy # 替换ContentResolver类的几个方法表达式 │ │ ProviderExprEditor2.groovy # 替换ContentProviderClient类的几个方法表达式 │ │ ProviderInjector.groovy # Provider之ContentResolver代码注入器 │ │ ProviderInjector2.groovy # Provider之ContentProviderClient代码注入器 │ │ │ ├─inner │ │ ClassFileVisitor.groovy # 类文件遍历类 │ │ CommonData.groovy # 实体类 │ │ ReClassTransform.groovy # 核心类，基于 transform api 实现动态修改class文件的总调度入口 │ │ Util.groovy # 工具类 │ │ │ ├─manifest │ │ IManifest.groovy # 接口类 │ │ ManifestAPI.groovy # 操作Manifest的API类 │ │ ManifestReader.groovy # Manifest读取工具类 │ │ │ └─util │ CmdUtil.groovy # 命令行工具类 │ └─resources └─META-INF └─gradle-plugins replugin-plugin-gradle.properties # 指定 gradle 插件实现类 replugin-plugin-gradle的基本用法 添加 RePlugin Plugin Gradle 依赖在项目根目录的 build.gradle（注意：不是 app/build.gradle） 中添加 replugin-plugin-gradle 依赖：123456buildscript &#123; dependencies &#123; classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.1.5' ... &#125;&#125; 在项目的app模块中的build.gradle应用插件：1apply plugin: 'replugin-plugin-gradle' replugin-plugin-gradle的源码解析我们在开始阅读源码前，要思考下，replugin-plugin-gradle是什么？A:replugin-plugin-gradle是一个自定义的gradle插件。这个清楚了，没上车的上车，上车了的别动！ replugin-plugin-gradle.properties文件1implementation-class=com.qihoo360.replugin.gradle.plugin.ReClassPlugin 在开发自定义gradle插件时，都会先定义这么个文件。这里有 2 个知识点： 文件中的implementation-class用来指定插件实现类。 文件名用来指定插件名，即在插件中使用gradle插件时的apply plugin: &#39;replugin-plugin-gradle&#39;中的replugin-plugin-gradle. 我们到插件实现类看看这个插件是如何工作的。 ReClassPlugin.groovy文件1234567public class ReClassPlugin implements Plugin&lt;Project&gt; &#123; @Override public void apply(Project project) &#123; println \"$&#123;AppConstant.TAG&#125; Welcome to replugin world ! \" ... &#125;&#125; 定义了一个类ReClassPlugin，继承自gradle-api 库中的接口类 Plugin ，实现了apply接口方法，apply方法会在 build.gradle 中执行 apply plugin: &#39;replugin-plugin-gradle&#39;时被调用。 接下来解读下 apply 方法的具体实现。 用于快速调试的gradle task12345678910111213141516171819202122232425262728293031323334353637383940@Override public void apply(Project project) &#123; println \"$&#123;AppConstant.TAG&#125; Welcome to replugin world ! \" /* Extensions */ project.extensions.create(AppConstant.USER_CONFIG, ReClassConfig) def isApp = project.plugins.hasPlugin(AppPlugin) if (isApp) &#123; def config = project.extensions.getByName(AppConstant.USER_CONFIG) def android = project.extensions.getByType(AppExtension) ... android.applicationVariants.all &#123; variant -&gt; PluginDebugger pluginDebugger = new PluginDebugger(project, config, variant) def variantData = variant.variantData def scope = variantData.scope def assembleTask = variant.getAssemble() def installPluginTaskName = scope.getTaskName(AppConstant.TASK_INSTALL_PLUGIN, \"\") def installPluginTask = project.task(installPluginTaskName) installPluginTask.doLast &#123; pluginDebugger.startHostApp() pluginDebugger.uninstall() pluginDebugger.forceStopHostApp() pluginDebugger.startHostApp() pluginDebugger.install() &#125; installPluginTask.group = AppConstant.TASKS_GROUP ... &#125; &#125; &#125; 首先向Plugin传递参数，通过project.extensions.create(AppConstant.USER_CONFIG, ReClassConfig)，将ReClassConfig类的常量配置信息赋值给AppConstant.USER_CONFIG，后面有两个地方会用到：一个是PluginDebugger类中要用到一些参数；另一个是做动态编译时要用到一些参数；后面逻辑会陆续用到。 判断project中是否含有AppPlugin类型插件，即是否有’application’ projects类型的Gradle plugin。我们在replugin插件项目中是应用了该类型插件的：apply plugin: &#39;com.android.application&#39;. 获取project中的AppExtension类型extension，即com.android.application projects的android extension.也就是在你的app模块的build.gradle中定义的闭包： 123android &#123; ...&#125; android.applicationVariants.all，遍历android extension的Application variants 组合。android gradle 插件，会对最终的包以多个维度进行组合。ApplicationVariant的组合 = {ProductFlavor} x {BuildType} 种组合. new PluginDebugger(project, config, variant)，初始化PluginDebugger类实例，主要配置了最终生成的插件应用的文件路径，以及adb文件的路径，是为了后续基于adb命令做push apk到SD卡上做准备。 12apkFile = new File(apkDir, apkName)adbFile = globalScope.androidBuilder.sdkInfo.adb; def assembleTask = variant.getAssemble()，获取assemble task(即打包apk的task)，后续的task需要依赖此task，比如安装插件的task，肯定要等到assemble task打包生成apk后，才能去执行。 生成installPluginTask 的gradle task 名字，并调用project的task()方法创建此Task。然后指定此task的任务内容：1234567installPluginTask.doLast &#123; pluginDebugger.startHostApp() pluginDebugger.uninstall() pluginDebugger.forceStopHostApp() pluginDebugger.startHostApp() pluginDebugger.install()&#125; 流程：启动宿主 -&gt; 卸载插件 -&gt; 强制停止宿主 -&gt; 启动宿主 -&gt; 安装插件 pluginDebugger 内的方法实现：基于adb shell + am 命令，实现 发送广播，push apk 等功能。,比如：pluginDebugger.startHostApp()123456789101112public boolean startHostApp() &#123; if (isConfigNull()) &#123; return false &#125; String cmd = \"$&#123;adbFile.absolutePath&#125; shell am start -n \\\"$&#123;config.hostApplicationId&#125;/$&#123;config.hostAppLauncherActivity&#125;\\\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER\" if (0 != CmdUtil.syncExecute(cmd)) &#123; return false &#125; return true &#125; pluginDebugger类的其他操作应用的方法，基本思路是一致的，基于adb+am命令。 apply()方法中共有如下几个gradle task(查看task： gradlew.bat task 或 gradlew.bat tasks --all): 以上task分别有不同的调试目的，可以去分别了解下，细节实现大同小异。看到这里，我们该插播一下调试方案的整体原理了： replugin-host-lib 的DebuggerReceivers类中，注册了一系列用于快速调试的广播，而replugin-host-lib是会内置在宿主应用中的。 replugin-plugin-gradle 中创建了一系列gradle task，用于启动停止重启宿主应用，安装卸载运行插件应用。这些gradle task都是被动型task，需要通过命令行主动的运行这些task。 打开命令行终端，执行replugin插件项目的某个gradle task，以实现快速调试功能。比如：gradlew.bat rpInstallPluginDebug，最终就会将宿主和插件运行起来。 这些gradle task被手动执行后，task会执行一系列任务，比如通过adb push 插件到sdcard，或通过am命令发送广播，启动activity等。当发送一系列步骤1中注册的广播后，宿主应用收到广播后会执行对应的操作，比如启动插件的activity等。 Tips.调试模式开启方法：插件调试Debug阶段建议开启,Release阶段建议关闭,默认为关闭状态 继续看apply()方法中的源码。 ##Transform:动态编译方案实现 12345678910111213@Override public void apply(Project project) &#123; ... if (isApp) &#123; ... def transform = new ReClassTransform(project) // 将 transform 注册到 android android.registerTransform(transform) ... &#125; &#125; 重点来了，这里就是动态编译方案的实现入口。在详细解读动态编译实现之前，先了解2个概念： 什么是 Transform？ Transform 是 Android Gradle API ，允许第三方插件在class文件转为dex文件前操作编译完成的class文件，这个API的引入是为了简化class文件的自定义操作而无需对Task进行处理。在做代码插桩时，本质上是在merge{ProductFlavor}{BuildType}Assets Task 之后，transformClassesWithDexFor{ProductFlavor}{BuildType} Transform 之前,插入一个transformClassesWith{YourTransformName}For{ProductFlavor}{BuildType} Transform，此Transform中完成对class文件的自定义操作（包括修改父类继承，方法中的super方法调用，方法参数替换等等，这个class交给你，理论上是可以改到怀疑人生）。 详细API参见：Transform 如何使用 Transform？ 实现一个继承自Transform的自定义 Transform 类。 通过registerTransform(@NonNull Transform transform, Object... dependencies)注册自定义 Transform 类。 去看看 ReClassTransform 类的核心实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ReClassTransform extends Transform &#123; @Override String getName() &#123; return '___ReClass___' &#125; @Override void transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException &#123; welcome() /* 读取用户配置 */ def config = project.extensions.getByName('repluginPluginConfig') ... // Compatible with path separators for window and Linux, and fit split param based on 'Pattern.quote' def variantDir = rootLocation.absolutePath.split(getName() + Pattern.quote(File.separator))[1] CommonData.appModule = config.appModule CommonData.ignoredActivities = config.ignoredActivities def injectors = includedInjectors(config, variantDir) if (injectors.isEmpty()) &#123; copyResult(inputs, outputProvider) // 跳过 reclass &#125; else &#123; doTransform(inputs, outputProvider, config, injectors) // 执行 reclass &#125; &#125; @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; @Override Set&lt;QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT &#125; @Override boolean isIncremental() &#123; return false &#125;&#125; getName()，即指定刚才提到的那个插入的transform transformClassesWith{YourTransformName}For{ProductFlavor}{BuildType}中的{YourTransformName}。 transform() 方法会在执行你的transform时被调用。 project.extensions.getByName(&#39;repluginPluginConfig&#39;)读取用户在replugin插件项目的build.gradle中配置的参数，比如设置了需要忽略的注入器ignoredInjectors、需要忽略替换的ActivityignoredActivities、自定义的代码注入器customInjectors等。 includedInjectors()返回用户未忽略的注入器的集合 LoaderActivityInjector 替换插件中的Activity的继承相关代码 为 replugin-plugin-library 中的XXPluginActivity父类 LocalBroadcastInjector 替换插件中的LocalBroadcastManager调用代码 为 插件库的调用代码。 ProviderInjector 替换 插件中的 ContentResolver 调用代码 为 插件库的调用代码 ProviderInjector2 替换 插件中的 ContentProviderClient 调用代码 为 插件库的调用代码 GetIdentifierInjector 替换 插件中的 Resource.getIdentifier 调用代码的参数 为 动态适配的参数 getInputTypes() 指明当前Trasfrom要处理的数据类型,可选类型包括CONTENT_CLASS（代表要处理的数据是编译过的Java代码，而这些数据的容器可以是jar包也可以是文件夹），CONTENT_JARS（包括编译过的Java代码和标准的Java资源），CONTENT_RESOURCES，CONTENT_NATIVE_LIBS等。在replugin-plugin-gradle中是使用Transform来做代码插桩,所以选用CONTENT_CLASS类型。 getScopes() 配置当前Transform的作用域，实际使用中可以根据需求配置多种Scope。 doTransform()方法是执行reclass的关键 123456789def doTransform(Collection&lt;TransformInput&gt; inputs, TransformOutputProvider outputProvider, Object config, def injectors) &#123; /* 初始化 ClassPool */ Object pool = initClassPool(inputs) ...&#125; Transform方法中的参数inputs和outputProvider一定程度上反映了Transform的工作流，接受输入-&gt;处理输入-&gt;输出数据。 initClassPool(...)方法主要的工作：添加编译时引用到的类到 ClassPool，同时记录要修改的 jar 到 includeJars。方便后续拿到这些class文件去修改。比如Sample中会添加的class路径：1234&gt;&gt;&gt; ClassPath:...// 插件项目replugin-sample的class目录 E:\\opensource\\qihoo\\RePlugin\\replugin-sample\\plugin\\plugin-demo1\\app\\build\\intermediates\\classes\\debug Javassit 是一个处理Java字节码的类库。CtMethod：是一个class文件中的方法的抽象表示。一个CtMethod对象表示一个方法。（Javassit 库API）CtClass：是一个class文件的抽象表示。一个CtClass（compile-time class)对象可以用来处理一个class文件。（Javassit 库API）ClassPool：是一个CtClass对象的容器类。（Javassit 库API）.class文件：.class文件是一种存储Java字节码的二进制文件，里面包含一个Java类或者接口。 12345678910111213141516171819202122def doTransform(Collection&lt;TransformInput&gt; inputs, TransformOutputProvider outputProvider, Object config, def injectors) &#123; ... /* 进行注入操作 */ Injectors.values().each &#123; ... doInject(inputs, pool, it.injector, config.properties[\"$&#123;configPre&#125;Config\"]) ... &#125; if (config.customInjectors != null) &#123; config.customInjectors.each &#123; doInject(inputs, pool, it) &#125; &#125; ...&#125; 这里会遍历除了用户已忽略过的全部代码注入器，依次执行每个注入器的特定注入任务。看下doInject(...)方法实现。123456789101112131415161718/** * 执行注入操作 */def doInject(Collection&lt;TransformInput&gt; inputs, ClassPool pool, IClassInjector injector, Object config) &#123; try &#123; inputs.each &#123; TransformInput input -&gt; input.directoryInputs.each &#123; handleDir(pool, it, injector, config) &#125; input.jarInputs.each &#123; handleJar(pool, it, injector, config) &#125; &#125; &#125; catch (Throwable t) &#123; println t.toString() &#125;&#125; 分别处理目录中的 class 文件和处理 jar1234def handleDir(ClassPool pool, DirectoryInput input, IClassInjector injector, Object config) &#123; println \"&gt;&gt;&gt; Handle Dir: $&#123;input.file.absolutePath&#125;\" injector.injectClass(pool, input.file.absolutePath, config)&#125; 接下来就是那些注入器八仙过海，各显神通的时候了。还记得吗，前面那句代码Injectors.values().each {，这是要用每个注入器都把class们撸一遍。 ##LoaderActivityInjector第一个被执行的就是 LoaderActivityInjector,用来修改插件中XXActivity类中的顶级XXActivity父类 为 XXPluginActivity父类。看看如何实现的。1234567891011121314@Override def injectClass(ClassPool pool, String dir, Map config) &#123; println \"&gt;&gt;&gt; LoaderActivityInjector dir: $dir\" init() /* 遍历程序中声明的所有 Activity */ //每次都new一下，否则多个variant一起构建时只会获取到首个manifest new ManifestAPI().getActivities(project, variantDir).each &#123; // 处理没有被忽略的 Activity if (!(it in CommonData.ignoredActivities)) &#123; handleActivity(pool, it, dir) &#125; &#125; &#125; init()指定了 Activity 替换规则，只替换那些顶级Activity父类为 replugin-plugin-lib 库中的 XXPluginActivity。 12345678910def private static loaderActivityRules = [ 'android.app.Activity' : 'com.qihoo360.replugin.loader.a.PluginActivity', 'android.app.TabActivity' : 'com.qihoo360.replugin.loader.a.PluginTabActivity', 'android.app.ListActivity' : 'com.qihoo360.replugin.loader.a.PluginListActivity', 'android.app.ActivityGroup' : 'com.qihoo360.replugin.loader.a.PluginActivityGroup', 'android.support.v4.app.FragmentActivity' : 'com.qihoo360.replugin.loader.a.PluginFragmentActivity', 'android.support.v7.app.AppCompatActivity': 'com.qihoo360.replugin.loader.a.PluginAppCompatActivity', 'android.preference.PreferenceActivity' : 'com.qihoo360.replugin.loader.a.PluginPreferenceActivity', 'android.app.ExpandableListActivity' : 'com.qihoo360.replugin.loader.a.PluginExpandableListActivity' ] 接下来遍历插件应用AndroidManifest.xml中声明的所有 Activity名称，并在handleActivity(...)方法中处理这些Activity类的.class文件。看下handleActivity(...)的实现细节。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private def handleActivity(ClassPool pool, String activity, String classesDir) &#123; def clsFilePath = classesDir + File.separatorChar + activity.replaceAll('\\\\.', '/') + '.class' ... def stream, ctCls try &#123; stream = new FileInputStream(clsFilePath) ctCls = pool.makeClass(stream); // ctCls 之前的父类 def originSuperCls = ctCls.superclass /* 从当前 Activity 往上回溯，直到找到需要替换的 Activity */ def superCls = originSuperCls while (superCls != null &amp;&amp; !(superCls.name in loaderActivityRules.keySet())) &#123; // println \"&gt;&gt;&gt; 向上查找 $superCls.name\" ctCls = superCls superCls = ctCls.superclass &#125; // 如果 ctCls 已经是 LoaderActivity，则不修改 if (ctCls.name in loaderActivityRules.values()) &#123; // println \" 跳过 $&#123;ctCls.getName()&#125;\" return &#125; /* 找到需要替换的 Activity, 修改 Activity 的父类为 LoaderActivity */ if (superCls != null) &#123; def targetSuperClsName = loaderActivityRules.get(superCls.name) // println \" $&#123;ctCls.getName()&#125; 的父类 $superCls.name 需要替换为 $&#123;targetSuperClsName&#125;\" CtClass targetSuperCls = pool.get(targetSuperClsName) if (ctCls.isFrozen()) &#123; ctCls.defrost() &#125; ctCls.setSuperclass(targetSuperCls) // 修改声明的父类后，还需要方法中所有的 super 调用。 ctCls.getDeclaredMethods().each &#123; outerMethod -&gt; outerMethod.instrument(new ExprEditor() &#123; @Override void edit(MethodCall call) throws CannotCompileException &#123; if (call.isSuper()) &#123; if (call.getMethod().getReturnType().getName() == 'void') &#123; String statement = '&#123;super.' + call.getMethodName() + '($$);&#125;' println \"&gt;&gt;&gt; $&#123;outerMethod&#125; call.replace 1 to statement $&#123;statement&#125;\" call.replace('&#123;super.' + call.getMethodName() + '($$);&#125;') &#125; else &#123; String statement = '&#123;super.' + call.getMethodName() + '($$);&#125;' println \"&gt;&gt;&gt; $&#123;outerMethod&#125; call.replace 2 to statement $&#123;statement&#125;\" call.replace('&#123;$_ = super.' + call.getMethodName() + '($$);&#125;') &#125; &#125; &#125; &#125;) &#125; ctCls.writeFile(CommonData.getClassPath(ctCls.name)) println \" Replace $&#123;ctCls.name&#125;'s SuperClass $&#123;superCls.name&#125; to $&#123;targetSuperCls.name&#125;\" &#125; &#125; catch (Throwable t) &#123; println \" [Warning] --&gt; $&#123;t.toString()&#125;\" &#125; finally &#123; if (ctCls != null) &#123; ctCls.detach() &#125; if (stream != null) &#123; stream.close() &#125; &#125; &#125; ctCls = pool.makeClass(stream)，从文件流中加载.class文件，创建一个CtClass实例，这个实例表示.class文件对应的类或接口。通过CtClass可以很方便的对.class文件进行自定义操作，比如添加方法，改方法参数，添加类成员，改继承关系等。 while (superCls != null &amp;&amp; !(superCls.name in loaderActivityRules.keySet()))，一级级向上遍历ctCls的父类，找到需要替换的Activity类。 ctCls.setSuperclass(targetSuperCls)，根据初始化中设置的Activity替换规则，修改 此Activity类 的父类为 对应的插件库中的父类。例：public class MainActivity extends Activity {修改为public class MainActivity extends PluginActivity { if (ctCls.isFrozen()) { ctCls.defrost() }，如果class被冻结，则通过defrost()解冻class，以便class重新允许被修改。注：当CtClass 调用writeFile()、toClass()、toBytecode() 这些方法的时候，Javassist会冻结CtClass Object，将不允许对CtClass object进行修改。 补充2个 Javassist 知识点： 如何修改方法体？1.获得一个CtMethod实例，即class中的一个方法。2.调用CtMethod实例的instrument(ExprEditor editor)方法，并传递一个ExprEditor实例(A translator of method bodies.)3.在ExprEditor实例中覆盖edit(MethodCall m)方法，这里可以调用MethodCall的replace()方法来更改方法体内的代码。 修改方法体的原理？调用CtMethod的instrument()，方法体会被逐行进行扫描，从第一行扫描到最后一行。发现有方法调用或表达式时(object creation),edit()会被调用，根据edit()内的replace()方法来修改这一行代码。 ctCls.getDeclaredMethods().each { }，经过对修改方法体的背景知识的了解，我们再看这段插桩代码实现就能看懂了： 遍历class中声明的全部方法 调用每个方法的instrument方法 扫描方法中的每一行表达式，如果这一行表达式的调用方为此类的super类，那么就分两种情况做处理：1.返回类型为void时，调用MethodCall的replace方法，替换这一行代码为super.&#39; + call.getMethodName() + &#39;($$);，其中$$ 是所有方法参数的简写，例如：m($$)等同于m($1,$2,…)。2.返回类型非void时，调用MethodCall的replace方法，替换这一行代码为$_ = super.&#39; + call.getMethodName() + &#39;($$);，其中特殊变量$_代表的是方法的返回值。因为方法调用是有返回值的，所以statement必须将返回值赋值给它，这是javassist.expr.MethodCall方法的明确要求。 Javassist提供了一些特殊的变量来代表特定含义：注：在不同的 javassist 方法中使用时，这些特殊变量代表的含义可能会略有不同。参见：javassist tutorial 全部的类遍历完后，将ctCls对象写回到class文件中。这样就全部完成了class文件的Activity顶级父类动态注入。 CtClass.detach()，最后调用detach()方法，把CtClass object 从ClassPool中移除，避免当加载过多的CtClass object的时候，会造成OutOfMemory的异常。因为ClassPool是一个CtClass objects的装载容器。加载CtClass object后，默认是不释放的。 关于Jar包中的class注入：在initClassPool时已经把Jar做了unzip，解压出也是一堆.class文件，其他处理逻辑同上。也就是说，你引用的第三方sdk中的jar，以及你依赖的库中的jar，都会被注入器撸一遍。 1.如果希望看看具体的代码插桩效果，可以基于dex2jar工具+jd-gui工具逆向你的插件apk。先zip工具解压你的apk，用dex2jar工具从dex拿到完整的jar，然后用jd-gui工具看看jar中的Activity父类是不是神奇的变了。或者直接apktool工具反编译插件apk，看smali文件的改变。2.可以基于命令行的方式gradlew.bat build编译你的插件应用，然后查看命令行中的编译日志，会有助于你更好的理解。 ##LocalBroadcastInjectorLocalBroadcastInjector，实现了替换插件中的 LocalBroadcastManager的方法调用 为 插件库的PluginLocalBroadcastManager中的方法调用。直接看injectClass的实现，遍历class目录并访问到文件时，执行以下这段逻辑。12345678910111213141516171819202122232425262728293031@Overridedef injectClass(ClassPool pool, String dir, Map config) &#123; ... try &#123; // 不处理 LocalBroadcastManager.class if (filePath.contains('android/support/v4/content/LocalBroadcastManager')) &#123; println \"Ignore $&#123;filePath&#125;\" return super.visitFile(file, attrs) &#125; stream = new FileInputStream(filePath) ctCls = pool.makeClass(stream); // println ctCls.name if (ctCls.isFrozen()) &#123; ctCls.defrost() &#125; /* 检查方法列表 */ ctCls.getDeclaredMethods().each &#123; it.instrument(editor) &#125; ctCls.getMethods().each &#123; it.instrument(editor) &#125; ctCls.writeFile(dir) &#125; ...&#125; if (filePath.contains(&#39;android/support/v4/content/LocalBroadcastManager&#39;))，保护性逻辑，避免替换掉v4包中的源码实现。 pool.makeClass()，创建当前类文件的CtClass实例。 ctCls.defrost() 如果CtClass实例被冻结，则执行解冻操作。 ctCls.getDeclaredMethods().each { }和ctCls.getMethods().each { }，遍历全部方法，并执行instrument方法，逐个扫描每个方法体内每一行代码，并交由LocalBroadcastExprEditor的edit()处理对方法体代码的修改。 LocalBroadcastExprEditor.groovy1234567891011121314151617181920212223242526272829303132333435363738394041public class LocalBroadcastExprEditor extends ExprEditor &#123; static def TARGET_CLASS = 'android.support.v4.content.LocalBroadcastManager' static def PROXY_CLASS = 'com.qihoo360.replugin.loader.b.PluginLocalBroadcastManager' /** 处理以下方法 */ static def includeMethodCall = ['getInstance', 'registerReceiver', 'unregisterReceiver', 'sendBroadcast', 'sendBroadcastSync'] ... @Override void edit(MethodCall call) throws CannotCompileException &#123; if (call.getClassName().equalsIgnoreCase(TARGET_CLASS)) &#123; if (!(call.getMethodName() in includeMethodCall)) &#123; // println \"Skip $methodName\" return &#125; replaceStatement(call) &#125; &#125; def private replaceStatement(MethodCall call) &#123; String method = call.getMethodName() if (method == 'getInstance') &#123; call.replace('&#123;$_ = ' + PROXY_CLASS + '.' + method + '($$);&#125;') &#125; else &#123; def returnType = call.method.returnType.getName() // getInstance 之外的调用，要增加一个参数，请参看 i-library 的 LocalBroadcastClient.java if (returnType == 'void') &#123; call.replace('&#123;' + PROXY_CLASS + '.' + method + '($0, $$);&#125;') &#125; else &#123; call.replace('&#123;$_ = ' + PROXY_CLASS + '.' + method + '($0, $$);&#125;') &#125; &#125; &#125;&#125; TARGET_CLASS和PROXY_CLASS分别指定了需要处理的目标类和对应的代理类 static def includeMethodCall中定义了需要处理的目标方法名 replaceStatement(...)中，替换方法体： 替换getInstance:1）调用原型：PluginLocalBroadcastManager.getInstance(context);2）replace statement：&#39;{$_ = &#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($$);}&#39;，$$表示全部参数的简写。$_表示resulting value即返回值。 替换registerReceiver unregisterReceiver sendBroadcastSync（returnType == &#39;void&#39;）:1）调用原型：PluginLocalBroadcastManager.registerReceiver(instance, receiver, filter);2）replace statement：&#39;{&#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($0, $$);}&#39;，$0在这里就不代表this了，而是表示方法的调用方（参见：javassist tutorial），即PluginLocalBroadcastManager。因为调用原型中需要入参instance（要求是PluginLocalBroadcastManager类型），所以这里必须传入$0。注：unregisterReceiver和sendBroadcastSync同上，调用原型请参见replugin-plugin-lib插件库中的PluginLocalBroadcastManager.java文件。 替换sendBroadcast （returnType != &#39;void&#39;）:1）调用原型：PluginLocalBroadcastManager.sendBroadcast(instance, intent);2）replace statement：&#39;{$_ = &#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($0, $$);}&#39;，传入调用方，全部参数，以及把返回值赋给特殊变量$_。 到这里广播注入器的工作就完成了。接下来看看ProviderInjector。 ##ProviderInjectorProviderInjector，主要用来替换 插件中的 ContentResolver相关的方法调用 为 插件库的PluginProviderClient中的对应方法调用。1234567891011121314// 处理以下方法public static def includeMethodCall = ['query', 'getType', 'insert', 'bulkInsert', 'delete', 'update', 'openInputStream', 'openOutputStream', 'openFileDescriptor', 'registerContentObserver', 'acquireContentProviderClient', 'notifyChange',] static def includeMethodCall中定义了需要处理的目标方法名 直接看injectClass的实现，遍历class目录并访问到文件时，执行以下逻辑。12345678910111213141516171819@Overridedef injectClass(ClassPool pool, String dir, Map config) &#123; ... try &#123; ... /* 检查方法列表 */ ctCls.getDeclaredMethods().each &#123; it.instrument(editor) &#125; ctCls.getMethods().each &#123; it.instrument(editor) &#125; ... &#125; ...&#125; ctCls.getDeclaredMethods().each { }和ctCls.getMethods().each { }，遍历全部方法，并执行instrument方法，逐个扫描每个方法体内每一行代码，并交由ProviderExprEditor的edit()处理对方法体代码的修改。 ProviderExprEditor.groovy1234567891011121314151617181920public class ProviderExprEditor extends ExprEditor &#123; static def PROVIDER_CLASS = 'com.qihoo360.replugin.loader.p.PluginProviderClient' @Override void edit(MethodCall m) throws CannotCompileException &#123; ... replaceStatement(m, methodName, m.lineNumber) ... &#125; def private replaceStatement(MethodCall methodCall, String method, def line) &#123; if (methodCall.getMethodName() == 'registerContentObserver' || methodCall.getMethodName() == 'notifyChange') &#123; methodCall.replace('&#123;' + PROVIDER_CLASS + '.' + method + '(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;') &#125; else &#123; methodCall.replace('&#123;$_ = ' + PROVIDER_CLASS + '.' + method + '(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;') &#125; println \"&gt;&gt;&gt; Replace: $&#123;filePath&#125; Provider.$&#123;method&#125;():$&#123;line&#125;\" &#125;&#125; PROVIDER_CLASS指定了对应的替代实现类 replaceStatement(...)中，替换方法体： 替换registerContentObserver或notifyChange :replace statement：&#39;{&#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;，唯一特别的地方就是入参中传入了特定的context。 替换query 等方法:replace statement：&#39;{$_ = &#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;，因为方法调用是有返回值的，所以statement必须将返回值赋值给特殊变量$_，这是javassist.expr.MethodCall方法的明确要求。 到这里Provider注入器的工作就完成了。接下来看看ProviderInjector2。 ##ProviderInjector2ProviderInjector2，主要用来替换 插件中的 ContentProviderClient 相关的方法调用。 12// 处理以下方法public static def includeMethodCall = ['query', 'update'] static def includeMethodCall中定义了需要处理的目标方法名 看下injectClass的实现，遍历class目录并访问到文件时，执行以下这段逻辑。12345678910111213141516171819@Overridedef injectClass(ClassPool pool, String dir, Map config) &#123; ... try &#123; ... /* 检查方法列表 */ ctCls.getDeclaredMethods().each &#123; it.instrument(editor) &#125; ctCls.getMethods().each &#123; it.instrument(editor) &#125; ... &#125; ...&#125; ctCls.getDeclaredMethods().each { }和ctCls.getMethods().each { }，遍历全部方法，并执行instrument方法，逐个扫描每个方法体内每一行代码，并交由ProviderExprEditor2的edit()处理对方法体代码的修改。 ProviderExprEditor2.groovy12345678910111213141516public class ProviderExprEditor2 extends ExprEditor &#123; static def PROVIDER_CLASS = 'com.qihoo360.loader2.mgr.PluginProviderClient2' @Override void edit(MethodCall m) throws CannotCompileException &#123; ... replaceStatement(m, methodName, m.lineNumber) ... &#125; def private replaceStatement(MethodCall methodCall, String method, def line) &#123; methodCall.replace('&#123;$_ = ' + PROVIDER_CLASS + '.' + method + '(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;') println \"&gt;&gt;&gt; Replace: $&#123;filePath&#125; Provider.$&#123;method&#125;():$&#123;line&#125;\" &#125;&#125; PROVIDER_CLASS指定了对应的替代实现类 replaceStatement(...)中，替换方法体： 替换query和update:replace statement：&#39;{$_ = &#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;，因为方法调用是有返回值的，所以statement必须将返回值赋值给特殊变量$_，这是javassist.expr.MethodCall方法的明确要求。 到这里ProviderInjector2注入器的工作就完成了。接下来看看GetIdentifierInjector。 ##GetIdentifierInjectorGetIdentifierInjector，主要用来替换 插件中的 Resource.getIdentifier 方法调用的参数 为 动态适配的参数。 看下injectClass的实现，遍历class目录并访问到文件时，执行以下这段逻辑。12345678910111213141516171819@Overridedef injectClass(ClassPool pool, String dir, Map config) &#123; ... try &#123; ... /* 检查方法列表 */ ctCls.getDeclaredMethods().each &#123; it.instrument(editor) &#125; ctCls.getMethods().each &#123; it.instrument(editor) &#125; ... &#125; ...&#125; ctCls.getDeclaredMethods().each { }和ctCls.getMethods().each { }，遍历全部方法，并执行instrument方法，逐个扫描每个方法体内每一行代码，并交由GetIdentifierExprEditor的edit()处理对方法体代码的修改。 GetIdentifierExprEditor.groovy1234567891011121314151617181920212223public class GetIdentifierExprEditor extends ExprEditor &#123; public def filePath @Override void edit(MethodCall m) throws CannotCompileException &#123; String clsName = m.getClassName() String methodName = m.getMethodName() if (clsName.equalsIgnoreCase('android.content.res.Resources')) &#123; if (methodName == 'getIdentifier') &#123; m.replace('&#123; $3 = \\\"' + CommonData.appPackage + '\\\"; ' + '$_ = $proceed($$);' + ' &#125;') println \" GetIdentifierCall =&gt; \" +'&#123; $3 = \\\"' + CommonData.appPackage + '\\\"; ' + '$_ = $proceed($$);' + ' &#125;' println \" \\n\"; println \" GetIdentifierCall =&gt; $&#123;filePath&#125; $&#123;methodName&#125;():$&#123;m.lineNumber&#125;\" &#125; &#125; &#125;&#125; edit(...)中，遍历到调用方为android.content.res.Resources且方法为getIdentifier的MethodCall，动态适配这些MethodCall中的方法参数：1）调用原型： int id = res.getIdentifier(&quot;com.qihoo360.replugin.sample.demo2:layout/from_demo1&quot;, null, null);2）replace statement：&#39;{ $3 = \\&quot;&#39; + CommonData.appPackage + &#39;\\&quot;; &#39; +&#39;$_ = $proceed($$);&#39; + &#39; }&#39;，为特殊变量$3赋值，即动态修改参数3的值为插件的包名；’$_ = $proceed($$);’表示按原样调用。 到此GetIdentifierInjector注入器的工作就已完成，全部的注入器也都遍历完毕并完成了全部的注入工作。 伴随着注入器的遍历结束，整个replugin-plugin-gradle插件的Tansfrom的注入工作完成了，Tansfrom还有一点整理的工作要做，用Tansfrom自然要按照Tansfrom的套路，把处理过的数据输出给下一个Tansfrom。1234567891011121314def doTransform(Collection&lt;TransformInput&gt; inputs, TransformOutputProvider outputProvider, Object config, def injectors) &#123; ... /* 重打包 */ repackage() /* 拷贝 class 和 jar 包 */ copyResult(inputs, outputProvider) ... &#125; repackage()，将解压的 class 文件重新打包，然后删除 class 文件 copyResult(...)最终会调用output.getContentLocation(...)，按照Tansfrom的API范式，把处理过的数据输出给下一个Tansfrom。 ReclassTansfrom任务完成，将会把输出继续传递给下一个TransfromtransformClassesWithDexFor{ProductFlavor}{BuildType}，把处理权交还给android gradle插件。至此，replugin-plugin-gradle 插件的工作就全部结束了。 ##Endreplugin-plugin-gradle 插件是一个compile-time gradle plugin，基于两大核心技术Transform + Javassist，完成了编译期对class文件的动态注入，进而实现动态修改构建目标文件的为replugin插件服务的gradle插件。","comments":true,"tags":[{"name":"RePlugin","slug":"RePlugin","permalink":"https://wangfuda.github.io/tags/RePlugin/"},{"name":"Gradle","slug":"Gradle","permalink":"https://wangfuda.github.io/tags/Gradle/"},{"name":"replugin-plugin-gradle","slug":"replugin-plugin-gradle","permalink":"https://wangfuda.github.io/tags/replugin-plugin-gradle/"}]},{"title":"replugin源码解析之replugin-host-gradle（宿主的gradle插件）","date":"2017-07-15T14:53:00.000Z","path":"2017/07/15/replugin-host-gradle/","text":"前言 replugin-host-gradle 是 RePlugin 插件框架中的宿主gradle插件，主要用于在宿主应用的编译期常规构建任务流中，插入一些定制化的构建任务，以便实现自动化编译期修改宿主应用的目的。RePlugin 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。 注：文中会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念： replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。 gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。 结构概览 结构概览 - 英文高清大图 —————— 结构概览 - 中文高清大图 replugin-host-gradle，针对宿主应用执行的构建任务： 生成带 RePlugin 插件坑位的 AndroidManifest.xml（允许自定义数量） 生成 RepluginHostConfig 类，方便插件框架读取并自定义其属性 生成 plugins-builtin.json，json中含有插件应用的信息，包名，插件名，插件路径等。 replugin-host-gradle 插件的构建任务基于{productFlavors}{buildTypes}组合出多维构建任务，在android gradle 插件构建规则内执行构建任务，举个具体的例子：在宿主中配置了 两个渠道{baidu} {xiaomi}，两个编译类型{debug} {release}共会生成四种编译组合:{baidu}{debug} {xiaomi}{debug} {baidu}{release} {xiaomi}{release}每种组合都会执行经由replugin-host-gradle 插件插入或修改到默认构建任务流中的gradle task为：rpGenerate{productFlavors}{buildTypes}HostConfig - 生成RePluginHostConfig.java配置文件到buildConfig目录下process{productFlavors}{buildTypes}Manifest - 拼装生成 AndroidManifest.xml（坑位组件+原xml中的组件）rpGenerate{productFlavors}{buildTypes}BuiltinJson - 生成插件信息文件plugins-builtin.json到assets目录下 目录概览1234567891011121314151617181920212223242526272829303132\\qihoo\\RePlugin\\replugin-host-gradle\\src│└─main ├─groovy │ └─com │ └─qihoo360 │ └─replugin │ └─gradle │ └─host │ │ AppConstant.groovy # 程序常量定义区 │ │ RePlugin.groovy # 针对宿主的特定构建任务创建及调度 │ │ │ ├─creator │ │ │ FileCreators.groovy # 组装生成器 │ │ │ IFileCreator.groovy # 文件生成器接口 │ │ │ │ │ └─impl │ │ ├─java │ │ │ RePluginHostConfigCreator.groovy # RePluginHostConfig.java 生成器 │ │ │ │ │ └─json │ │ PluginBuiltinJsonCreator.groovy # plugins-builtin.json 生成器 │ │ PluginInfo.groovy # 插件信息模型 │ │ PluginInfoParser.groovy # 从 manifest 的 xml 中抽取 PluginInfo信息 │ │ │ └─handlemanifest │ ComponentsGenerator.groovy # 动态生成插件化框架中需要的组件 │ └─resources └─META-INF └─gradle-plugins replugin-host-gradle.properties # 指定 gradle 插件实现类 replugin-host-gradle的基本用法 添加 RePlugin Host Gradle 依赖在项目根目录的 build.gradle（注意：不是 app/build.gradle） 中添加 replugin-host-gradle 依赖：123456buildscript &#123; dependencies &#123; classpath 'com.qihoo360.replugin:replugin-host-gradle:2.1.5' ... &#125;&#125; 在项目的app模块中的build.gradle应用插件：1apply plugin: 'replugin-host-gradle' replugin-host-gradle的源码解析我们在开始阅读源码前，要思考下，replugin-host-gradle是什么？A:replugin-host-gradle是一个自定义的gradle插件。这个清楚了，那就上车吧。 讲解replugin-host-gradle源码的同时，还会讲解一些开发自定义gradle插件的知识，希望能和您一起：知其然，亦知其所以然。 replugin-host-gradle.properties文件1implementation-class=com.qihoo360.replugin.gradle.host.Replugin 在开发自定义gradle插件时，都会先定义这么个文件。这里有 2 个知识点： 文件中的implementation-class用来指定插件实现类。 文件名用来指定插件名，即在宿主中使用插件时的apply plugin: &#39;replugin-host-gradle&#39;中的replugin-host-gradle. 我们到插件实现类看看这个插件是如何工作的。 此 gradle 插件基于 groovy 开发，groovy 也是 JVM 系的编程语言，对于 java 系程序员来说，几乎可以闭着眼就开撸代码，不过 gradle 基于 Groovy，build 脚本使用 Groovy 编写，想写出 gradle style 的代码，还是可以去学学这门语言。 RePlugin.groovy文件1234567public class Replugin implements Plugin&lt;Project&gt; &#123; @Override public void apply(Project project) &#123; println \"$&#123;TAG&#125; Welcome to replugin world ! \" ... &#125;&#125; 定义了一个类RePlugin，继承自gradle-api 库中的接口类 Plugin ，实现了apply接口方法，apply方法会在 build.gradle 中执行 apply plugin: ‘replugin-host-gradle’ 时被调用。 那我们分小节，循序渐进的看看 apply 方法的具体实现。 预生成AndroidManifest.xml中的组件坑位123456789101112131415161718192021222324252627282930@Override public void apply(Project project) &#123; println \"$&#123;TAG&#125; Welcome to replugin world ! \" this.project = project /* Extensions */ project.extensions.create(AppConstant.USER_CONFIG, RepluginConfig) if (project.plugins.hasPlugin(AppPlugin)) &#123; def android = project.extensions.getByType(AppExtension) android.applicationVariants.all &#123; variant -&gt; addShowPluginTask(variant) if (config == null) &#123; config = project.extensions.getByName(AppConstant.USER_CONFIG) checkUserConfig(config) &#125; def appID = variant.generateBuildConfig.appPackageName println \"$&#123;TAG&#125; appID: $&#123;appID&#125;\" def newManifest = ComponentsGenerator.generateComponent(appID, config) ... &#125; &#125; &#125; 首先向Plugin传递参数，通过project.extensions.create(AppConstant.USER_CONFIG, RepluginConfig)，将RepluginConfig类的常量配置信息赋值给AppConstant.USER_CONFIG，在接下来checkUserConfig(config)检查配置信息时有用到,主要检查配置信息数据类型是否正确。 判断project中是否含有AppPlugin类型插件，即是否有’application’ projects类型的Gradle plugin。我们在宿主项目中是应用了该类型插件的：apply plugin: &#39;com.android.application&#39;.如果希望判断是否有libraryPlugin,可以这样写：if (project.plugins.hasPlugin(LibraryPlugin))，it’s for ‘library’ projects. 获取project中的AppExtension类型extension，即com.android.application projects的android extension.也就是在你的app模块的build.gradle中定义的闭包：123android &#123; ...&#125; 遍历android extension的Application variants 列表。这里说下，这可以说是 Hook Android gradle 插件的一种方式，因为通过遍历applicationVariants，你可以修改属性，名字，描述，输出文件名等，如果是Android library库，那么就将applicationVariants替换为libraryVariants。很多人可能在build.gradle中这样定义过闭包：1234567891011buildTypes &#123; release &#123; applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile def fileName = \"xxx_$&#123;variant.productFlavors[0].name&#125;_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; 其实这也是一种插件的创建方式，Hook Android gradle 插件动态修改variants属性值，修改打包输出的apk文件名。创建自定义gradle插件，Gradle提供了多种方式： 在build.gradle脚本中直接创建（上述代码即是） 在独立Module中创建（replugin-host-gradle即是） 继续看代码，addShowPluginTask(variant)这个方法执行了，但是方法内指定的task并未挂到android gradle task上，即task不会执行。这个task是方便调试时查看插件信息的，任务内容同接下来将讲到的生成 plugins-builtin.json 插件信息文件task一致。 checkUserConfig(config)，获取到AppConstant.USER_CONFIG内一系列参数后，做数据类型正确性校验。 关键代码来了，下面一行代码，搞定了宿主中AndroidManifest.xml中的组件坑位生成，注意，结合结构概览中的gradle Flow 看，这里只是生成组件坑位的xml代码，最终的xml文件是在后续的task中拼装出来的，稍后会讲到。1def newManifest = ComponentsGenerator.generateComponent(appID, config) 在代码面前，一切都是纸老虎。上车，进去看如何生成坑位的。 1234567891011121314151617181920212223242526272829303132333435363738394041def static generateComponent(def applicationID, def config) &#123; // 是否使用 AppCompat 库（涉及到默认主题） if (config.useAppCompat) &#123; themeNTS = THEME_NTS_NOT_APP_COMPAT &#125; else &#123; themeNTS = THEME_NTS_NOT_USE_APP_COMPAT &#125; def writer = new StringWriter() def xml = new MarkupBuilder(writer) /* UI 进程 */ xml.application &#123; /* 透明坑 */ config.countTranslucentStandard.times &#123; activity( \"$&#123;name&#125;\": \"$&#123;applicationID&#125;.$&#123;infix&#125;N1NRTS$&#123;it&#125;\", \"$&#123;cfg&#125;\": \"$&#123;cfgV&#125;\", \"$&#123;exp&#125;\": \"$&#123;expV&#125;\", \"$&#123;ori&#125;\": \"$&#123;oriV&#125;\", \"$&#123;theme&#125;\": \"$&#123;themeTS&#125;\") ... &#125; ... /* 不透明坑 */ config.countNotTranslucentStandard.times&#123; &#125; ... &#125; // 删除 application 标签 def normalStr = writer.toString().replace(\"&lt;application&gt;\", \"\").replace(\"&lt;/application&gt;\", \"\")// println \"$&#123;TAG&#125; normalStr: $&#123;normalStr&#125;\" // 将单进程和多进程的组件相加 normalStr + generateMultiProcessComponent(applicationID, config) &#125; 一定要用一句话总结的话，那就是:基于 Groovy 的 MarkupBuilder api，根据 RepluginConfig 类中的配置，拼出组件坑位的xml 字符串。就像搭积木一样，看一组就明白了。生成坑位的代码：12345678config.countTranslucentStandard.times &#123; activity( \"$&#123;name&#125;\": \"$&#123;applicationID&#125;.$&#123;infix&#125;N1NRTS$&#123;it&#125;\", \"$&#123;cfg&#125;\": \"$&#123;cfgV&#125;\", \"$&#123;exp&#125;\": \"$&#123;expV&#125;\", \"$&#123;ori&#125;\": \"$&#123;oriV&#125;\", \"$&#123;theme&#125;\": \"$&#123;themeTS&#125;\") &#125; 注：config.countTranslucentStandard.times 含义：根据config.countTranslucentStandard的值循环生成的坑位：123456&lt;activity android:theme=\"@ref/0x01030010\" android:name=\"com.qihoo360.replugin.sample.host.loader.a.ActivityN1NRTS0\" android:exported=\"false\" android:screenOrientation=\"1\" android:configChanges=\"0x4b0\" /&gt; 一个字总结：replace. Tips. 可以用Android Studio的Analyze APK…功能查看host gradle插件构建后宿主的AndroidManifest.xml，看看生成的坑位的样子就明白了。 ##生成 RePluginHostConfig 配置文件 12345678910111213141516171819202122232425262728293031323334353637@Override public void apply(Project project) &#123; ... if (project.plugins.hasPlugin(AppPlugin)) &#123; def android = project.extensions.getByType(AppExtension) android.applicationVariants.all &#123; variant -&gt; ... def variantData = variant.variantData def scope = variantData.scope //host generate task def generateHostConfigTaskName = scope.getTaskName(AppConstant.TASK_GENERATE, \"HostConfig\") def generateHostConfigTask = project.task(generateHostConfigTaskName) generateHostConfigTask.doLast &#123; FileCreators.createHostConfig(project, variant, config) &#125; generateHostConfigTask.group = AppConstant.TASKS_GROUP //depends on build config task String generateBuildConfigTaskName = variant.getVariantData().getScope().getGenerateBuildConfigTask().name def generateBuildConfigTask = project.tasks.getByName(generateBuildConfigTaskName) if (generateBuildConfigTask) &#123; generateHostConfigTask.dependsOn generateBuildConfigTask generateBuildConfigTask.finalizedBy generateHostConfigTask &#125; ... &#125; &#125; &#125; 继续回到 apply 方法，接下来该到生成 RePluginHostConfig 的时候了，即 注释中的host generate task。 首先生成了 HostConfig 的gradle task 名字，并调用project的task()方法创建此Task。 指定了 generateHostConfigTask 的task任务：自动创建RePluginHostConfig.java至BuildConfig目录。123generateHostConfigTask.doLast &#123; FileCreators.createHostConfig(project, variant, config)&#125; 注：createHostConfig(...)方法内的实现，也是根据配置类 RepluginConfig中的配置信息拼装生成的java文件。 设置generateHostConfigTask的执行依赖12345//depends on build config taskif (generateBuildConfigTask) &#123; generateHostConfigTask.dependsOn generateBuildConfigTask generateBuildConfigTask.finalizedBy generateHostConfigTask&#125; 因为此task中创建的RePluginHostConfig.java希望放置到编译输出目录..\\replugin-sample\\host\\app\\build\\generated\\source\\buildConfig\\{productFlavors}\\{buildTypes}\\...下，所以此task依赖于生成 BuildConfig.java 的task并设置为 BuildConfigTask 执行完后，就执行HostConfigTask。关于gradle 的 task 相关知识，可以去gradle 官网或某搜索引擎查看学习，属于字典型知识点，需要时候查阅下。 ##生成 plugins-builtin.json 插件信息文件 12345678910111213141516171819202122232425262728293031323334@Override public void apply(Project project) &#123; ... if (project.plugins.hasPlugin(AppPlugin)) &#123; def android = project.extensions.getByType(AppExtension) android.applicationVariants.all &#123; variant -&gt; ... //json generate task def generateBuiltinJsonTaskName = scope.getTaskName(AppConstant.TASK_GENERATE, \"BuiltinJson\") def generateBuiltinJsonTask = project.task(generateBuiltinJsonTaskName) generateBuiltinJsonTask.doLast &#123; FileCreators.createBuiltinJson(project, variant, config) &#125; generateBuiltinJsonTask.group = AppConstant.TASKS_GROUP //depends on mergeAssets Task String mergeAssetsTaskName = variant.getVariantData().getScope().getMergeAssetsTask().name def mergeAssetsTask = project.tasks.getByName(mergeAssetsTaskName) if (mergeAssetsTask) &#123; generateBuiltinJsonTask.dependsOn mergeAssetsTask mergeAssetsTask.finalizedBy generateBuiltinJsonTask &#125; ... &#125; &#125; &#125; 继续回到 apply 方法，接下来该到生成 plugins-builtin.json 这个包含了插件信息的文件的时候了，即 注释中的json generate task。 首先生成个gradle task 名字，并调用project的task()方法创建此Task。 指定了 generateBuiltinJsonTask 的task任务：扫描宿主\\assets\\plugins目录下的插件文件，并基于apk文件规则解析出插件信息，包名，版本号等，然后拼装成json文件。 123generateBuiltinJsonTask.doLast &#123; FileCreators.createBuiltinJson(project, variant, config)&#125; 设置 generateBuiltinJsonTask 的执行依赖 12345//depends on build config taskif (mergeAssetsTask) &#123; generateBuiltinJsonTask.dependsOn mergeAssetsTask mergeAssetsTask.finalizedBy generateBuiltinJsonTask&#125; 因为此task中创建的 plugins-builtin.json 希望放置到编译输出目录...\\replugin-sample\\host\\app\\build\\intermediates\\assets\\{productFlavors}\\{buildTypes}\\...下，所以此task依赖于merge assets文件 的task并设置为 mergeAssetsTask 执行完后，就执行BuiltinJsonTask。 ##拼装 AndroidManifest.xml12345output.processManifest.doLast &#123; def manifestPath = output.processManifest.outputFile.absolutePath def updatedContent = new File(manifestPath).getText(\"UTF-8\").replaceAll(\"&lt;/application&gt;\", newManifest + \"&lt;/application&gt;\") new File(manifestPath).write(updatedContent, 'UTF-8')&#125; 将坑位 xml 字符串 与 原有xml 标签内的配置信息合二为一。 至此，replugin-host-gradle 插件的工作就全部结束了。 ##Endreplugin-host-gradle 插件是一个compile-time gradle plugin，基于赋予android gradle 构建任务流中新的构建任务及修改已有的构建任务，进而实现动态修改构建目标文件的为replugin宿主服务的gradle插件。","comments":true,"tags":[{"name":"RePlugin","slug":"RePlugin","permalink":"https://wangfuda.github.io/tags/RePlugin/"},{"name":"Gradle","slug":"Gradle","permalink":"https://wangfuda.github.io/tags/Gradle/"},{"name":"replugin-host-gradle","slug":"replugin-host-gradle","permalink":"https://wangfuda.github.io/tags/replugin-host-gradle/"}]},{"title":"自定义View星空动画的内存占用/GPU渲染性能优化手记","date":"2017-07-09T00:55:00.000Z","path":"2017/07/09/nebula_gpu_monitor_optimize/","text":"这是一个关于星空的自定义动画Sample,源码请戳 https://github.com/wangfuda/nebula Gif图： 本文将重点讲解在本例自定义动画编程中，如何结合 Android Studio 的 Memory Monitor，GPU monitor 按步骤做内存优化，GPU渲染优化。关于动画实现部分，源码已提交至github，请手动阅读理解，注释很详尽。 内存占用优化内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi.先来彪一张直接撸完代码无任何优化的情况下，内存的占用图： 内存占用246M，不能忍。问：为什么这么大？答：因为资源图都是高清1K分辨率的图。问：为什么这么大？答：。。。那么我们算一下这246M内存占用是怎么来的吧。先来一条图片内存占用计算公式，公式溯源请自行去看源码：BitmapFactory.Java &amp; BitmapFactory.cppscaledWidth = int( Width targetDensity / density + 0.5)scaledHeight = int( Height targetDensity / density + 0.5)memory = scaledWidth scaledHeight 4其中参数定义如下： Width：图片宽Height：图片高targetDensity：加载图片的目标手机的 density，这个值的来源是 DisplayMetrics 的 densityDpi，如果是小米note那么这个数值就是480，详见下图关于targetDensity的参数细节。density：decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 hdpi 是240，xxhdpi 是480）每像素字节数：ARGB8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte。 对于一张1080x1920的图来说，放置在hdpi目录，并在小米note手机上（分辨率1080x1920,targetDensity为480），而且均默认以ARGB8888格式加载。内存占用计算公式：scaledWidth = int( 1080 480/ 240+ 0.5) =2160scaledHeight = int( 1920 480/ 240+ 0.5)=3840memory = scaledWidth scaledHeight 4=216038404 = 33177600 = 33.17M 一张背景图就占用33M,这个分辨率的图，我们res下一共有7张，还有其他几张小图。这回可以回答为什么占用245M的内存了。 那么内存占用的优化方案也就有了，我们尽量把图片资源放到大分辨率目录下，比如xxxhdpi（当然还有个前提，你的图片分辨率也确实符合大分辨率，否则会出现在大分辨率设备上，显示不全的问题）。 我们来看看把图片资源移动到xxxhdpi目录下后，内存占用情况： 把图片资源从hdpi移动到xxx-hdpi，从246M降低到56M,减少了190M，Bingo! 内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）初始单张图片大小都接近2M，经过tinypng优化后，压缩率达到70-80%，非常完美，包体大小减小了，不过，经过我们步骤一的科学计算，这个优化并不会影响图片在内存中的占用。 内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放12345public void releaseBitmap &#123; ... bitmap.recycle(); ...&#125; 来看下bitmap释放后的memory monitor图： 内存占用降低到36M,减少了20M 内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2123456789101112public void releaseValueAnimator &#123; ... valueAnimator = null; ...&#125;public void initBitmap &#123; ... localOptions.inSampleSize = 2; localOptions.inPreferredConfig = Bitmap.Config.RGB_565; ...&#125; 来看下变更图片颜色格式及采样率后的memory monitor图： 内存占用降低到28M,减少了8M（后来monitor截图只对背景图片做inPreferredConfig调整，内存占用变为30M,相比全部设置为2，增加了2M） ##GPU渲染优化接下来我们要专注于GPU渲染优化了。通过前面几张图，也能看到GPU monitor的状态，非常不乐观，完全达不到帧率刷新的要求：即每帧渲染不超过16ms，每秒可以渲染60帧。先看GPU Monitor的各项指标含义： Misc Time：表示在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况；出现该线条的时候，可以在Log中看到这样的日志： Skipped xxx frames! The application may be doing too much work on its main thread Swap Buffers：表示处理任务的时间，也可以说是CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多； Command Issue：表示执行任务的时间，这部分主要是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，红色线条越高表示需要绘制的视图更多； Sync：表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小； Draw：表示测量和绘制视图列表所需要的时间，蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作； Measure/Layout：表示布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题； Animation：表示计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等； Input Handling：表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作；Vsync Delay：见Misc Time GPU渲染优化 步骤一：优化内存占用可以回过头去看看内存优化过程演进中的Monitor图，随着内存占用的降低，GPU渲染的性能改善也是随之渐进的，所以GPU渲染性能优化，首选就是内存优化 GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。在sample代码中重构了onDraw中的画笔的属性设置，绘制区域的创建等代码，这些代码都重构到初始化中。而在onDraw中仅做参数值的动态调整。 Tips.本例Sample最初始未经过任何优化的代码及最终优化版本代码均在github上可以查看到commit记录，这里不再写详细代码对比，请移动github阅读源码。 我们看下重构前后的对比图monitor_5_bitmap_RGB_565_inSampleSize2.png Vs monitor_6_gpu_optimize_object_and_paint_create.png，对比发现，GPU渲染耗时明显降低。 我们暂时先对比看GPU Monitor的 0s ~ 9s 部分的性能改善，目前GPU优化主要在这里体现，因为后半部分各位爷看到了，GPU渲染耗时飙升，掉帧严重，那部分的优化在后续步骤会提到。 重构前 GPU Monitor： 重构后 GPU Monitor： GPU渲染优化 步骤三：能用硬件加速，就别关闭它。我们都看到了，在GPU Monitor中显示，9s后的GPU渲染，每帧耗时突然飙升，每帧渲染都是超60ms，Draw上升至172ms，Vsync上升至148ms.而且在logcat中也看到日志：07-09 11:17:57.135 15980-15980/com.osan.nebula I/Choreographer: Skipped 31 frames! The application may be doing too much work on its main thread.每帧超时，掉帧严重。到底是什么原因呢？经过反复的排查，终于找到原因，我们来聊聊这个飙升的来龙去脉。由于在后半部分的动画中，绘制小星星的光晕效果时，使用的画笔设置了模糊属性，为了给小星星加个光晕效果。1paintCircleStar.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.SOLID)); 然后google官方文档都说了，硬件加速不支持的UI特效API之一就有它。也就是你要用硬件加速，这个模糊效果就失效。所以我一门心思的为了给小星星加光晕… 光晕…晕…，最后我选择了关闭硬件加速123456789private void drawState7(Canvas canvas) &#123; ... canvas.save(); setLayerType(LAYER_TYPE_SOFTWARE, null);//关闭硬件加速 canvas.translate(halfWidth, halfHeight); canvas.scale(scale, scale); canvas.rotate(30f * mValue7); ...&#125; 呵呵，为了小星星，闯祸了。因为本例动画中，各种对画布的旋转，缩放，变换，透明度动态变化，在非硬件加速情况下，不停的重新绘制，是GPU渲染耗时飙升的唯一原因。我们来看看开启硬件加速的情况下，GPU Monitor的指标监控： 恢复硬件加速后，渲染耗时立刻恢复到绿线以下，即每帧渲染不超过16ms，达到渲染标准。而且，CPU消耗也明显下降。那么为什么硬件加速有如此神奇之功效？使用硬件加速在对一些view的属性改变上有更高的效率，因为不需要view的invalidate和redrawn。而我们动画中正式大量使用了对属性的改变。属性如: 透明度：alpha移动：x, y, translationX, translationY缩放：scaleX, scaleY旋转：rotation, rotationX, rotationY坐标：pivotX, pivotY 注：1）使用硬件加速，对于渲染性能的提示是显著的，API&gt;14后，硬件加速是默认开启的。2）硬件加速还不支持所有的2D绘图命令，开启后可能会影响自定义View和绘图操作。 GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算涉及计算任务，能不在ondraw中执行的，就坚决移走，即使只是一个a*b或a/b.因为我们继续重构了onDraw方法，将可能优化的运算代码均做了优化，能放到初始化做的就移到初始化，能提炼共用的运算公式就共用，能不重复算的就绝对不算第二遍。我们来看看优化算数运算后，GPU Monitor的指标监控： 相比步骤三中的GPU Monitor指标有了进一步降低，虽然降低幅度很小，但是还是对GPU渲染性能提升有效果的，而且观察发现，优化后，CPU和GPU的指标看起来更平稳。 最后附上一张coding过程中的草图以及nebula自定义动画的截图","comments":true,"tags":[{"name":"自定义View","slug":"自定义View","permalink":"https://wangfuda.github.io/tags/自定义View/"},{"name":"自定义动画","slug":"自定义动画","permalink":"https://wangfuda.github.io/tags/自定义动画/"},{"name":"GPU Monior","slug":"GPU-Monior","permalink":"https://wangfuda.github.io/tags/GPU-Monior/"}]},{"title":"Retrofit 2.3.0 源码解析","date":"2017-07-01T07:24:47.838Z","path":"2017/07/01/Retrofit-2.3.0-code-explain/","text":"前言 Retrofit A type-safe HTTP client for Android and Java Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。 基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。 结构概览 项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall这里我们把基于Retrofit的HTTP通信比做是邮递信件。 邮递信件 信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。 邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。 邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理 邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。 基于Retrofit的HTTP通信 Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。 Proxy：然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等 Invocation：这里负责调度同步或异步请求，请求装配和响应解析 RawCall：这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。 来看看寄信和Retrofit之间的对比： 大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。 目录概览官方 Javadoc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647│ BuiltInConverters.java # 内建Converter│ Call.java # 发送请求接收响应的retrofit方法调用│ CallAdapter.java # 适配Call的响应类型，将默认响应类型R转换为类型T│ Callback.java # 返回服务端或离线请求的响应体│ Converter.java # HTTP交互中，转换对象为数据 或 从数据转换为对象│ DefaultCallAdapterFactory.java # 默认CallAdapter工厂│ ExecutorCallAdapterFactory.java # http请求执行器工厂│ HttpException.java # 非2xx HTTP响应的异常处理│ OkHttpCall.java # 真正调用OkHttp3发送Http请求的类│ package-info.java # 包描述│ ParameterHandler.java # 参数注解解析器│ Platform.java # 平台适配(Java/Android)│ RequestBuilder.java # 请求拼装│ Response.java # 原汁原味的HTTP 响应体，所谓 T body│ Retrofit.java # 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口│ ServiceMethod.java # 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请 # 求头、是否是multipart等等),并返回用于发起http请求的Call对象│ Utils.java # 工具类│ └─http # http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解） Body.java # control the request body of a POST/PUT request DELETE.java # Make a DELETE request Field.java # Named pair for a form-encoded request FieldMap.java # Named key/value pairs for a form-encoded request FormUrlEncoded.java # Denotes that the request body will use form URL encoding GET.java # Make a GET request HEAD.java # Make a HEAD request Header.java # Replaces the header with the value of its target HeaderMap.java # Adds headers specified in the Map Headers.java # Adds headers literally supplied in the value HTTP.java # Use a custom HTTP verb for a request Multipart.java # Denotes that the request body is multi-part OPTIONS.java # Make an OPTIONS request package-info.java # Package description Part.java # Denotes a single part of a multi-part request PartMap.java # Denotes name and value parts of a multi-part request PATCH.java # Make a PATCH request Path.java # Named replacement in a URL path segment POST.java # Make a POST request PUT.java # Make a PUT request Query.java # Query parameter appended to the URL QueryMap.java # Query parameter keys and values appended to the URL QueryName.java # Query parameter appended to the URL that has no value Streaming.java # Treat the response body on methods returning Response as is, i.e. # without converting body() to byte[] Url.java # URL resolved against the base URL Retrofit的基本用法让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。 用 Java 接口的方式定义一个HTTP API.1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; Retrofit 类生成一个 GitHubService 接口的实现实例.12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class); Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); 执行同步或异步HTTP请求，得到HTTP响应数据.1Response&lt;List&lt;Repo&gt;&gt; response = repos.execute(); Retrofit的源码解析首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器 Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。 下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall. Flow - Builder Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) ... .build();Tips.设计模式之Builder模式 基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。123456789// Retrofit.java -&gt; class Builderpublic Retrofit build() &#123; ... return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。注：validateEagerly，用于指定是否预先解析注解，加速接口访问效率。 Flow - Proxy GitHubService service = retrofit.create(GitHubService.class);我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。123456789101112131415161718192021222324252627// Retrofit.java public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。为什么用动态代理？这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。 Tips.动态代理 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。 invoke中主要由ServiceMethod和CallAdapter完成了三件事： 请求方法的注解解析 创建OkHttpCall实例，为后续流程中的HTTP请求执行做准备，详见 Flow - Invocation. 适配Call的响应类型，将默认响应类型R转换为类型T 1234ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); ServiceMethod.java12345678910111213141516171819202122232425262728293031323334// ServiceMethod.javapublic ServiceMethod build() &#123; callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); ... responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; ... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; ... Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; ... parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; ... return new ServiceMethod&lt;&gt;(this); &#125; 获取callAdapter、responseType、responseConverter接口对象 解析Method的注解 解析Method的参数注解 解析Method的参数中使用了依赖请求API的动态参数的注解，交由ParameterHandler处理 CallAdapter.java1234567891011public interface CallAdapter&lt;R, T&gt; &#123; Type responseType(); ... T adapt(Call&lt;R&gt; call); ... &#125; 适配Call的响应类型，将默认响应类型R转换为类型T.比如官方的RxJavaCallAdapter可以结合Rxjava特性对Call的响应做RxJava观察者模式转换，进一步解放生产力。 注：未在Builder阶段指定CallAdapter(如 RxJavaCallAdapterFactory )的情况下，默认的 CallAdapter 不对Call做任何处理。见 DefaultCallAdapterFactory:1234567891011final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123; static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory(); ... ... @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return call; &#125; &#125;&#125; Flow - Invocation Response&lt;List&lt;Repo&gt;&gt; response = repos.execute(); 这一步开始基于同步的方式执行HTTP请求，并得到返回的HTTP响应数据. 本质上是执行了 OkHttpCall 的 execute方法.12345678910111213141516// OkHttpCall.java@Override public Response&lt;T&gt; execute() throws IOException &#123; synchronized (this) &#123; ... ... call = rawCall = createRawCall(); &#125; ... return parseResponse(call.execute()); &#125; 如你所见，这里创建了RawCall，即真正的去执行HTTP请求任务的对象。这里还负责HTTP请求的响应数据解析。我们看下createRawCall()干了什么。 12345678// OkHttpCall.javaprivate okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); ... return call; &#125; serviceMethod.toRequest()的功能：1234567891011// ServiceMethod.java/** Builds an HTTP request from method arguments. */ Request toRequest(@Nullable Object... args) throws IOException &#123; RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ... return requestBuilder.build(); &#125; toRequest 方法通过 RequestBuilder 创建了 okhttp3 做 HTTP 请求时需要的 Request 对象。 serviceMethod.callFactory.newCall(request)的功能：建立一个请求通道，为执行HTTP请求做准备。这里callFactory可以由使用者指定，默认为 OkHttpClient，见：123456// Retrofit.javaokhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; 回头看下 OkHttpCall 中 execute 方法最后一句: return parseResponse(call.execute());这里调用真正的HTTP请求客户端的请求执行方法。也就是来到了接下来的一个流程。 Flow - RawCall 上个 Flow 中最后一步， call.execute(),开启了真正的HTTP请求，即通过 okhttp3 完成HTTP请求。这个部分没什么代码可讲，属于面向接口开发的典范，要讲就该去讲 Okhttp 框架的源码了。 这个部分引出了 Retrofit 的开源拥有者-Square 公司的另一个优秀的开源项目 Okhttp,是不是也很想一探究竟？ End最后我想拿 Retrofit 官方的一段话来结束： Contributing If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running mvn clean verify. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA). 纳尼？ Cos 我想把亲手画的两副图贡献给 Retrofit.","comments":true,"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangfuda.github.io/tags/Retrofit/"},{"name":"okhttp","slug":"okhttp","permalink":"https://wangfuda.github.io/tags/okhttp/"},{"name":"http","slug":"http","permalink":"https://wangfuda.github.io/tags/http/"},{"name":"restful api","slug":"restful-api","permalink":"https://wangfuda.github.io/tags/restful-api/"}]},{"title":"todo-mvp-dagger 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/todo-mvp-dagger-code-explain/","text":"前言 android-architectureThe Android Architecture Blueprints project demonstrates strategies to help solve or avoid these common problems. This project implements the same app using different architectural concepts and tools. 敬请期待。","comments":true,"tags":[{"name":"mvp","slug":"mvp","permalink":"https://wangfuda.github.io/tags/mvp/"},{"name":"dagger","slug":"dagger","permalink":"https://wangfuda.github.io/tags/dagger/"},{"name":"android architecture","slug":"android-architecture","permalink":"https://wangfuda.github.io/tags/android-architecture/"}]},{"title":"vue-hackernews-2.0 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/vue-hackernews-2.0-code-explain/","text":"前言 HackerNews是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。 vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。 结构概览 项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。 客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过app.$mount(&#39;#app&#39;)挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行Hydration（合并） 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748│ manifest.json # progressive web apps配置文件│ package.json # 项目配置文件│ server.js # 服务端渲染│ ├─public # 静态资源│ logo-120.png│ logo-144.png│ logo-152.png│ logo-192.png│ logo-384.png│ logo-48.png│ └─src │ app.js # 整合 router,filters,vuex 的入口文件 │ App.vue # 根 vue 组件 │ entry-client.js # client 的入口文件 │ entry-server.js # server 的入口文件 │ index.template.html # html 模板 │ ├─api │ create-api-client.js # Client数据源配置 │ create-api-server.js # server数据源配置 │ index.js # 数据请求API │ ├─components │ Comment.vue # 评论组件 │ Item.vue # │ ProgressBar.vue # 进度条组件 │ Spinner.vue # 加载提示组件 │ ├─router │ index.js # router配置 │ ├─store # Vue store模块 │ actions.js # 根级别的 action │ getters.js # 属性接口 │ index.js # 我们组装模块并导出 store 的地方 │ mutations.js # 根级别的 mutation │ ├─util │ filters.js # 过滤器 │ title.js # 工具类 │ └─views CreateListView.js # 动态生成列表界面的工厂方法 ItemList.vue # List界面组件 ItemView.vue # 单List项组件 UserView.vue # 用户界面组件 本项目包含开发环境及生产环境，我们先学习开发环境。 开发环境的服务端渲染流程让我们从node环境下执行命令开始。12# serve in dev mode, with hot reload at localhost:8080$npm run dev 然后发生了什么？我们来看一张图。 Tips:package.json解读 上述执行dev属性对应的脚本：node server即node server.js，即执行server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768···const app = express()// 服务端渲染的HTML模板const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer // 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中 return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125;let rendererlet readyPromiseif (isProd) &#123; // 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle const bundle = require('./dist/vue-ssr-server-bundle.json') //client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能 const clientManifest = require('./dist/vue-ssr-client-manifest.json') //vue-server-renderer创建bundle渲染器并绑定server bundle renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; // 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回 // 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新 //以及通过webpack的watch功能实现服务端代码的热更新 readyPromise = require('./build/setup-dev-server')(app, (bundle, options) =&gt; &#123; // 基于热更新，回调生成最新的bundle渲染器 renderer = createRenderer(bundle, options) &#125;)&#125;//依次装载一系列Express中间件，用来处理静态资源，数据压缩等···app.use(···)···function render (req, res) &#123; ··· // 设置请求的url const context = &#123; title: 'Vue HN 2.0', // default title url: req.url &#125; // 为渲染器绑定的server bundle（即entry-server.js）设置入参context renderer.renderToString(context, (err, html) =&gt; &#123; ··· res.end(html) ··· &#125;)&#125;//启动一个服务并监听从 8080 端口进入的所有连接请求。app.get('*', isProd ? render : (req, res) =&gt; &#123; readyPromise.then(() =&gt; render(req, res))&#125;)const port = process.env.PORT || 8080app.listen(port, () =&gt; &#123; console.log(`server started at localhost:$&#123;port&#125;`)&#125;) Tips1.vue-server-renderer(Vue服务端渲染，同时支持prefetch、prerender特性)2.webpack-dev-server(webpack-dev-middleware/webpack-hot-middleware)3.此项目全面使用ES6语法，包括箭头函数，解构赋值，Promise等特性。 server.js最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080请求经由express路由接收后，执行处理逻辑:readyPromise.then(() =&gt; render(req, res))沿着Promise的调用链处理：开发环境下1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。最终通过回调把生成在内存中的server bundle传回。2.创建渲染器，绑定server bundle，设置渲染模板，缓存等3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等4.最后将渲染好的HTML写入http响应体，传回浏览器。 接下来分解解读下这几个的实现。 setup-dev-server看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色） build/setup-dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// setup-dev-server.jsconst clientConfig = require('./webpack.client.config')const serverConfig = require('./webpack.server.config')module.exports = function setupDevServer (app, cb) &#123; let bundle, clientManifest let resolve const readyPromise = new Promise(r =&gt; &#123; resolve = r &#125;) const ready = (...args) =&gt; &#123; resolve() cb(...args) &#125; // 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem // 读取内存中的bundle 并通过传入的回调更新server.js中的bundle clientCompiler.plugin('done', () =&gt; &#123; const fs = devMiddleware.fileSystem const readFile = file =&gt; fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') clientManifest = JSON.parse(readFile('vue-ssr-client-manifest.json')) if (bundle) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) // hot middleware app.use(require('webpack-hot-middleware')(clientCompiler)) // watch and update server renderer const serverCompiler = webpack(serverConfig) // 获取基于memory-fs创建的内存文件系统对象 const mfs = new MFS() serverCompiler.outputFileSystem = mfs // 设置文件重新编译监听并通过传入的回调更新server.js中的bundle serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err stats = stats.toJson() stats.errors.forEach(err =&gt; console.error(err)) stats.warnings.forEach(err =&gt; console.warn(err)) const readFile = file =&gt; mfs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile('vue-ssr-server-bundle.json')) if (clientManifest) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) return readyPromise&#125; build/webpack.base.config.js 123456789101112131415161718192021222324252627282930313233343536// build/webpack.base.config.jsmodule.exports = &#123; // 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map devtool: isProd ? false : '#cheap-module-source-map', // 打包输出配置 output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/', filename: '[name].[chunkhash].js' &#125;, resolve: &#123; alias: &#123; 'public': path.resolve(__dirname, '../public') &#125; &#125;, module: &#123; ··· // 一系列加载器 &#125;, plugins:[ // 压缩js的插件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来 new ExtractTextPlugin(&#123; &#125;) ]&#125; build/webpack.client.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041// build/webpack.client.config.js// 基于webpack-merge工具合并base以及client特定配置项const config = merge(base, &#123; // 配置编译的入口文件 entry: &#123; app: './src/entry-client.js' &#125;, // 在alias设置客户端数据请求API为create-api-client.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-client.js' &#125; &#125;, plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"client\"' &#125;), // 设置打包时公共模块的提取规则 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // a module is extracted into the vendor chunk if... return ( // it's inside node_modules /node_modules/.test(module.context) &amp;&amp; // and not a CSS file (due to extract-text-webpack-plugin limitation) !/\\.css$/.test(module.request) ) &#125; &#125;), // 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name， // 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new VueSSRClientPlugin() ]&#125;) bulid/webpack.server.config.js 1234567891011121314151617181920212223242526272829303132333435// build/webpack.server.config.jsmodule.exports = merge(base, &#123; // 指定生成后的运行环境在node target: 'node', // 设置代码调试map devtool: '#source-map', // 配置编译的入口文件 entry: './src/entry-server.js', // 设置输出文件名，并设置模块导出为commonjs2类型 output: &#123; filename: 'server-bundle.js', libraryTarget: 'commonjs2' &#125;, // 在alias设置好服务端数据请求API为create-api-server.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-server.js' &#125; &#125;, // 设置不打包排除规则 externals: nodeExternals(&#123; // do not externalize CSS files in case we need to import it from a dep whitelist: /\\.css$/ &#125;), plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"server\"' &#125;), //设置VueSSRServerPlugin插件 new VueSSRServerPlugin() ]&#125;) 如上，基于 webpack config 的setup-dev-server就到这里，接下来说创建渲染器。 创建渲染器12345678910function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer console.log(`createRenderer`) return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125; 创建渲染器时重点两件事：1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件entry-server.js打包生成的。当渲染器调用renderer.renderToString开始渲染时，会执行该入口文件的默认方法。2.传入了一个html模板index.template.html，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。 Tips:index.template.html解读 顺着readyPromise.then的调用链，接下来调用render方法123456function render (req, res) &#123;··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) &#125;)&#125; renderer.renderToString方法内部会先调用入口模块entry-server.js的默认方法，我们看下entry-server.js主要做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// This exported function will be called by `bundleRenderer`.// This is where we perform data-prefetching to determine the// state of our application before actually rendering it.// Since data fetching is async, this function is expected to// return a Promise that resolves to the app instance.export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const s = isDev &amp;&amp; Date.now() const &#123; app, router, store &#125; = createApp() // set router's location // 手动路由切换到请求的url，即'/' router.push(context.url) // wait until router has resolved possible async hooks router.onReady(() =&gt; &#123; // 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js const matchedComponents = router.getMatchedComponents() // no matched routes if (!matchedComponents.length) &#123; reject(&#123; code: 404 &#125;) &#125; // Call fetchData hooks on components matched by the route. // A preFetch hook dispatches a store action and returns a Promise, // which is resolved when the action is complete and store state has been // updated. // 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据 Promise.all(matchedComponents.map(component =&gt; &#123; return component.asyncData &amp;&amp; component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125;)).then(() =&gt; &#123; isDev &amp;&amp; console.log(`data pre-fetch: $&#123;Date.now() - s&#125;ms`) // After all preFetch hooks are resolved, our store is now // filled with the state needed to render the app. // Expose the state on the render context, and let the request handler // inline the state in the HTML response. This allows the client-side // store to pick-up the server-side state without having to duplicate // the initial data fetching on the client. // 把vuex的state设置到传入的context.initialState上 context.state = store.state // 返回state, router已经设置好的Vue实例app resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; entry-server.js的主要工作：0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。1.手动路由切换到请求的url，即’/‘2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js） Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：服务端渲染时的数据预取流程 还记得index.template.html被设置到template属性中吗？此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？123&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt; 就是这里，这个&lt;!--vue-ssr-outlet--&gt;Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template. 接下来，Vue渲染器会回调callback方法，我们回到server.js123456789101112function render (req, res) &#123; ··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) ··· &#125;)&#125; 此时只需要将渲染好的html写入http响应体就结束了，浏览器客户端就可以看到页面了。 接下来我们看看服务端数据预取的实现 服务端渲染时的数据预取流程上文提到，服务端渲染时，会手动将路由导航到请求地址即&#39;/&#39;下，然后调用该路由组件的asyncData方法来预取数据 那么我们看看路由配置 12345678910111213141516171819202122232425// /src/router/index.jsVue.use(Router)// route-level code splittingconst createListView = id =&gt; () =&gt; System.import('../views/CreateListView').then(m =&gt; m.default(id))const ItemView = () =&gt; System.import('../views/ItemView.vue')const UserView = () =&gt; System.import('../views/UserView.vue')export function createRouter () &#123; return new Router(&#123; mode: 'history', scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [ &#123; path: '/top/:page(\\\\d+)?', component: createListView('top') &#125;, &#123; path: '/new/:page(\\\\d+)?', component: createListView('new') &#125;, &#123; path: '/show/:page(\\\\d+)?', component: createListView('show') &#125;, &#123; path: '/ask/:page(\\\\d+)?', component: createListView('ask') &#125;, &#123; path: '/job/:page(\\\\d+)?', component: createListView('job') &#125;, &#123; path: '/item/:id(\\\\d+)', component: ItemView &#125;, &#123; path: '/user/:id', component: UserView &#125;, &#123; path: '/', redirect: '/top' &#125; ] &#125;)&#125; 地址&#39;/&#39;是做了redirect到&#39;/top&#39;,其实就是默认地址就是到top页面，在看第一条路由配置，&#39;/top&#39;路由对应的组件是createListView(&#39;top&#39;) 12345678910111213141516171819// /src/views/CreateListView.jsexport default function createListView (type) &#123; return &#123; name: `$&#123;type&#125;-stories-view`, asyncData (&#123; store &#125;) &#123; console.log(`createListView asyncData`) return store.dispatch('FETCH_LIST_DATA', &#123; type &#125;) &#125;, title: camelize(type), render (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; &#125;&#125; Tips: Vuex状态管理1.dispatch对应Action，commit对应mutation2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。 Vuex state状态变更流程 asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store. 最后数据就都保存在store这里了。12345678910111213141516171819202122// /src/store/index.jsexport function createStore () &#123; return new Vuex.Store(&#123; state: &#123; activeType: null, itemsPerPage: 20, items: &#123;/* [id: number]: Item */&#125;, users: &#123;/* [id: string]: User */&#125;, lists: &#123; top: [/* number */], new: [], show: [], ask: [], job: [] &#125; &#125;, actions, mutations, getters &#125;)&#125; 然后将开始通过Render 函数创建HTML。 123456// /src/views/CreateListView.jsrender (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; 123456789101112131415161718192021222324// /src/views/ItemList.vue···&lt;template&gt; &lt;div class=\"news-view\"&gt; &lt;div class=\"news-list-nav\"&gt; &lt;router-link v-if=\"page &gt; 1\" :to=\"'/' + type + '/' + (page - 1)\"&gt;&amp;lt; prev&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;&amp;lt; prev&lt;/a&gt; &lt;span&gt;&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;&lt;/span&gt; &lt;router-link v-if=\"hasMore\" :to=\"'/' + type + '/' + (page + 1)\"&gt;more &amp;gt;&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;more &amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;transition :name=\"transition\"&gt; &lt;div class=\"news-list\" :key=\"displayedPage\" v-if=\"displayedPage &gt; 0\"&gt; &lt;transition-group tag=\"ul\" name=\"item\"&gt; &lt;item v-for=\"item in displayedItems\" :key=\"item.id\" :item=\"item\"&gt; &lt;/item&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;··· 这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的&lt;!--vue-ssr-outlet--&gt;,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。 Tips:后续更新内容规划：1.生产环境下的服务端渲染逻辑流程2.客户端渲染逻辑流程3.客户端vue组件细节解读","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]},{"title":"vue-hackernews-2.0 细节解读","date":"2017-05-12T16:00:00.000Z","path":"2017/05/13/vue-hackernews-2.0-code-detail/","text":"前言本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对项目源码解读的细节补充。 package.json解读该文件提供了四种命令1234567891011# install dependenciesnpm install # or yarn# serve in dev mode, with hot reload at localhost:8080npm run dev# build for productionnpm run build# serve in production modenpm start 执行npm install查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。 Tips:dependencies与devDependencies的区别devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。 执行npm run dev1234567\"scripts\": &#123;\"dev\": \"node server\",\"start\": \"cross-env NODE_ENV=production node server\",\"build\": \"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server\",\"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules\",\"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules\"&#125;, 查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：node server即node server.js，即执行server.js 执行npm run build同样，找到build属性，并执行：rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server，即删除dist目录并执行npm run build:client和npm run build:server对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件 执行npm start同样，找到start属性，并执行：cross-env NODE_ENV=production node server，即通过cross-env模块设置NODE_ENV环境变量为production，并执行node server Tips:为什么是npm start而不是npm run start?1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见npm --help2.其他三个命令都不是内置命令，需要经由npm run去执行。 index.template.html解读12345&lt;meta name=\"mobile-web-app-capable\" content=\"yes\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\"&gt;&lt;link rel=\"shortcut icon\" sizes=\"48x48\" href=\"/public/logo-48.png\"&gt;&lt;meta name=\"theme-color\" content=\"#f60\"&gt;&lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; 这段html代码功能：移动端浏览器适配及PWA适配 Tips:PWA (progressive web apps)-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。 接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。浏览器体验：在Chrome浏览器地址栏中输入项目地址，效果如下： PWA体验：通过Chrome的Add to Homescreen功能，将该站点添加到桌面。效果如下： 点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。 现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：123456789101112//1. 主题色：绿色 启动图背景色：白色\"background_color\": \"#f2f3f5\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//2. 主题色：绿色 启动图背景色：绿色\"background_color\": \"#48BB74\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//3. 主题色：橙色 启动图背景色：橙色\"background_color\": \"#f60\",\"display\": \"standalone\",\"theme_color\": \"#f60\" Tips:这里用到的manifest.json不要与作为离线缓存的manifest混淆。 最后来对比感受下非PWA的百度站点VsPWA站点的hackernews在Add to HomeScreen后，体验上的差异。 概括下主要的差异：1.增加了同原生应用一样的启动图过渡界面2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。注：PWA更多的特性这里并未应用，其实PWA可以做的更多。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]}]