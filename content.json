[{"title":"Retrofit 2.3.0 源码解析","date":"2017-07-01T07:24:47.838Z","path":"2017/07/01/Retrofit-2.3.0-code-explain/","text":"前言 Retrofit A type-safe HTTP client for Android and Java Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。 基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。 结构概览 项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall这里我们把基于Retrofit的HTTP通信当做是一次邮递信件。 邮递信件 信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。 邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。 邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理 邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。 基于Retrofit的HTTP通信 Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。 Proxy:然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等 Invocation：这里负责调度同步或异步请求，请求装配和响应解析 RawCall:这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。 来看看寄信和Retrofit之间的对比： 大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。 目录概览官方 Javadoc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647│ BuiltInConverters.java # 内建Converter│ Call.java # 发送请求接收响应的retrofit方法调用│ CallAdapter.java # 适配Call的响应类型，将默认响应类型R转换为类型T│ Callback.java # 返回服务端或离线请求的响应体│ Converter.java # HTTP交互中，转换对象为数据 或 从数据转换为对象│ DefaultCallAdapterFactory.java # 默认CallAdapter工厂│ ExecutorCallAdapterFactory.java # http请求执行器工厂│ HttpException.java # 非2xx HTTP响应的异常处理│ OkHttpCall.java # 真正调用OkHttp3发送Http请求的类│ package-info.java # 包描述│ ParameterHandler.java # 参数注解解析器│ Platform.java # 平台适配(Java/Android)│ RequestBuilder.java # 请求拼装│ Response.java # 原汁原味的HTTP 响应体，所谓 T body│ Retrofit.java # 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口│ ServiceMethod.java # 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请 # 求头、是否是multipart等等),并返回用于发起http请求的Call对象│ Utils.java # 工具类│ └─http # http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解） Body.java # control the request body of a POST/PUT request DELETE.java # Make a DELETE request Field.java # Named pair for a form-encoded request FieldMap.java # Named key/value pairs for a form-encoded request FormUrlEncoded.java # Denotes that the request body will use form URL encoding GET.java # Make a GET request HEAD.java # Make a HEAD request Header.java # Replaces the header with the value of its target HeaderMap.java # Adds headers specified in the Map Headers.java # Adds headers literally supplied in the value HTTP.java # Use a custom HTTP verb for a request Multipart.java # Denotes that the request body is multi-part OPTIONS.java # Make an OPTIONS request package-info.java # Package description Part.java # Denotes a single part of a multi-part request PartMap.java # Denotes name and value parts of a multi-part request PATCH.java # Make a PATCH request Path.java # Named replacement in a URL path segment POST.java # Make a POST request PUT.java # Make a PUT request Query.java # Query parameter appended to the URL QueryMap.java # Query parameter keys and values appended to the URL QueryName.java # Query parameter appended to the URL that has no value Streaming.java # Treat the response body on methods returning Response as is, i.e. # without converting body() to byte[] Url.java # URL resolved against the base URL Retrofit的基本用法让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。 用 Java 接口的方式定义一个HTTP API.1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; Retrofit 类生成一个 GitHubService 接口的实现实例.12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class); Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); Retrofit的源码解析首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器 Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。 下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall Flow - Builder Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) ... .build(); Tips.设计模式之Builder模式基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。123456789// Retrofit.java -&gt; class Builderpublic Retrofit build() &#123; ... return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。注：validateEagerly，用于指定是否预先解析注解，加速接口访问效率。 Flow - Proxy GitHubService service = retrofit.create(GitHubService.class);我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。123456789101112131415161718192021222324252627// Retrofit.java public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。为什么用动态代理？这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。 Tips.动态代理 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。 invoke中主要由ServiceMethod和CallAdapter完成了两件事： 请求方法的注解解析 适配Call的响应类型，将默认响应类型R转换为类型T 12345678910111213141516171819202122232425262728293031323334// ServiceMethod.javapublic ServiceMethod build() &#123; callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); ... responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; ... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; ... Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; ... parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; ... return new ServiceMethod&lt;&gt;(this); &#125; 12 Flow - Invocation Flow - RawCall","comments":true,"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangfuda.github.io/tags/Retrofit/"},{"name":"okhttp","slug":"okhttp","permalink":"https://wangfuda.github.io/tags/okhttp/"},{"name":"http","slug":"http","permalink":"https://wangfuda.github.io/tags/http/"},{"name":"restful api","slug":"restful-api","permalink":"https://wangfuda.github.io/tags/restful-api/"}]},{"title":"vue-hackernews-2.0 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/vue-hackernews-2.0-code-explain/","text":"前言 HackerNews是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。 vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。 结构概览 项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。 客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过app.$mount(&#39;#app&#39;)挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行Hydration（合并） 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748│ manifest.json # progressive web apps配置文件│ package.json # 项目配置文件│ server.js # 服务端渲染│ ├─public # 静态资源│ logo-120.png│ logo-144.png│ logo-152.png│ logo-192.png│ logo-384.png│ logo-48.png│ └─src │ app.js # 整合 router,filters,vuex 的入口文件 │ App.vue # 根 vue 组件 │ entry-client.js # client 的入口文件 │ entry-server.js # server 的入口文件 │ index.template.html # html 模板 │ ├─api │ create-api-client.js # Client数据源配置 │ create-api-server.js # server数据源配置 │ index.js # 数据请求API │ ├─components │ Comment.vue # 评论组件 │ Item.vue # │ ProgressBar.vue # 进度条组件 │ Spinner.vue # 加载提示组件 │ ├─router │ index.js # router配置 │ ├─store # Vue store模块 │ actions.js # 根级别的 action │ getters.js # 属性接口 │ index.js # 我们组装模块并导出 store 的地方 │ mutations.js # 根级别的 mutation │ ├─util │ filters.js # 过滤器 │ title.js # 工具类 │ └─views CreateListView.js # 动态生成列表界面的工厂方法 ItemList.vue # List界面组件 ItemView.vue # 单List项组件 UserView.vue # 用户界面组件 本项目包含开发环境及生产环境，我们先学习开发环境。 开发环境的服务端渲染流程让我们从node环境下执行命令开始。12# serve in dev mode, with hot reload at localhost:8080$npm run dev 然后发生了什么？我们来看一张图。 Tips:package.json解读 上述执行dev属性对应的脚本：node server即node server.js，即执行server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768···const app = express()// 服务端渲染的HTML模板const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer // 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中 return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125;let rendererlet readyPromiseif (isProd) &#123; // 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle const bundle = require('./dist/vue-ssr-server-bundle.json') //client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能 const clientManifest = require('./dist/vue-ssr-client-manifest.json') //vue-server-renderer创建bundle渲染器并绑定server bundle renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; // 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回 // 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新 //以及通过webpack的watch功能实现服务端代码的热更新 readyPromise = require('./build/setup-dev-server')(app, (bundle, options) =&gt; &#123; // 基于热更新，回调生成最新的bundle渲染器 renderer = createRenderer(bundle, options) &#125;)&#125;//依次装载一系列Express中间件，用来处理静态资源，数据压缩等···app.use(···)···function render (req, res) &#123; ··· // 设置请求的url const context = &#123; title: 'Vue HN 2.0', // default title url: req.url &#125; // 为渲染器绑定的server bundle（即entry-server.js）设置入参context renderer.renderToString(context, (err, html) =&gt; &#123; ··· res.end(html) ··· &#125;)&#125;//启动一个服务并监听从 8080 端口进入的所有连接请求。app.get('*', isProd ? render : (req, res) =&gt; &#123; readyPromise.then(() =&gt; render(req, res))&#125;)const port = process.env.PORT || 8080app.listen(port, () =&gt; &#123; console.log(`server started at localhost:$&#123;port&#125;`)&#125;) Tips1.vue-server-renderer(Vue服务端渲染，同时支持prefetch、prerender特性)2.webpack-dev-server(webpack-dev-middleware/webpack-hot-middleware)3.此项目全面使用ES6语法，包括箭头函数，解构赋值，Promise等特性。 server.js最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080请求经由express路由接收后，执行处理逻辑:readyPromise.then(() =&gt; render(req, res))沿着Promise的调用链处理：开发环境下1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。最终通过回调把生成在内存中的server bundle传回。2.创建渲染器，绑定server bundle，设置渲染模板，缓存等3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等4.最后将渲染好的HTML写入http响应体，传回浏览器。 接下来分解解读下这几个的实现。 setup-dev-server看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色） build/setup-dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// setup-dev-server.jsconst clientConfig = require('./webpack.client.config')const serverConfig = require('./webpack.server.config')module.exports = function setupDevServer (app, cb) &#123; let bundle, clientManifest let resolve const readyPromise = new Promise(r =&gt; &#123; resolve = r &#125;) const ready = (...args) =&gt; &#123; resolve() cb(...args) &#125; // 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem // 读取内存中的bundle 并通过传入的回调更新server.js中的bundle clientCompiler.plugin('done', () =&gt; &#123; const fs = devMiddleware.fileSystem const readFile = file =&gt; fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') clientManifest = JSON.parse(readFile('vue-ssr-client-manifest.json')) if (bundle) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) // hot middleware app.use(require('webpack-hot-middleware')(clientCompiler)) // watch and update server renderer const serverCompiler = webpack(serverConfig) // 获取基于memory-fs创建的内存文件系统对象 const mfs = new MFS() serverCompiler.outputFileSystem = mfs // 设置文件重新编译监听并通过传入的回调更新server.js中的bundle serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err stats = stats.toJson() stats.errors.forEach(err =&gt; console.error(err)) stats.warnings.forEach(err =&gt; console.warn(err)) const readFile = file =&gt; mfs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile('vue-ssr-server-bundle.json')) if (clientManifest) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) return readyPromise&#125; build/webpack.base.config.js 123456789101112131415161718192021222324252627282930313233343536// build/webpack.base.config.jsmodule.exports = &#123; // 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map devtool: isProd ? false : '#cheap-module-source-map', // 打包输出配置 output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/', filename: '[name].[chunkhash].js' &#125;, resolve: &#123; alias: &#123; 'public': path.resolve(__dirname, '../public') &#125; &#125;, module: &#123; ··· // 一系列加载器 &#125;, plugins:[ // 压缩js的插件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来 new ExtractTextPlugin(&#123; &#125;) ]&#125; build/webpack.client.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041// build/webpack.client.config.js// 基于webpack-merge工具合并base以及client特定配置项const config = merge(base, &#123; // 配置编译的入口文件 entry: &#123; app: './src/entry-client.js' &#125;, // 在alias设置客户端数据请求API为create-api-client.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-client.js' &#125; &#125;, plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"client\"' &#125;), // 设置打包时公共模块的提取规则 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // a module is extracted into the vendor chunk if... return ( // it's inside node_modules /node_modules/.test(module.context) &amp;&amp; // and not a CSS file (due to extract-text-webpack-plugin limitation) !/\\.css$/.test(module.request) ) &#125; &#125;), // 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name， // 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new VueSSRClientPlugin() ]&#125;) bulid/webpack.server.config.js 1234567891011121314151617181920212223242526272829303132333435// build/webpack.server.config.jsmodule.exports = merge(base, &#123; // 指定生成后的运行环境在node target: 'node', // 设置代码调试map devtool: '#source-map', // 配置编译的入口文件 entry: './src/entry-server.js', // 设置输出文件名，并设置模块导出为commonjs2类型 output: &#123; filename: 'server-bundle.js', libraryTarget: 'commonjs2' &#125;, // 在alias设置好服务端数据请求API为create-api-server.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-server.js' &#125; &#125;, // 设置不打包排除规则 externals: nodeExternals(&#123; // do not externalize CSS files in case we need to import it from a dep whitelist: /\\.css$/ &#125;), plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"server\"' &#125;), //设置VueSSRServerPlugin插件 new VueSSRServerPlugin() ]&#125;) 如上，基于 webpack config 的setup-dev-server就到这里，接下来说创建渲染器。 创建渲染器12345678910function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer console.log(`createRenderer`) return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125; 创建渲染器时重点两件事：1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件entry-server.js打包生成的。当渲染器调用renderer.renderToString开始渲染时，会执行该入口文件的默认方法。2.传入了一个html模板index.template.html，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。 Tips:index.template.html解读 顺着readyPromise.then的调用链，接下来调用render方法123456function render (req, res) &#123;··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) &#125;)&#125; renderer.renderToString方法内部会先调用入口模块entry-server.js的默认方法，我们看下entry-server.js主要做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// This exported function will be called by `bundleRenderer`.// This is where we perform data-prefetching to determine the// state of our application before actually rendering it.// Since data fetching is async, this function is expected to// return a Promise that resolves to the app instance.export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const s = isDev &amp;&amp; Date.now() const &#123; app, router, store &#125; = createApp() // set router's location // 手动路由切换到请求的url，即'/' router.push(context.url) // wait until router has resolved possible async hooks router.onReady(() =&gt; &#123; // 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js const matchedComponents = router.getMatchedComponents() // no matched routes if (!matchedComponents.length) &#123; reject(&#123; code: 404 &#125;) &#125; // Call fetchData hooks on components matched by the route. // A preFetch hook dispatches a store action and returns a Promise, // which is resolved when the action is complete and store state has been // updated. // 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据 Promise.all(matchedComponents.map(component =&gt; &#123; return component.asyncData &amp;&amp; component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125;)).then(() =&gt; &#123; isDev &amp;&amp; console.log(`data pre-fetch: $&#123;Date.now() - s&#125;ms`) // After all preFetch hooks are resolved, our store is now // filled with the state needed to render the app. // Expose the state on the render context, and let the request handler // inline the state in the HTML response. This allows the client-side // store to pick-up the server-side state without having to duplicate // the initial data fetching on the client. // 把vuex的state设置到传入的context.initialState上 context.state = store.state // 返回state, router已经设置好的Vue实例app resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; entry-server.js的主要工作：0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。1.手动路由切换到请求的url，即’/‘2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js） Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：服务端渲染时的数据预取流程 还记得index.template.html被设置到template属性中吗？此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？123&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt; 就是这里，这个&lt;!--vue-ssr-outlet--&gt;Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template. 接下来，Vue渲染器会回调callback方法，我们回到server.js123456789101112function render (req, res) &#123; ··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) ··· &#125;)&#125; 此时只需要将渲染好的html写入http响应体就结束了，浏览器客户端就可以看到页面了。 接下来我们看看服务端数据预取的实现 服务端渲染时的数据预取流程上文提到，服务端渲染时，会手动将路由导航到请求地址即&#39;/&#39;下，然后调用该路由组件的asyncData方法来预取数据 那么我们看看路由配置 12345678910111213141516171819202122232425// /src/router/index.jsVue.use(Router)// route-level code splittingconst createListView = id =&gt; () =&gt; System.import('../views/CreateListView').then(m =&gt; m.default(id))const ItemView = () =&gt; System.import('../views/ItemView.vue')const UserView = () =&gt; System.import('../views/UserView.vue')export function createRouter () &#123; return new Router(&#123; mode: 'history', scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [ &#123; path: '/top/:page(\\\\d+)?', component: createListView('top') &#125;, &#123; path: '/new/:page(\\\\d+)?', component: createListView('new') &#125;, &#123; path: '/show/:page(\\\\d+)?', component: createListView('show') &#125;, &#123; path: '/ask/:page(\\\\d+)?', component: createListView('ask') &#125;, &#123; path: '/job/:page(\\\\d+)?', component: createListView('job') &#125;, &#123; path: '/item/:id(\\\\d+)', component: ItemView &#125;, &#123; path: '/user/:id', component: UserView &#125;, &#123; path: '/', redirect: '/top' &#125; ] &#125;)&#125; 地址&#39;/&#39;是做了redirect到&#39;/top&#39;,其实就是默认地址就是到top页面，在看第一条路由配置，&#39;/top&#39;路由对应的组件是createListView(&#39;top&#39;) 12345678910111213141516171819// /src/views/CreateListView.jsexport default function createListView (type) &#123; return &#123; name: `$&#123;type&#125;-stories-view`, asyncData (&#123; store &#125;) &#123; console.log(`createListView asyncData`) return store.dispatch('FETCH_LIST_DATA', &#123; type &#125;) &#125;, title: camelize(type), render (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; &#125;&#125; Tips: Vuex状态管理1.dispatch对应Action，commit对应mutation2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。 Vuex state状态变更流程 asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store. 最后数据就都保存在store这里了。12345678910111213141516171819202122// /src/store/index.jsexport function createStore () &#123; return new Vuex.Store(&#123; state: &#123; activeType: null, itemsPerPage: 20, items: &#123;/* [id: number]: Item */&#125;, users: &#123;/* [id: string]: User */&#125;, lists: &#123; top: [/* number */], new: [], show: [], ask: [], job: [] &#125; &#125;, actions, mutations, getters &#125;)&#125; 然后将开始通过Render 函数创建HTML。 123456// /src/views/CreateListView.jsrender (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; 123456789101112131415161718192021222324// /src/views/ItemList.vue···&lt;template&gt; &lt;div class=\"news-view\"&gt; &lt;div class=\"news-list-nav\"&gt; &lt;router-link v-if=\"page &gt; 1\" :to=\"'/' + type + '/' + (page - 1)\"&gt;&amp;lt; prev&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;&amp;lt; prev&lt;/a&gt; &lt;span&gt;&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;&lt;/span&gt; &lt;router-link v-if=\"hasMore\" :to=\"'/' + type + '/' + (page + 1)\"&gt;more &amp;gt;&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;more &amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;transition :name=\"transition\"&gt; &lt;div class=\"news-list\" :key=\"displayedPage\" v-if=\"displayedPage &gt; 0\"&gt; &lt;transition-group tag=\"ul\" name=\"item\"&gt; &lt;item v-for=\"item in displayedItems\" :key=\"item.id\" :item=\"item\"&gt; &lt;/item&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;··· 这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的&lt;!--vue-ssr-outlet--&gt;,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。 Tips:后续更新内容规划：1.生产环境下的服务端渲染逻辑流程2.客户端渲染逻辑流程3.客户端vue组件细节解读","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]},{"title":"todo-mvp-dagger 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/todo-mvp-dagger-code-explain/","text":"前言 HackerNews是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。 vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。 结构概览 目录概览","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]},{"title":"vue-hackernews-2.0 细节解读","date":"2017-05-12T16:00:00.000Z","path":"2017/05/13/vue-hackernews-2.0-code-detail/","text":"前言本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对项目源码解读的细节补充。 package.json解读该文件提供了四种命令1234567891011# install dependenciesnpm install # or yarn# serve in dev mode, with hot reload at localhost:8080npm run dev# build for productionnpm run build# serve in production modenpm start 执行npm install查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。 Tips:dependencies与devDependencies的区别devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。 执行npm run dev1234567\"scripts\": &#123;\"dev\": \"node server\",\"start\": \"cross-env NODE_ENV=production node server\",\"build\": \"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server\",\"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules\",\"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules\"&#125;, 查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：node server即node server.js，即执行server.js 执行npm run build同样，找到build属性，并执行：rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server，即删除dist目录并执行npm run build:client和npm run build:server对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件 执行npm start同样，找到start属性，并执行：cross-env NODE_ENV=production node server，即通过cross-env模块设置NODE_ENV环境变量为production，并执行node server Tips:为什么是npm start而不是npm run start?1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见npm --help2.其他三个命令都不是内置命令，需要经由npm run去执行。 index.template.html解读12345&lt;meta name=\"mobile-web-app-capable\" content=\"yes\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\"&gt;&lt;link rel=\"shortcut icon\" sizes=\"48x48\" href=\"/public/logo-48.png\"&gt;&lt;meta name=\"theme-color\" content=\"#f60\"&gt;&lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; 这段html代码功能：移动端浏览器适配及PWA适配 Tips:PWA (progressive web apps)-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。 接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。浏览器体验：在Chrome浏览器地址栏中输入项目地址，效果如下： PWA体验：通过Chrome的Add to Homescreen功能，将该站点添加到桌面。效果如下： 点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。 现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：123456789101112//1. 主题色：绿色 启动图背景色：白色\"background_color\": \"#f2f3f5\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//2. 主题色：绿色 启动图背景色：绿色\"background_color\": \"#48BB74\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//3. 主题色：橙色 启动图背景色：橙色\"background_color\": \"#f60\",\"display\": \"standalone\",\"theme_color\": \"#f60\" Tips:这里用到的manifest.json不要与作为离线缓存的manifest混淆。 最后来对比感受下非PWA的百度站点VsPWA站点的hackernews在Add to HomeScreen后，体验上的差异。 概括下主要的差异：1.增加了同原生应用一样的启动图过渡界面2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。注：PWA更多的特性这里并未应用，其实PWA可以做的更多。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]}]