[{"title":"Retrofit 2.3.0 源码解析","date":"2017-07-01T07:24:47.838Z","path":"2017/07/01/Retrofit-2.3.0-code-explain/","text":"前言 Retrofit A type-safe HTTP client for Android and Java Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。 基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。 结构概览 项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall这里我们把基于Retrofit的HTTP通信比做是邮递信件。 邮递信件 信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。 邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。 邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理 邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。 基于Retrofit的HTTP通信 Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。 Proxy：然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等 Invocation：这里负责调度同步或异步请求，请求装配和响应解析 RawCall：这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。 来看看寄信和Retrofit之间的对比： 大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。 目录概览官方 Javadoc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647│ BuiltInConverters.java # 内建Converter│ Call.java # 发送请求接收响应的retrofit方法调用│ CallAdapter.java # 适配Call的响应类型，将默认响应类型R转换为类型T│ Callback.java # 返回服务端或离线请求的响应体│ Converter.java # HTTP交互中，转换对象为数据 或 从数据转换为对象│ DefaultCallAdapterFactory.java # 默认CallAdapter工厂│ ExecutorCallAdapterFactory.java # http请求执行器工厂│ HttpException.java # 非2xx HTTP响应的异常处理│ OkHttpCall.java # 真正调用OkHttp3发送Http请求的类│ package-info.java # 包描述│ ParameterHandler.java # 参数注解解析器│ Platform.java # 平台适配(Java/Android)│ RequestBuilder.java # 请求拼装│ Response.java # 原汁原味的HTTP 响应体，所谓 T body│ Retrofit.java # 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口│ ServiceMethod.java # 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请 # 求头、是否是multipart等等),并返回用于发起http请求的Call对象│ Utils.java # 工具类│ └─http # http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解） Body.java # control the request body of a POST/PUT request DELETE.java # Make a DELETE request Field.java # Named pair for a form-encoded request FieldMap.java # Named key/value pairs for a form-encoded request FormUrlEncoded.java # Denotes that the request body will use form URL encoding GET.java # Make a GET request HEAD.java # Make a HEAD request Header.java # Replaces the header with the value of its target HeaderMap.java # Adds headers specified in the Map Headers.java # Adds headers literally supplied in the value HTTP.java # Use a custom HTTP verb for a request Multipart.java # Denotes that the request body is multi-part OPTIONS.java # Make an OPTIONS request package-info.java # Package description Part.java # Denotes a single part of a multi-part request PartMap.java # Denotes name and value parts of a multi-part request PATCH.java # Make a PATCH request Path.java # Named replacement in a URL path segment POST.java # Make a POST request PUT.java # Make a PUT request Query.java # Query parameter appended to the URL QueryMap.java # Query parameter keys and values appended to the URL QueryName.java # Query parameter appended to the URL that has no value Streaming.java # Treat the response body on methods returning Response as is, i.e. # without converting body() to byte[] Url.java # URL resolved against the base URL Retrofit的基本用法让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。 用 Java 接口的方式定义一个HTTP API.1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; Retrofit 类生成一个 GitHubService 接口的实现实例.12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class); Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); 执行同步或异步HTTP请求，得到HTTP响应数据.1Response&lt;List&lt;Repo&gt;&gt; response = repos.execute(); Retrofit的源码解析首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器 Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。 下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall. Flow - Builder Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) ... .build();Tips.设计模式之Builder模式 基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。123456789// Retrofit.java -&gt; class Builderpublic Retrofit build() &#123; ... return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。注：validateEagerly，用于指定是否预先解析注解，加速接口访问效率。 Flow - Proxy GitHubService service = retrofit.create(GitHubService.class);我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。123456789101112131415161718192021222324252627// Retrofit.java public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。为什么用动态代理？这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。 Tips.动态代理 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。 invoke中主要由ServiceMethod和CallAdapter完成了三件事： 请求方法的注解解析 创建OkHttpCall实例，为后续流程中的HTTP请求执行做准备，详见 Flow - Invocation. 适配Call的响应类型，将默认响应类型R转换为类型T 1234ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); ServiceMethod.java12345678910111213141516171819202122232425262728293031323334// ServiceMethod.javapublic ServiceMethod build() &#123; callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); ... responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; ... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; ... Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; ... parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; ... return new ServiceMethod&lt;&gt;(this); &#125; 获取callAdapter、responseType、responseConverter接口对象 解析Method的注解 解析Method的参数注解 解析Method的参数中使用了依赖请求API的动态参数的注解，交由ParameterHandler处理 CallAdapter.java1234567891011public interface CallAdapter&lt;R, T&gt; &#123; Type responseType(); ... T adapt(Call&lt;R&gt; call); ... &#125; 适配Call的响应类型，将默认响应类型R转换为类型T.比如官方的RxJavaCallAdapter可以结合Rxjava特性对Call的响应做RxJava观察者模式转换，进一步解放生产力。 注：未在Builder阶段指定CallAdapter(如 RxJavaCallAdapterFactory )的情况下，默认的 CallAdapter 不对Call做任何处理。见 DefaultCallAdapterFactory:1234567891011final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123; static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory(); ... ... @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return call; &#125; &#125;&#125; Flow - Invocation Response&lt;List&lt;Repo&gt;&gt; response = repos.execute(); 这一步开始基于同步的方式执行HTTP请求，并得到返回的HTTP响应数据. 本质上是执行了 OkHttpCall 的 execute方法.12345678910111213141516// OkHttpCall.java@Override public Response&lt;T&gt; execute() throws IOException &#123; synchronized (this) &#123; ... ... call = rawCall = createRawCall(); &#125; ... return parseResponse(call.execute()); &#125; 如你所见，这里创建了RawCall，即真正的去执行HTTP请求任务的对象。这里还负责HTTP请求的响应数据解析。我们看下createRawCall()干了什么。 12345678// OkHttpCall.javaprivate okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); ... return call; &#125; serviceMethod.toRequest()的功能：1234567891011// ServiceMethod.java/** Builds an HTTP request from method arguments. */ Request toRequest(@Nullable Object... args) throws IOException &#123; RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ... return requestBuilder.build(); &#125; toRequest 方法通过 RequestBuilder 创建了 okhttp3 做 HTTP 请求时需要的 Request 对象。 serviceMethod.callFactory.newCall(request)的功能：建立一个请求通道，为执行HTTP请求做准备。这里callFactory可以由使用者指定，默认为 OkHttpClient，见：123456// Retrofit.javaokhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; 回头看下 OkHttpCall 中 execute 方法最后一句: return parseResponse(call.execute());这里调用真正的HTTP请求客户端的请求执行方法。也就是来到了接下来的一个流程。 Flow - RawCall 上个 Flow 中最后一步， call.execute(),开启了真正的HTTP请求，即通过 okhttp3 完成HTTP请求。这个部分没什么代码可讲，属于面向接口开发的典范，要讲就该去讲 Okhttp 框架的源码了。 这个部分引出了 Retrofit 的开源拥有者-Square 公司的另一个优秀的开源项目 Okhttp,是不是也很想一探究竟？ End最后我想拿 Retrofit 官方的一段话来结束： Contributing If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running mvn clean verify. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA). 纳尼？ Cos 我想把亲手画的两副图贡献给 Retrofit.","comments":true,"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://wangfuda.github.io/tags/Retrofit/"},{"name":"okhttp","slug":"okhttp","permalink":"https://wangfuda.github.io/tags/okhttp/"},{"name":"http","slug":"http","permalink":"https://wangfuda.github.io/tags/http/"},{"name":"restful api","slug":"restful-api","permalink":"https://wangfuda.github.io/tags/restful-api/"}]},{"title":"todo-mvp-dagger 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/todo-mvp-dagger-code-explain/","text":"前言 android-architectureThe Android Architecture Blueprints project demonstrates strategies to help solve or avoid these common problems. This project implements the same app using different architectural concepts and tools. 敬请期待。","comments":true,"tags":[{"name":"mvp","slug":"mvp","permalink":"https://wangfuda.github.io/tags/mvp/"},{"name":"dagger","slug":"dagger","permalink":"https://wangfuda.github.io/tags/dagger/"},{"name":"android architecture","slug":"android-architecture","permalink":"https://wangfuda.github.io/tags/android-architecture/"}]},{"title":"自定义View星空动画的内存占用/GPU渲染性能优化手记","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/nebula_gpu_monitor_optimize/","text":"这是一个关于星空的自定义动画Sample,源码请戳 https://github.com/wangfuda/nebula Gif图： 本文将重点讲解在本例自定义动画编程中，如何结合 Android Studio 的 Memory Monitor，GPU monitor 按步骤做内存优化，GPU渲染优化。关于动画实现部分，源码已提交至github，请手动阅读理解，注释很详尽。 内存占用优化内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi.先来彪一张直接撸完代码无任何优化的情况下，内存的占用图： 内存占用246M，不能忍。问：为什么这么大？答：因为资源图都是高清1K分辨率的图。问：为什么这么大？答：。。。那么我们算一下这246M内存占用是怎么来的吧。先来一条图片内存占用计算公式，公式溯源请自行去看源码：BitmapFactory.Java &amp; BitmapFactory.cppscaledWidth = int( Width targetDensity / density + 0.5)scaledHeight = int( Height targetDensity / density + 0.5)memory = scaledWidth scaledHeight 4其中参数定义如下： Width：图片宽Height：图片高targetDensity：加载图片的目标手机的 density，这个值的来源是 DisplayMetrics 的 densityDpi，如果是小米note那么这个数值就是480，详见下图关于targetDensity的参数细节。density：decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 hdpi 是240，xxhdpi 是480）每像素字节数：ARGB8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte。 对于一张1080x1920的图来说，放置在hdpi目录，并在小米note手机上（分辨率1080x1920,targetDensity为480），而且均默认以ARGB8888格式加载。内存占用计算公式：scaledWidth = int( 1080 480/ 240+ 0.5) =2160scaledHeight = int( 1920 480/ 240+ 0.5)=3840memory = scaledWidth scaledHeight 4=216038404 = 33177600 = 33.17M 一张背景图就占用33M,这个分辨率的图，我们res下一共有7张，还有其他几张小图。这回可以回答为什么占用245M的内存了。 那么内存占用的优化方案也就有了，我们尽量把图片资源放到大分辨率目录下，比如xxxhdpi（当然还有个前提，你的图片分辨率也确实符合大分辨率，否则会出现在大分辨率设备上，显示不全的问题）。 我们来看看把图片资源移动到xxxhdpi目录下后，内存占用情况： 把图片资源从hdpi移动到xxx-hdpi，从246M降低到56M,减少了190M，Bingo! 内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）初始单张图片大小都接近2M，经过tinypng优化后，压缩率达到70-80%，非常完美，包体大小减小了，不过，经过我们步骤一的科学计算，这个优化并不会影响图片在内存中的占用。 内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放12345public void releaseBitmap &#123; ... bitmap.recycle(); ...&#125; 来看下bitmap释放后的memory monitor图： 内存占用降低到36M,减少了20M 内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2123456789101112public void releaseValueAnimator &#123; ... valueAnimator = null; ...&#125;public void initBitmap &#123; ... localOptions.inSampleSize = 2; localOptions.inPreferredConfig = Bitmap.Config.RGB_565; ...&#125; 来看下变更图片颜色格式及采样率后的memory monitor图： 内存占用降低到28M,减少了8M（后来monitor截图只对背景图片做inPreferredConfig调整，内存占用变为30M,相比全部设置为2，增加了2M） ##GPU渲染优化接下来我们要专注于GPU渲染优化了。通过前面几张图，也能看到GPU monitor的状态，非常不乐观，完全达不到帧率刷新的要求：即每帧渲染不超过16ms，每秒可以渲染60帧。先看GPU Monitor的各项指标含义： Misc Time：表示在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况；出现该线条的时候，可以在Log中看到这样的日志： Skipped xxx frames! The application may be doing too much work on its main thread Swap Buffers：表示处理任务的时间，也可以说是CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多； Command Issue：表示执行任务的时间，这部分主要是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，红色线条越高表示需要绘制的视图更多； Sync：表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小； Draw：表示测量和绘制视图列表所需要的时间，蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作； Measure/Layout：表示布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题； Animation：表示计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等； Input Handling：表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作；Vsync Delay：见Misc Time GPU渲染优化 步骤一：优化内存占用可以回过头去看看内存优化过程演进中的Monitor图，随着内存占用的降低，GPU渲染的性能改善也是随之渐进的，所以GPU渲染性能优化，首选就是内存优化 GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。在sample代码中重构了onDraw中的画笔的属性设置，绘制区域的创建等代码，这些代码都重构到初始化中。而在onDraw中仅做参数值的动态调整。 Tips.本例Sample最初始未经过任何优化的代码及最终优化版本代码均在github上可以查看到commit记录，这里不再写详细代码对比，请移动github阅读源码。 我们看下重构前后的对比图monitor_5_bitmap_RGB_565_inSampleSize2.png Vs monitor_6_gpu_optimize_object_and_paint_create.png，对比发现，GPU渲染耗时明显降低。 我们暂时先对比看GPU Monitor的 0s ~ 9s 部分的性能改善，目前GPU优化主要在这里体现，因为后半部分各位爷看到了，GPU渲染耗时飙升，掉帧严重，那部分的优化在后续步骤会提到。 重构前 GPU Monitor： 重构后 GPU Monitor： GPU渲染优化 步骤三：能用硬件加速，就别关闭它。我们都看到了，在GPU Monitor中显示，9s后的GPU渲染，每帧耗时突然飙升，每帧渲染都是超60ms，Draw上升至172ms，Vsync上升至148ms.而且在logcat中也看到日志：07-09 11:17:57.135 15980-15980/com.osan.nebula I/Choreographer: Skipped 31 frames! The application may be doing too much work on its main thread.每帧超时，掉帧严重。到底是什么原因呢？经过反复的排查，终于找到原因，我们来聊聊这个飙升的来龙去脉。由于在后半部分的动画中，绘制小星星的光晕效果时，使用的画笔设置了模糊属性，为了给小星星加个光晕效果。1paintCircleStar.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.SOLID)); 然后google官方文档都说了，硬件加速不支持的UI特效API之一就有它。也就是你要用硬件加速，这个模糊效果就失效。所以我一门心思的为了给小星星加光晕… 光晕…晕…，最后我选择了关闭硬件加速123456789private void drawState7(Canvas canvas) &#123; ... canvas.save(); setLayerType(LAYER_TYPE_SOFTWARE, null);//关闭硬件加速 canvas.translate(halfWidth, halfHeight); canvas.scale(scale, scale); canvas.rotate(30f * mValue7); ...&#125; 呵呵，为了小星星，闯祸了。因为本例动画中，各种对画布的旋转，缩放，变换，透明度动态变化，在非硬件加速情况下，不停的重新绘制，是GPU渲染耗时飙升的唯一原因。我们来看看开启硬件加速的情况下，GPU Monitor的指标监控： 恢复硬件加速后，渲染耗时立刻恢复到绿线以下，即每帧渲染不超过16ms，达到渲染标准。而且，CPU消耗也明显下降。那么为什么硬件加速有如此神奇之功效？使用硬件加速在对一些view的属性改变上有更高的效率，因为不需要view的invalidate和redrawn。而我们动画中正式大量使用了对属性的改变。属性如: 透明度：alpha移动：x, y, translationX, translationY缩放：scaleX, scaleY旋转：rotation, rotationX, rotationY坐标：pivotX, pivotY 注：1）使用硬件加速，对于渲染性能的提示是显著的，API&gt;14后，硬件加速是默认开启的。2）硬件加速还不支持所有的2D绘图命令，开启后可能会影响自定义View和绘图操作。 GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算涉及计算任务，能不在ondraw中执行的，就坚决移走，即使只是一个a*b或a/b.因为我们继续重构了onDraw方法，将可能优化的运算代码均做了优化，能放到初始化做的就移到初始化，能提炼共用的运算公式就共用，能不重复算的就绝对不算第二遍。我们来看看优化算数运算后，GPU Monitor的指标监控： 相比步骤三中的GPU Monitor指标有了进一步降低，虽然降低幅度很小，但是还是对GPU渲染性能提升有效果的，而且观察发现，优化后，CPU和GPU的指标看起来更平稳。 最后附上nebula自定义动画的截图","comments":true,"tags":[{"name":"自定义View","slug":"自定义View","permalink":"https://wangfuda.github.io/tags/自定义View/"},{"name":"自定义动画","slug":"自定义动画","permalink":"https://wangfuda.github.io/tags/自定义动画/"},{"name":"GPU Monior","slug":"GPU-Monior","permalink":"https://wangfuda.github.io/tags/GPU-Monior/"}]},{"title":"vue-hackernews-2.0 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/vue-hackernews-2.0-code-explain/","text":"前言 HackerNews是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。 vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。 结构概览 项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。 客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过app.$mount(&#39;#app&#39;)挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行Hydration（合并） 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748│ manifest.json # progressive web apps配置文件│ package.json # 项目配置文件│ server.js # 服务端渲染│ ├─public # 静态资源│ logo-120.png│ logo-144.png│ logo-152.png│ logo-192.png│ logo-384.png│ logo-48.png│ └─src │ app.js # 整合 router,filters,vuex 的入口文件 │ App.vue # 根 vue 组件 │ entry-client.js # client 的入口文件 │ entry-server.js # server 的入口文件 │ index.template.html # html 模板 │ ├─api │ create-api-client.js # Client数据源配置 │ create-api-server.js # server数据源配置 │ index.js # 数据请求API │ ├─components │ Comment.vue # 评论组件 │ Item.vue # │ ProgressBar.vue # 进度条组件 │ Spinner.vue # 加载提示组件 │ ├─router │ index.js # router配置 │ ├─store # Vue store模块 │ actions.js # 根级别的 action │ getters.js # 属性接口 │ index.js # 我们组装模块并导出 store 的地方 │ mutations.js # 根级别的 mutation │ ├─util │ filters.js # 过滤器 │ title.js # 工具类 │ └─views CreateListView.js # 动态生成列表界面的工厂方法 ItemList.vue # List界面组件 ItemView.vue # 单List项组件 UserView.vue # 用户界面组件 本项目包含开发环境及生产环境，我们先学习开发环境。 开发环境的服务端渲染流程让我们从node环境下执行命令开始。12# serve in dev mode, with hot reload at localhost:8080$npm run dev 然后发生了什么？我们来看一张图。 Tips:package.json解读 上述执行dev属性对应的脚本：node server即node server.js，即执行server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768···const app = express()// 服务端渲染的HTML模板const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer // 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中 return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125;let rendererlet readyPromiseif (isProd) &#123; // 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle const bundle = require('./dist/vue-ssr-server-bundle.json') //client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能 const clientManifest = require('./dist/vue-ssr-client-manifest.json') //vue-server-renderer创建bundle渲染器并绑定server bundle renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; // 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回 // 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新 //以及通过webpack的watch功能实现服务端代码的热更新 readyPromise = require('./build/setup-dev-server')(app, (bundle, options) =&gt; &#123; // 基于热更新，回调生成最新的bundle渲染器 renderer = createRenderer(bundle, options) &#125;)&#125;//依次装载一系列Express中间件，用来处理静态资源，数据压缩等···app.use(···)···function render (req, res) &#123; ··· // 设置请求的url const context = &#123; title: 'Vue HN 2.0', // default title url: req.url &#125; // 为渲染器绑定的server bundle（即entry-server.js）设置入参context renderer.renderToString(context, (err, html) =&gt; &#123; ··· res.end(html) ··· &#125;)&#125;//启动一个服务并监听从 8080 端口进入的所有连接请求。app.get('*', isProd ? render : (req, res) =&gt; &#123; readyPromise.then(() =&gt; render(req, res))&#125;)const port = process.env.PORT || 8080app.listen(port, () =&gt; &#123; console.log(`server started at localhost:$&#123;port&#125;`)&#125;) Tips1.vue-server-renderer(Vue服务端渲染，同时支持prefetch、prerender特性)2.webpack-dev-server(webpack-dev-middleware/webpack-hot-middleware)3.此项目全面使用ES6语法，包括箭头函数，解构赋值，Promise等特性。 server.js最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080请求经由express路由接收后，执行处理逻辑:readyPromise.then(() =&gt; render(req, res))沿着Promise的调用链处理：开发环境下1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。最终通过回调把生成在内存中的server bundle传回。2.创建渲染器，绑定server bundle，设置渲染模板，缓存等3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等4.最后将渲染好的HTML写入http响应体，传回浏览器。 接下来分解解读下这几个的实现。 setup-dev-server看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色） build/setup-dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// setup-dev-server.jsconst clientConfig = require('./webpack.client.config')const serverConfig = require('./webpack.server.config')module.exports = function setupDevServer (app, cb) &#123; let bundle, clientManifest let resolve const readyPromise = new Promise(r =&gt; &#123; resolve = r &#125;) const ready = (...args) =&gt; &#123; resolve() cb(...args) &#125; // 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem // 读取内存中的bundle 并通过传入的回调更新server.js中的bundle clientCompiler.plugin('done', () =&gt; &#123; const fs = devMiddleware.fileSystem const readFile = file =&gt; fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') clientManifest = JSON.parse(readFile('vue-ssr-client-manifest.json')) if (bundle) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) // hot middleware app.use(require('webpack-hot-middleware')(clientCompiler)) // watch and update server renderer const serverCompiler = webpack(serverConfig) // 获取基于memory-fs创建的内存文件系统对象 const mfs = new MFS() serverCompiler.outputFileSystem = mfs // 设置文件重新编译监听并通过传入的回调更新server.js中的bundle serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err stats = stats.toJson() stats.errors.forEach(err =&gt; console.error(err)) stats.warnings.forEach(err =&gt; console.warn(err)) const readFile = file =&gt; mfs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile('vue-ssr-server-bundle.json')) if (clientManifest) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) return readyPromise&#125; build/webpack.base.config.js 123456789101112131415161718192021222324252627282930313233343536// build/webpack.base.config.jsmodule.exports = &#123; // 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map devtool: isProd ? false : '#cheap-module-source-map', // 打包输出配置 output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/', filename: '[name].[chunkhash].js' &#125;, resolve: &#123; alias: &#123; 'public': path.resolve(__dirname, '../public') &#125; &#125;, module: &#123; ··· // 一系列加载器 &#125;, plugins:[ // 压缩js的插件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来 new ExtractTextPlugin(&#123; &#125;) ]&#125; build/webpack.client.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041// build/webpack.client.config.js// 基于webpack-merge工具合并base以及client特定配置项const config = merge(base, &#123; // 配置编译的入口文件 entry: &#123; app: './src/entry-client.js' &#125;, // 在alias设置客户端数据请求API为create-api-client.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-client.js' &#125; &#125;, plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"client\"' &#125;), // 设置打包时公共模块的提取规则 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // a module is extracted into the vendor chunk if... return ( // it's inside node_modules /node_modules/.test(module.context) &amp;&amp; // and not a CSS file (due to extract-text-webpack-plugin limitation) !/\\.css$/.test(module.request) ) &#125; &#125;), // 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name， // 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new VueSSRClientPlugin() ]&#125;) bulid/webpack.server.config.js 1234567891011121314151617181920212223242526272829303132333435// build/webpack.server.config.jsmodule.exports = merge(base, &#123; // 指定生成后的运行环境在node target: 'node', // 设置代码调试map devtool: '#source-map', // 配置编译的入口文件 entry: './src/entry-server.js', // 设置输出文件名，并设置模块导出为commonjs2类型 output: &#123; filename: 'server-bundle.js', libraryTarget: 'commonjs2' &#125;, // 在alias设置好服务端数据请求API为create-api-server.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-server.js' &#125; &#125;, // 设置不打包排除规则 externals: nodeExternals(&#123; // do not externalize CSS files in case we need to import it from a dep whitelist: /\\.css$/ &#125;), plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"server\"' &#125;), //设置VueSSRServerPlugin插件 new VueSSRServerPlugin() ]&#125;) 如上，基于 webpack config 的setup-dev-server就到这里，接下来说创建渲染器。 创建渲染器12345678910function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer console.log(`createRenderer`) return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125; 创建渲染器时重点两件事：1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件entry-server.js打包生成的。当渲染器调用renderer.renderToString开始渲染时，会执行该入口文件的默认方法。2.传入了一个html模板index.template.html，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。 Tips:index.template.html解读 顺着readyPromise.then的调用链，接下来调用render方法123456function render (req, res) &#123;··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) &#125;)&#125; renderer.renderToString方法内部会先调用入口模块entry-server.js的默认方法，我们看下entry-server.js主要做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// This exported function will be called by `bundleRenderer`.// This is where we perform data-prefetching to determine the// state of our application before actually rendering it.// Since data fetching is async, this function is expected to// return a Promise that resolves to the app instance.export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const s = isDev &amp;&amp; Date.now() const &#123; app, router, store &#125; = createApp() // set router's location // 手动路由切换到请求的url，即'/' router.push(context.url) // wait until router has resolved possible async hooks router.onReady(() =&gt; &#123; // 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js const matchedComponents = router.getMatchedComponents() // no matched routes if (!matchedComponents.length) &#123; reject(&#123; code: 404 &#125;) &#125; // Call fetchData hooks on components matched by the route. // A preFetch hook dispatches a store action and returns a Promise, // which is resolved when the action is complete and store state has been // updated. // 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据 Promise.all(matchedComponents.map(component =&gt; &#123; return component.asyncData &amp;&amp; component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125;)).then(() =&gt; &#123; isDev &amp;&amp; console.log(`data pre-fetch: $&#123;Date.now() - s&#125;ms`) // After all preFetch hooks are resolved, our store is now // filled with the state needed to render the app. // Expose the state on the render context, and let the request handler // inline the state in the HTML response. This allows the client-side // store to pick-up the server-side state without having to duplicate // the initial data fetching on the client. // 把vuex的state设置到传入的context.initialState上 context.state = store.state // 返回state, router已经设置好的Vue实例app resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; entry-server.js的主要工作：0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。1.手动路由切换到请求的url，即’/‘2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js） Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：服务端渲染时的数据预取流程 还记得index.template.html被设置到template属性中吗？此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？123&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt; 就是这里，这个&lt;!--vue-ssr-outlet--&gt;Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template. 接下来，Vue渲染器会回调callback方法，我们回到server.js123456789101112function render (req, res) &#123; ··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) ··· &#125;)&#125; 此时只需要将渲染好的html写入http响应体就结束了，浏览器客户端就可以看到页面了。 接下来我们看看服务端数据预取的实现 服务端渲染时的数据预取流程上文提到，服务端渲染时，会手动将路由导航到请求地址即&#39;/&#39;下，然后调用该路由组件的asyncData方法来预取数据 那么我们看看路由配置 12345678910111213141516171819202122232425// /src/router/index.jsVue.use(Router)// route-level code splittingconst createListView = id =&gt; () =&gt; System.import('../views/CreateListView').then(m =&gt; m.default(id))const ItemView = () =&gt; System.import('../views/ItemView.vue')const UserView = () =&gt; System.import('../views/UserView.vue')export function createRouter () &#123; return new Router(&#123; mode: 'history', scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [ &#123; path: '/top/:page(\\\\d+)?', component: createListView('top') &#125;, &#123; path: '/new/:page(\\\\d+)?', component: createListView('new') &#125;, &#123; path: '/show/:page(\\\\d+)?', component: createListView('show') &#125;, &#123; path: '/ask/:page(\\\\d+)?', component: createListView('ask') &#125;, &#123; path: '/job/:page(\\\\d+)?', component: createListView('job') &#125;, &#123; path: '/item/:id(\\\\d+)', component: ItemView &#125;, &#123; path: '/user/:id', component: UserView &#125;, &#123; path: '/', redirect: '/top' &#125; ] &#125;)&#125; 地址&#39;/&#39;是做了redirect到&#39;/top&#39;,其实就是默认地址就是到top页面，在看第一条路由配置，&#39;/top&#39;路由对应的组件是createListView(&#39;top&#39;) 12345678910111213141516171819// /src/views/CreateListView.jsexport default function createListView (type) &#123; return &#123; name: `$&#123;type&#125;-stories-view`, asyncData (&#123; store &#125;) &#123; console.log(`createListView asyncData`) return store.dispatch('FETCH_LIST_DATA', &#123; type &#125;) &#125;, title: camelize(type), render (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; &#125;&#125; Tips: Vuex状态管理1.dispatch对应Action，commit对应mutation2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。 Vuex state状态变更流程 asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store. 最后数据就都保存在store这里了。12345678910111213141516171819202122// /src/store/index.jsexport function createStore () &#123; return new Vuex.Store(&#123; state: &#123; activeType: null, itemsPerPage: 20, items: &#123;/* [id: number]: Item */&#125;, users: &#123;/* [id: string]: User */&#125;, lists: &#123; top: [/* number */], new: [], show: [], ask: [], job: [] &#125; &#125;, actions, mutations, getters &#125;)&#125; 然后将开始通过Render 函数创建HTML。 123456// /src/views/CreateListView.jsrender (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; 123456789101112131415161718192021222324// /src/views/ItemList.vue···&lt;template&gt; &lt;div class=\"news-view\"&gt; &lt;div class=\"news-list-nav\"&gt; &lt;router-link v-if=\"page &gt; 1\" :to=\"'/' + type + '/' + (page - 1)\"&gt;&amp;lt; prev&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;&amp;lt; prev&lt;/a&gt; &lt;span&gt;&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;&lt;/span&gt; &lt;router-link v-if=\"hasMore\" :to=\"'/' + type + '/' + (page + 1)\"&gt;more &amp;gt;&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;more &amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;transition :name=\"transition\"&gt; &lt;div class=\"news-list\" :key=\"displayedPage\" v-if=\"displayedPage &gt; 0\"&gt; &lt;transition-group tag=\"ul\" name=\"item\"&gt; &lt;item v-for=\"item in displayedItems\" :key=\"item.id\" :item=\"item\"&gt; &lt;/item&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;··· 这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的&lt;!--vue-ssr-outlet--&gt;,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。 Tips:后续更新内容规划：1.生产环境下的服务端渲染逻辑流程2.客户端渲染逻辑流程3.客户端vue组件细节解读","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]},{"title":"vue-hackernews-2.0 细节解读","date":"2017-05-12T16:00:00.000Z","path":"2017/05/13/vue-hackernews-2.0-code-detail/","text":"前言本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对项目源码解读的细节补充。 package.json解读该文件提供了四种命令1234567891011# install dependenciesnpm install # or yarn# serve in dev mode, with hot reload at localhost:8080npm run dev# build for productionnpm run build# serve in production modenpm start 执行npm install查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。 Tips:dependencies与devDependencies的区别devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。 执行npm run dev1234567\"scripts\": &#123;\"dev\": \"node server\",\"start\": \"cross-env NODE_ENV=production node server\",\"build\": \"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server\",\"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules\",\"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules\"&#125;, 查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：node server即node server.js，即执行server.js 执行npm run build同样，找到build属性，并执行：rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server，即删除dist目录并执行npm run build:client和npm run build:server对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件 执行npm start同样，找到start属性，并执行：cross-env NODE_ENV=production node server，即通过cross-env模块设置NODE_ENV环境变量为production，并执行node server Tips:为什么是npm start而不是npm run start?1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见npm --help2.其他三个命令都不是内置命令，需要经由npm run去执行。 index.template.html解读12345&lt;meta name=\"mobile-web-app-capable\" content=\"yes\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\"&gt;&lt;link rel=\"shortcut icon\" sizes=\"48x48\" href=\"/public/logo-48.png\"&gt;&lt;meta name=\"theme-color\" content=\"#f60\"&gt;&lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; 这段html代码功能：移动端浏览器适配及PWA适配 Tips:PWA (progressive web apps)-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。 接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。浏览器体验：在Chrome浏览器地址栏中输入项目地址，效果如下： PWA体验：通过Chrome的Add to Homescreen功能，将该站点添加到桌面。效果如下： 点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。 现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：123456789101112//1. 主题色：绿色 启动图背景色：白色\"background_color\": \"#f2f3f5\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//2. 主题色：绿色 启动图背景色：绿色\"background_color\": \"#48BB74\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//3. 主题色：橙色 启动图背景色：橙色\"background_color\": \"#f60\",\"display\": \"standalone\",\"theme_color\": \"#f60\" Tips:这里用到的manifest.json不要与作为离线缓存的manifest混淆。 最后来对比感受下非PWA的百度站点VsPWA站点的hackernews在Add to HomeScreen后，体验上的差异。 概括下主要的差异：1.增加了同原生应用一样的启动图过渡界面2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。注：PWA更多的特性这里并未应用，其实PWA可以做的更多。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]}]