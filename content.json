[{"title":"vue-hackernews-2.0 源码解读","date":"2017-05-14T00:55:00.000Z","path":"2017/05/14/vue-hackernews-2.0-code-explain/","text":"前言 HackerNews是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。 vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。 结构概览 项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。 客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过app.$mount(&#39;#app&#39;)挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行Hydration（合并） 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748│ manifest.json # progressive web apps配置文件│ package.json # 项目配置文件│ server.js # 服务端渲染│ ├─public # 静态资源│ logo-120.png│ logo-144.png│ logo-152.png│ logo-192.png│ logo-384.png│ logo-48.png│ └─src │ app.js # 整合 router,filters,vuex 的入口文件 │ App.vue # 根 vue 组件 │ entry-client.js # client 的入口文件 │ entry-server.js # server 的入口文件 │ index.template.html # html 模板 │ ├─api │ create-api-client.js # Client数据源配置 │ create-api-server.js # server数据源配置 │ index.js # 数据请求API │ ├─components │ Comment.vue # 评论组件 │ Item.vue # │ ProgressBar.vue # 进度条组件 │ Spinner.vue # 加载提示组件 │ ├─router │ index.js # router配置 │ ├─store # Vue store模块 │ actions.js # 根级别的 action │ getters.js # 属性接口 │ index.js # 我们组装模块并导出 store 的地方 │ mutations.js # 根级别的 mutation │ ├─util │ filters.js # 过滤器 │ title.js # 工具类 │ └─views CreateListView.js # 动态生成列表界面的工厂方法 ItemList.vue # List界面组件 ItemView.vue # 单List项组件 UserView.vue # 用户界面组件 本项目包含开发环境及生产环境，我们先学习开发环境。 开发环境的服务端渲染流程让我们从node环境下执行命令开始。12# serve in dev mode, with hot reload at localhost:8080$npm run dev 然后发生了什么？我们来看一张图。 Tips:package.json解读 上述执行dev属性对应的脚本：node server即node server.js，即执行server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768···const app = express()// 服务端渲染的HTML模板const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer // 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中 return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125;let rendererlet readyPromiseif (isProd) &#123; // 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle const bundle = require('./dist/vue-ssr-server-bundle.json') //client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能 const clientManifest = require('./dist/vue-ssr-client-manifest.json') //vue-server-renderer创建bundle渲染器并绑定server bundle renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; // 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回 // 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新 //以及通过webpack的watch功能实现服务端代码的热更新 readyPromise = require('./build/setup-dev-server')(app, (bundle, options) =&gt; &#123; // 基于热更新，回调生成最新的bundle渲染器 renderer = createRenderer(bundle, options) &#125;)&#125;//依次装载一系列Express中间件，用来处理静态资源，数据压缩等···app.use(···)···function render (req, res) &#123; ··· // 设置请求的url const context = &#123; title: 'Vue HN 2.0', // default title url: req.url &#125; // 为渲染器绑定的server bundle（即entry-server.js）设置入参context renderer.renderToString(context, (err, html) =&gt; &#123; ··· res.end(html) ··· &#125;)&#125;//启动一个服务并监听从 8080 端口进入的所有连接请求。app.get('*', isProd ? render : (req, res) =&gt; &#123; readyPromise.then(() =&gt; render(req, res))&#125;)const port = process.env.PORT || 8080app.listen(port, () =&gt; &#123; console.log(`server started at localhost:$&#123;port&#125;`)&#125;) Tips1.vue-server-renderer(Vue服务端渲染，同时支持prefetch、prerender特性)2.webpack-dev-server(webpack-dev-middleware/webpack-hot-middleware)3.此项目全面使用ES6语法，包括箭头函数，解构赋值，Promise等特性。 server.js最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080请求经由express路由接收后，执行处理逻辑:readyPromise.then(() =&gt; render(req, res))沿着Promise的调用链处理：开发环境下1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。最终通过回调把生成在内存中的server bundle传回。2.创建渲染器，绑定server bundle，设置渲染模板，缓存等3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等4.最后将渲染好的HTML写入http响应体，传回浏览器。 接下来分解解读下这几个的实现。 setup-dev-server看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色） build/setup-dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// setup-dev-server.jsconst clientConfig = require('./webpack.client.config')const serverConfig = require('./webpack.server.config')module.exports = function setupDevServer (app, cb) &#123; let bundle, clientManifest let resolve const readyPromise = new Promise(r =&gt; &#123; resolve = r &#125;) const ready = (...args) =&gt; &#123; resolve() cb(...args) &#125; // 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem // 读取内存中的bundle 并通过传入的回调更新server.js中的bundle clientCompiler.plugin('done', () =&gt; &#123; const fs = devMiddleware.fileSystem const readFile = file =&gt; fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') clientManifest = JSON.parse(readFile('vue-ssr-client-manifest.json')) if (bundle) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) // hot middleware app.use(require('webpack-hot-middleware')(clientCompiler)) // watch and update server renderer const serverCompiler = webpack(serverConfig) // 获取基于memory-fs创建的内存文件系统对象 const mfs = new MFS() serverCompiler.outputFileSystem = mfs // 设置文件重新编译监听并通过传入的回调更新server.js中的bundle serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err stats = stats.toJson() stats.errors.forEach(err =&gt; console.error(err)) stats.warnings.forEach(err =&gt; console.warn(err)) const readFile = file =&gt; mfs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile('vue-ssr-server-bundle.json')) if (clientManifest) &#123; ready(bundle, &#123; clientManifest &#125;) &#125; &#125;) return readyPromise&#125; build/webpack.base.config.js 123456789101112131415161718192021222324252627282930313233343536// build/webpack.base.config.jsmodule.exports = &#123; // 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map devtool: isProd ? false : '#cheap-module-source-map', // 打包输出配置 output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/', filename: '[name].[chunkhash].js' &#125;, resolve: &#123; alias: &#123; 'public': path.resolve(__dirname, '../public') &#125; &#125;, module: &#123; ··· // 一系列加载器 &#125;, plugins:[ // 压缩js的插件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来 new ExtractTextPlugin(&#123; &#125;) ]&#125; build/webpack.client.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041// build/webpack.client.config.js// 基于webpack-merge工具合并base以及client特定配置项const config = merge(base, &#123; // 配置编译的入口文件 entry: &#123; app: './src/entry-client.js' &#125;, // 在alias设置客户端数据请求API为create-api-client.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-client.js' &#125; &#125;, plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"client\"' &#125;), // 设置打包时公共模块的提取规则 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // a module is extracted into the vendor chunk if... return ( // it's inside node_modules /node_modules/.test(module.context) &amp;&amp; // and not a CSS file (due to extract-text-webpack-plugin limitation) !/\\.css$/.test(module.request) ) &#125; &#125;), // 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name， // 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new VueSSRClientPlugin() ]&#125;) bulid/webpack.server.config.js 1234567891011121314151617181920212223242526272829303132333435// build/webpack.server.config.jsmodule.exports = merge(base, &#123; // 指定生成后的运行环境在node target: 'node', // 设置代码调试map devtool: '#source-map', // 配置编译的入口文件 entry: './src/entry-server.js', // 设置输出文件名，并设置模块导出为commonjs2类型 output: &#123; filename: 'server-bundle.js', libraryTarget: 'commonjs2' &#125;, // 在alias设置好服务端数据请求API为create-api-server.js模块 resolve: &#123; alias: &#123; 'create-api': './create-api-server.js' &#125; &#125;, // 设置不打包排除规则 externals: nodeExternals(&#123; // do not externalize CSS files in case we need to import it from a dep whitelist: /\\.css$/ &#125;), plugins: [ // 设置环境变量 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': '\"server\"' &#125;), //设置VueSSRServerPlugin插件 new VueSSRServerPlugin() ]&#125;) 如上，基于 webpack config 的setup-dev-server就到这里，接下来说创建渲染器。 创建渲染器12345678910function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer console.log(`createRenderer`) return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125; 创建渲染器时重点两件事：1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件entry-server.js打包生成的。当渲染器调用renderer.renderToString开始渲染时，会执行该入口文件的默认方法。2.传入了一个html模板index.template.html，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。 Tips:index.template.html解读 顺着readyPromise.then的调用链，接下来调用render方法123456function render (req, res) &#123;··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) &#125;)&#125; renderer.renderToString方法内部会先调用入口模块entry-server.js的默认方法，我们看下entry-server.js主要做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// This exported function will be called by `bundleRenderer`.// This is where we perform data-prefetching to determine the// state of our application before actually rendering it.// Since data fetching is async, this function is expected to// return a Promise that resolves to the app instance.export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const s = isDev &amp;&amp; Date.now() const &#123; app, router, store &#125; = createApp() // set router's location // 手动路由切换到请求的url，即'/' router.push(context.url) // wait until router has resolved possible async hooks router.onReady(() =&gt; &#123; // 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js const matchedComponents = router.getMatchedComponents() // no matched routes if (!matchedComponents.length) &#123; reject(&#123; code: 404 &#125;) &#125; // Call fetchData hooks on components matched by the route. // A preFetch hook dispatches a store action and returns a Promise, // which is resolved when the action is complete and store state has been // updated. // 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据 Promise.all(matchedComponents.map(component =&gt; &#123; return component.asyncData &amp;&amp; component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125;)).then(() =&gt; &#123; isDev &amp;&amp; console.log(`data pre-fetch: $&#123;Date.now() - s&#125;ms`) // After all preFetch hooks are resolved, our store is now // filled with the state needed to render the app. // Expose the state on the render context, and let the request handler // inline the state in the HTML response. This allows the client-side // store to pick-up the server-side state without having to duplicate // the initial data fetching on the client. // 把vuex的state设置到传入的context.initialState上 context.state = store.state // 返回state, router已经设置好的Vue实例app resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; entry-server.js的主要工作：0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。1.手动路由切换到请求的url，即’/‘2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js） Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：服务端渲染时的数据预取流程 还记得index.template.html被设置到template属性中吗？此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？123&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt; 就是这里，这个&lt;!--vue-ssr-outlet--&gt;Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template. 接下来，Vue渲染器会回调callback方法，我们回到server.js123456789101112function render (req, res) &#123; ··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) ··· &#125;)&#125; 此时只需要将渲染好的html写入http响应体就结束了，浏览器客户端就可以看到页面了。 接下来我们看看服务端数据预取的实现 服务端渲染时的数据预取流程上文提到，服务端渲染时，会手动将路由导航到请求地址即&#39;/&#39;下，然后调用该路由组件的asyncData方法来预取数据 那么我们看看路由配置 12345678910111213141516171819202122232425// /src/router/index.jsVue.use(Router)// route-level code splittingconst createListView = id =&gt; () =&gt; System.import('../views/CreateListView').then(m =&gt; m.default(id))const ItemView = () =&gt; System.import('../views/ItemView.vue')const UserView = () =&gt; System.import('../views/UserView.vue')export function createRouter () &#123; return new Router(&#123; mode: 'history', scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [ &#123; path: '/top/:page(\\\\d+)?', component: createListView('top') &#125;, &#123; path: '/new/:page(\\\\d+)?', component: createListView('new') &#125;, &#123; path: '/show/:page(\\\\d+)?', component: createListView('show') &#125;, &#123; path: '/ask/:page(\\\\d+)?', component: createListView('ask') &#125;, &#123; path: '/job/:page(\\\\d+)?', component: createListView('job') &#125;, &#123; path: '/item/:id(\\\\d+)', component: ItemView &#125;, &#123; path: '/user/:id', component: UserView &#125;, &#123; path: '/', redirect: '/top' &#125; ] &#125;)&#125; 地址&#39;/&#39;是做了redirect到&#39;/top&#39;,其实就是默认地址就是到top页面，在看第一条路由配置，&#39;/top&#39;路由对应的组件是createListView(&#39;top&#39;) 12345678910111213141516171819// /src/views/CreateListView.jsexport default function createListView (type) &#123; return &#123; name: `$&#123;type&#125;-stories-view`, asyncData (&#123; store &#125;) &#123; console.log(`createListView asyncData`) return store.dispatch('FETCH_LIST_DATA', &#123; type &#125;) &#125;, title: camelize(type), render (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; &#125;&#125; Tips: Vuex状态管理1.dispatch对应Action，commit对应mutation2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。 Vuex state状态变更流程 asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store. 最后数据就都保存在store这里了。12345678910111213141516171819202122// /src/store/index.jsexport function createStore () &#123; return new Vuex.Store(&#123; state: &#123; activeType: null, itemsPerPage: 20, items: &#123;/* [id: number]: Item */&#125;, users: &#123;/* [id: string]: User */&#125;, lists: &#123; top: [/* number */], new: [], show: [], ask: [], job: [] &#125; &#125;, actions, mutations, getters &#125;)&#125; 然后将开始通过Render 函数创建HTML。 123456// /src/views/CreateListView.jsrender (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; 123456789101112131415161718192021222324// /src/views/ItemList.vue···&lt;template&gt; &lt;div class=\"news-view\"&gt; &lt;div class=\"news-list-nav\"&gt; &lt;router-link v-if=\"page &gt; 1\" :to=\"'/' + type + '/' + (page - 1)\"&gt;&amp;lt; prev&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;&amp;lt; prev&lt;/a&gt; &lt;span&gt;&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;&lt;/span&gt; &lt;router-link v-if=\"hasMore\" :to=\"'/' + type + '/' + (page + 1)\"&gt;more &amp;gt;&lt;/router-link&gt; &lt;a v-else class=\"disabled\"&gt;more &amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;transition :name=\"transition\"&gt; &lt;div class=\"news-list\" :key=\"displayedPage\" v-if=\"displayedPage &gt; 0\"&gt; &lt;transition-group tag=\"ul\" name=\"item\"&gt; &lt;item v-for=\"item in displayedItems\" :key=\"item.id\" :item=\"item\"&gt; &lt;/item&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;··· 这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的&lt;!--vue-ssr-outlet--&gt;,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。 Tips:后续更新内容规划：1.生产环境下的服务端渲染逻辑流程2.客户端渲染逻辑流程3.客户端vue组件细节解读","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]},{"title":"vue-hackernews-2.0 细节解读","date":"2017-05-12T16:00:00.000Z","path":"2017/05/13/vue-hackernews-2.0-code-detail/","text":"前言本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对项目源码解读的细节补充。 package.json解读该文件提供了四种命令1234567891011# install dependenciesnpm install # or yarn# serve in dev mode, with hot reload at localhost:8080npm run dev# build for productionnpm run build# serve in production modenpm start 执行npm install查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。 Tips:dependencies与devDependencies的区别devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。 执行npm run dev1234567\"scripts\": &#123;\"dev\": \"node server\",\"start\": \"cross-env NODE_ENV=production node server\",\"build\": \"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server\",\"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules\",\"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules\"&#125;, 查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：node server即node server.js，即执行server.js 执行npm run build同样，找到build属性，并执行：rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server，即删除dist目录并执行npm run build:client和npm run build:server对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件 执行npm start同样，找到start属性，并执行：cross-env NODE_ENV=production node server，即通过cross-env模块设置NODE_ENV环境变量为production，并执行node server Tips:为什么是npm start而不是npm run start?1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见npm --help2.其他三个命令都不是内置命令，需要经由npm run去执行。 index.template.html解读12345&lt;meta name=\"mobile-web-app-capable\" content=\"yes\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\"&gt;&lt;link rel=\"shortcut icon\" sizes=\"48x48\" href=\"/public/logo-48.png\"&gt;&lt;meta name=\"theme-color\" content=\"#f60\"&gt;&lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; 这段html代码功能：移动端浏览器适配及PWA适配 Tips:PWA (progressive web apps)-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。 接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。浏览器体验：在Chrome浏览器地址栏中输入项目地址，效果如下： PWA体验：通过Chrome的Add to Homescreen功能，将该站点添加到桌面。效果如下： 点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。 现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：123456789101112//1. 主题色：绿色 启动图背景色：白色\"background_color\": \"#f2f3f5\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//2. 主题色：绿色 启动图背景色：绿色\"background_color\": \"#48BB74\",\"display\": \"standalone\",\"theme_color\": \"#48BB74\"//3. 主题色：橙色 启动图背景色：橙色\"background_color\": \"#f60\",\"display\": \"standalone\",\"theme_color\": \"#f60\" Tips:这里用到的manifest.json不要与作为离线缓存的manifest混淆。 最后来对比感受下非PWA的百度站点VsPWA站点的hackernews在Add to HomeScreen后，体验上的差异。 概括下主要的差异：1.增加了同原生应用一样的启动图过渡界面2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。注：PWA更多的特性这里并未应用，其实PWA可以做的更多。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://wangfuda.github.io/tags/vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wangfuda.github.io/tags/Vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wangfuda.github.io/tags/vue-router/"},{"name":"ssr","slug":"ssr","permalink":"https://wangfuda.github.io/tags/ssr/"},{"name":"webpack","slug":"webpack","permalink":"https://wangfuda.github.io/tags/webpack/"},{"name":"node","slug":"node","permalink":"https://wangfuda.github.io/tags/node/"}]}]