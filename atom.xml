<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>osan&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangfuda.github.io/"/>
  <updated>2017-07-01T08:57:42.506Z</updated>
  <id>https://wangfuda.github.io/</id>
  
  <author>
    <name>osan</name>
    <email>o.san@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Retrofit 2.3.0 源码解析</title>
    <link href="https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/</id>
    <published>2017-07-01T07:24:47.838Z</published>
    <updated>2017-07-01T08:57:42.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> A type-safe HTTP client for Android and Java</p>
</blockquote>
<p>Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。</p>
<p>基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/retrofit/architecture.png" alt="architecture"></p>
<a id="more"></a>
<p>项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall<br>这里我们把基于Retrofit的HTTP通信比做是邮递信件。</p>
<blockquote>
<p>邮递信件</p>
</blockquote>
<ul>
<li>信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。</li>
<li>邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。</li>
<li>邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理</li>
<li>邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。</li>
</ul>
<blockquote>
<p>基于Retrofit的HTTP通信</p>
</blockquote>
<ul>
<li>Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。</li>
<li>Proxy：然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等</li>
<li>Invocation：这里负责调度同步或异步请求，请求装配和响应解析</li>
<li>RawCall：这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。</li>
</ul>
<p>来看看寄信和Retrofit之间的对比：<br><img src="/assets/postImg/retrofit/arch_flow.png" alt="arch_flow"></p>
<p>大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。</p>
<!--more-->
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><p><a href="http://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">官方 Javadoc</a><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">BuiltInConverters.java</span>					<span class="comment"># 内建Converter</span></div><div class="line"><span class="string">│</span>  <span class="string">Call.java</span>							<span class="comment"># 发送请求接收响应的retrofit方法调用</span></div><div class="line"><span class="string">│</span>  <span class="string">CallAdapter.java</span>						<span class="comment"># 适配Call的响应类型，将默认响应类型R转换为类型T</span></div><div class="line"><span class="string">│</span>  <span class="string">Callback.java</span>						<span class="comment"># 返回服务端或离线请求的响应体</span></div><div class="line"><span class="string">│</span>  <span class="string">Converter.java</span>						<span class="comment"># HTTP交互中，转换对象为数据 或 从数据转换为对象</span></div><div class="line"><span class="string">│</span>  <span class="string">DefaultCallAdapterFactory.java</span>				<span class="comment"># 默认CallAdapter工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">ExecutorCallAdapterFactory.java</span>				<span class="comment"># http请求执行器工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">HttpException.java</span>						<span class="comment"># 非2xx HTTP响应的异常处理</span></div><div class="line"><span class="string">│</span>  <span class="string">OkHttpCall.java</span>						<span class="comment"># 真正调用OkHttp3发送Http请求的类</span></div><div class="line"><span class="string">│</span>  <span class="string">package-info.java</span>						<span class="comment"># 包描述</span></div><div class="line"><span class="string">│</span>  <span class="string">ParameterHandler.java</span>					<span class="comment"># 参数注解解析器</span></div><div class="line"><span class="string">│</span>  <span class="string">Platform.java</span>						<span class="comment"># 平台适配(Java/Android)</span></div><div class="line"><span class="string">│</span>  <span class="string">RequestBuilder.java</span>						<span class="comment"># 请求拼装</span></div><div class="line"><span class="string">│</span>  <span class="string">Response.java</span>						<span class="comment"># 原汁原味的HTTP 响应体，所谓 T body</span></div><div class="line"><span class="string">│</span>  <span class="string">Retrofit.java</span>						<span class="comment"># 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口</span></div><div class="line"><span class="string">│</span>  <span class="string">ServiceMethod.java</span>						<span class="comment"># 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请</span></div><div class="line">								<span class="comment"># 求头、是否是multipart等等),并返回用于发起http请求的Call对象</span></div><div class="line"><span class="string">│</span>  <span class="string">Utils.java</span>							<span class="comment"># 工具类</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">└─http</span>								<span class="comment"># http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解）</span></div><div class="line"></div><div class="line">        <span class="string">Body.java</span>						<span class="comment"># control the request body of a POST/PUT request</span></div><div class="line">        <span class="string">DELETE.java</span>						<span class="comment"># Make a DELETE request</span></div><div class="line">        <span class="string">Field.java</span>						<span class="comment"># Named pair for a form-encoded request</span></div><div class="line">        <span class="string">FieldMap.java</span>						<span class="comment"># Named key/value pairs for a form-encoded request</span></div><div class="line">        <span class="string">FormUrlEncoded.java</span>					<span class="comment"># Denotes that the request body will use form URL encoding</span></div><div class="line">        <span class="string">GET.java</span>						<span class="comment"># Make a GET request</span></div><div class="line">        <span class="string">HEAD.java</span>						<span class="comment"># Make a HEAD request</span></div><div class="line">        <span class="string">Header.java</span>						<span class="comment"># Replaces the header with the value of its target</span></div><div class="line">        <span class="string">HeaderMap.java</span>						<span class="comment"># Adds headers specified in the Map</span></div><div class="line">        <span class="string">Headers.java</span>						<span class="comment"># Adds headers literally supplied in the value</span></div><div class="line">        <span class="string">HTTP.java</span>						<span class="comment"># Use a custom HTTP verb for a request</span></div><div class="line">        <span class="string">Multipart.java</span>						<span class="comment"># Denotes that the request body is multi-part</span></div><div class="line">        <span class="string">OPTIONS.java</span>						<span class="comment"># Make an OPTIONS request</span></div><div class="line">        <span class="string">package-info.java</span>					<span class="comment"># Package description</span></div><div class="line">        <span class="string">Part.java</span>						<span class="comment"># Denotes a single part of a multi-part request</span></div><div class="line">        <span class="string">PartMap.java</span>						<span class="comment"># Denotes name and value parts of a multi-part request</span></div><div class="line">        <span class="string">PATCH.java</span>						<span class="comment"># Make a PATCH request</span></div><div class="line">        <span class="string">Path.java</span>						<span class="comment"># Named replacement in a URL path segment</span></div><div class="line">        <span class="string">POST.java</span>						<span class="comment"># Make a POST request</span></div><div class="line">        <span class="string">PUT.java</span>						<span class="comment"># Make a PUT request</span></div><div class="line">        <span class="string">Query.java</span>						<span class="comment"># Query parameter appended to the URL</span></div><div class="line">        <span class="string">QueryMap.java</span>						<span class="comment"># Query parameter keys and values appended to the URL</span></div><div class="line">        <span class="string">QueryName.java</span>						<span class="comment"># Query parameter appended to the URL that has no value</span></div><div class="line">        <span class="string">Streaming.java</span>						<span class="comment"># Treat the response body on methods returning Response as is, i.e. </span></div><div class="line">								<span class="comment"># without converting body() to byte[]</span></div><div class="line">        <span class="string">Url.java</span>						<span class="comment"># URL resolved against the base URL</span></div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的基本用法"><a href="#Retrofit的基本用法" class="headerlink" title="Retrofit的基本用法"></a>Retrofit的基本用法</h2><p>让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。</p>
<p>用 Java 接口的方式定义一个HTTP API.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Retrofit 类生成一个 GitHubService 接口的实现实例.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>
<p>Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.<br>GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure></p>
<p>执行同步或异步HTTP请求，得到HTTP响应数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的源码解析"><a href="#Retrofit的源码解析" class="headerlink" title="Retrofit的源码解析"></a>Retrofit的源码解析</h2><p>首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器</p>
<p>Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。</p>
<p>下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall.</p>
<blockquote>
<p>Flow - Builder</p>
</blockquote>
<p><code>Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
    ...
    .build();</code><br><a href="https://en.wikipedia.org/wiki/Builder_pattern" target="_blank" rel="external">Tips.设计模式之Builder模式</a></p>
<p>基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java -&gt; class Builder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      </div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">          callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。<br>注：<code>validateEagerly</code>，用于指定是否预先解析注解，加速接口访问效率。</p>
<blockquote>
<p>Flow - Proxy</p>
</blockquote>
<p><code>GitHubService service = retrofit.create(GitHubService.class);</code><br>我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。<br>为什么用动态代理？<br>这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。</p>
<blockquote>
<p>Tips.<a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="external">动态代理</a></p>
</blockquote>
<p><code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code><br>通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。</p>
<p>invoke中主要由ServiceMethod和CallAdapter完成了三件事：</p>
<ul>
<li>请求方法的注解解析</li>
<li>创建OkHttpCall实例，为后续流程中的HTTP请求执行做准备，详见 Flow - Invocation.</li>
<li>适配Call的响应类型，将默认响应类型R转换为类型T</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p>ServiceMethod.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      callAdapter = createCallAdapter();</div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">      </div><div class="line">	  ...</div><div class="line"></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">        Type parameterType = parameterTypes[p];</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>获取callAdapter、responseType、responseConverter接口对象</p>
<p>解析Method的注解</p>
<p>解析Method的参数注解</p>
<p>解析Method的参数中使用了依赖请求API的动态参数的注解，交由ParameterHandler处理</p>
<p>CallAdapter.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>适配Call的响应类型，将默认响应类型R转换为类型T.比如官方的RxJavaCallAdapter可以结合Rxjava特性对Call的响应做RxJava观察者模式转换，进一步解放生产力。</p>
<p>注：未在Builder阶段指定CallAdapter(如 RxJavaCallAdapterFactory )的情况下，默认的 CallAdapter 不对Call做任何处理。<br>见 DefaultCallAdapterFactory:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CallAdapter.Factory INSTANCE = <span class="keyword">new</span> DefaultCallAdapterFactory();</div><div class="line"></div><div class="line">  ...</div><div class="line">	  ...</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> call;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Flow - Invocation</p>
</blockquote>
<p><code>Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</code></p>
<p>这一步开始基于同步的方式执行HTTP请求，并得到返回的HTTP响应数据.</p>
<p>本质上是执行了 OkHttpCall 的 execute方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">     </div><div class="line">     ...</div><div class="line">        ...</div><div class="line">          call = rawCall = createRawCall();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parseResponse(call.execute());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，这里创建了RawCall，即真正的去执行HTTP请求任务的对象。<br>这里还负责HTTP请求的响应数据解析。<br>我们看下<code>createRawCall()</code>干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = serviceMethod.toRequest(args);</div><div class="line">    okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> call;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>serviceMethod.toRequest()的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="comment">/** Builds an HTTP request from method arguments. */</span></div><div class="line">  <span class="function">Request <span class="title">toRequest</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,</div><div class="line">        contentType, hasBody, isFormEncoded, isMultipart);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> requestBuilder.build();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>toRequest 方法通过 RequestBuilder 创建了 okhttp3 做 HTTP 请求时需要的 Request 对象。</p>
<p>serviceMethod.callFactory.newCall(request)的功能：<br>建立一个请求通道，为执行HTTP请求做准备。<br>这里callFactory可以由使用者指定，默认为 OkHttpClient，见：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>回头看下 OkHttpCall 中 execute 方法最后一句: <code>return parseResponse(call.execute());</code><br>这里调用真正的HTTP请求客户端的请求执行方法。也就是来到了接下来的一个流程。</p>
<blockquote>
<p>Flow - RawCall</p>
</blockquote>
<p>上个 Flow 中最后一步， <code>call.execute()</code>,开启了真正的HTTP请求，即通过 okhttp3 完成HTTP请求。<br>这个部分没什么代码可讲，属于面向接口开发的典范，要讲就该去讲 Okhttp 框架的源码了。</p>
<p>这个部分引出了 Retrofit 的开源拥有者-Square 公司的另一个优秀的开源项目 Okhttp,是不是也很想一探究竟？</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>最后我想拿 Retrofit 官方的一段话来结束：</p>
<p>Contributing</p>
<p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
<p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running mvn clean verify.</p>
<p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>
<p>纳尼？</p>
<p>Cos 我想把亲手画的两副图贡献给 Retrofit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit&lt;/a&gt; A type-safe HTTP client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。&lt;/p&gt;
&lt;p&gt;基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/retrofit/architecture.png&quot; alt=&quot;architecture&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Retrofit" scheme="https://wangfuda.github.io/tags/Retrofit/"/>
    
      <category term="okhttp" scheme="https://wangfuda.github.io/tags/okhttp/"/>
    
      <category term="http" scheme="https://wangfuda.github.io/tags/http/"/>
    
      <category term="restful api" scheme="https://wangfuda.github.io/tags/restful-api/"/>
    
  </entry>
  
  <entry>
    <title>todo-mvp-dagger 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-07-01T08:53:39.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>The Android Architecture Blueprints project demonstrates strategies to help solve or avoid these common problems. This project implements the same app using different architectural concepts and tools.</p>
</blockquote>
<p>敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/googlesamples/android-archite
    
    </summary>
    
    
      <category term="mvp" scheme="https://wangfuda.github.io/tags/mvp/"/>
    
      <category term="dagger" scheme="https://wangfuda.github.io/tags/dagger/"/>
    
      <category term="android architecture" scheme="https://wangfuda.github.io/tags/android-architecture/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-05-14T09:48:44.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="external">HackerNews</a>是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。</p>
</blockquote>
<p>vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/hn-architecture.png" alt="hn-architecture"></p>
<p>项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. </p>
<p>服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。</p>
<p>客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过<code>app.$mount(&#39;#app&#39;)</code>挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行<a href="https://ssr.vuejs.org/en/hydration.html" target="_blank" rel="external">Hydration</a>（合并）</p>
<a id="more"></a>
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">manifest.json</span>				<span class="comment"># progressive web apps配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">package.json</span>					<span class="comment"># 项目配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">server.js</span>					<span class="comment"># 服务端渲染</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">├─public</span>                                    	<span class="comment"># 静态资源</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-120.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-144.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-152.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-192.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-384.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-48.png</span></div><div class="line"><span class="string">│</span>      </div><div class="line"><span class="string">└─src</span></div><div class="line">    <span class="string">│</span>  <span class="string">app.js</span>					<span class="comment"># 整合 router,filters,vuex 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">App.vue</span>					<span class="comment"># 根 vue 组件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-client.js</span>				<span class="comment"># client 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-server.js</span>				<span class="comment"># server 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">index.template.html</span>			<span class="comment"># html 模板</span></div><div class="line">    <span class="string">│</span>  </div><div class="line">    <span class="string">├─api</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-client.js</span>			<span class="comment"># Client数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-server.js</span>			<span class="comment"># server数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 数据请求API</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─components</span></div><div class="line">    <span class="string">│</span>      <span class="string">Comment.vue</span>				<span class="comment"># 评论组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Item.vue</span>				<span class="comment"># </span></div><div class="line">    <span class="string">│</span>      <span class="string">ProgressBar.vue</span>			<span class="comment"># 进度条组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Spinner.vue</span>				<span class="comment"># 加载提示组件</span></div><div class="line">    <span class="string">│</span>     </div><div class="line">    <span class="string">├─router</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># router配置</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─store</span>					<span class="comment"># Vue store模块</span></div><div class="line">    <span class="string">│</span>      <span class="string">actions.js</span>				<span class="comment"># 根级别的 action</span></div><div class="line">    <span class="string">│</span>      <span class="string">getters.js</span>				<span class="comment"># 属性接口</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 我们组装模块并导出 store 的地方</span></div><div class="line">    <span class="string">│</span>      <span class="string">mutations.js</span>				<span class="comment"># 根级别的 mutation</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─util</span></div><div class="line">    <span class="string">│</span>      <span class="string">filters.js</span>				<span class="comment"># 过滤器</span></div><div class="line">    <span class="string">│</span>      <span class="string">title.js</span>				<span class="comment"># 工具类</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">└─views</span></div><div class="line">            <span class="string">CreateListView.js</span>			<span class="comment"># 动态生成列表界面的工厂方法</span></div><div class="line">            <span class="string">ItemList.vue</span>			<span class="comment"># List界面组件</span></div><div class="line">            <span class="string">ItemView.vue</span>			<span class="comment"># 单List项组件</span></div><div class="line">            <span class="string">UserView.vue</span>			<span class="comment"># 用户界面组件</span></div></pre></td></tr></table></figure>
<p>本项目包含开发环境及生产环境，我们先学习开发环境。</p>
<h2 id="开发环境的服务端渲染流程"><a href="#开发环境的服务端渲染流程" class="headerlink" title="开发环境的服务端渲染流程"></a>开发环境的服务端渲染流程</h2><p>让我们从node环境下执行命令开始。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line"><span class="string">$npm</span> <span class="string">run</span> <span class="string">dev</span></div></pre></td></tr></table></figure></p>
<p>然后发生了什么？我们来看一张图。<br><img src="/assets/postImg/rundev.png" alt="rundev"></p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">package.json解读</a></p>
</blockquote>
<p>上述执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"><span class="comment">// 服务端渲染的HTML模板</span></div><div class="line"><span class="keyword">const</span> template = fs.readFileSync(resolve(<span class="string">'./src/index.template.html'</span>), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">  <span class="comment">// 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中</span></div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line"></div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> renderer</div><div class="line"><span class="keyword">let</span> readyPromise</div><div class="line"><span class="keyword">if</span> (isProd) &#123;</div><div class="line">  <span class="comment">// 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle</span></div><div class="line">  <span class="keyword">const</span> bundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</div><div class="line">  <span class="comment">//client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能</span></div><div class="line">  <span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</div><div class="line">  <span class="comment">//vue-server-renderer创建bundle渲染器并绑定server bundle</span></div><div class="line">  renderer = createRenderer(bundle, &#123;</div><div class="line">    clientManifest</div><div class="line">  &#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回</span></div><div class="line">  <span class="comment">// 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新</span></div><div class="line">  <span class="comment">//以及通过webpack的watch功能实现服务端代码的热更新</span></div><div class="line">  readyPromise = <span class="built_in">require</span>(<span class="string">'./build/setup-dev-server'</span>)(app, (bundle, options) =&gt; &#123;</div><div class="line">	<span class="comment">// 基于热更新，回调生成最新的bundle渲染器</span></div><div class="line">    renderer = createRenderer(bundle, options)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//依次装载一系列Express中间件，用来处理静态资源，数据压缩等</span></div><div class="line">···</div><div class="line">app.use(···)</div><div class="line">···</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  ···</div><div class="line"> </div><div class="line">  <span class="comment">// 设置请求的url</span></div><div class="line">  <span class="keyword">const</span> context = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'Vue HN 2.0'</span>, <span class="comment">// default title</span></div><div class="line">    url: req.url</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 为渲染器绑定的server bundle（即entry-server.js）设置入参context</span></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    ···</div><div class="line">    res.end(html)</div><div class="line">	···</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//启动一个服务并监听从 8080 端口进入的所有连接请求。</span></div><div class="line">app.get(<span class="string">'*'</span>, isProd ? render : <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">  readyPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> render(req, res))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">8080</span></div><div class="line">app.listen(port, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`server started at localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips<br>1.<a href="https://ssr.vuejs.org" target="_blank" rel="external">vue-server-renderer</a>(Vue服务端渲染，同时支持prefetch、prerender特性)<br>2.<a href="https://webpack.js.org/guides/development/#webpack-dev-server" target="_blank" rel="external">webpack-dev-server</a>(webpack-dev-middleware/webpack-hot-middleware)<br>3.此项目全面使用<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6语法</a>，包括箭头函数，解构赋值，Promise等特性。</p>
</blockquote>
<p><code>server.js</code>最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080<br>请求经由<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">express</a>路由接收后，执行处理逻辑:<code>readyPromise.then(() =&gt; render(req, res))</code><br>沿着Promise的调用链处理：<br>开发环境下<br>1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。<br>最终通过回调把生成在内存中的server bundle传回。<br>2.创建渲染器，绑定server bundle，设置渲染模板，缓存等<br>3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等<br>4.最后将渲染好的HTML写入http响应体，传回浏览器。</p>
<p>接下来分解解读下这几个的实现。</p>
<h3 id="setup-dev-server"><a href="#setup-dev-server" class="headerlink" title="setup-dev-server"></a>setup-dev-server</h3><p>看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色）<br><img src="/assets/postImg/serverjs.png" alt="serverjs"></p>
<p><code>build/setup-dev-server.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setup-dev-server.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'./webpack.client.config'</span>)</div><div class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'./webpack.server.config'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">setupDevServer</span> (<span class="params">app, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> bundle, clientManifest</div><div class="line">  <span class="keyword">let</span> resolve</div><div class="line">  <span class="keyword">const</span> readyPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123; resolve = r &#125;)</div><div class="line">  <span class="keyword">const</span> ready = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    resolve()</div><div class="line">    cb(...args)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem</span></div><div class="line">  <span class="comment">// 读取内存中的bundle 并通过传入的回调更新server.js中的bundle</span></div><div class="line">  clientCompiler.plugin(<span class="string">'done'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> fs = devMiddleware.fileSystem</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> fs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line">    clientManifest = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-client-manifest.json'</span>))</div><div class="line">    <span class="keyword">if</span> (bundle) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// hot middleware</span></div><div class="line">  app.use(<span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(clientCompiler))</div><div class="line"></div><div class="line">  <span class="comment">// watch and update server renderer</span></div><div class="line">  <span class="keyword">const</span> serverCompiler = webpack(serverConfig)</div><div class="line">  <span class="comment">// 获取基于memory-fs创建的内存文件系统对象</span></div><div class="line">  <span class="keyword">const</span> mfs = <span class="keyword">new</span> MFS()</div><div class="line">  serverCompiler.outputFileSystem = mfs</div><div class="line">  <span class="comment">// 设置文件重新编译监听并通过传入的回调更新server.js中的bundle</span></div><div class="line">  serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">    stats = stats.toJson()</div><div class="line">    stats.errors.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div><div class="line">    stats.warnings.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.warn(err))</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> mfs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// read bundle generated by vue-ssr-webpack-plugin</span></div><div class="line">    bundle = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-server-bundle.json'</span>))</div><div class="line">    <span class="keyword">if</span> (clientManifest) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> readyPromise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.base.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.base.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map</span></div><div class="line">  devtool: isProd</div><div class="line">    ? <span class="literal">false</span></div><div class="line">    : <span class="string">'#cheap-module-source-map'</span>,</div><div class="line">  <span class="comment">// 打包输出配置</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    <span class="attr">publicPath</span>: <span class="string">'/dist/'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[chunkhash].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'public'</span>: path.resolve(__dirname, <span class="string">'../public'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line"></div><div class="line">    ···</div><div class="line">	<span class="comment">// 一系列加载器</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="attr">plugins</span>:[</div><div class="line">    <span class="comment">// 压缩js的插件</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      <span class="attr">compress</span>: &#123; <span class="attr">warnings</span>: <span class="literal">false</span> &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来</span></div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.client.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.client.config.js</span></div><div class="line"></div><div class="line"><span class="comment">// 基于webpack-merge工具合并base以及client特定配置项</span></div><div class="line"><span class="keyword">const</span> config = merge(base, &#123;</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: &#123;</div><div class="line">    <span class="attr">app</span>: <span class="string">'./src/entry-client.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置客户端数据请求API为create-api-client.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-client.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"client"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 设置打包时公共模块的提取规则</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="attr">minChunks</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">        <span class="comment">// a module is extracted into the vendor chunk if...</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="comment">// it's inside node_modules</span></div><div class="line">          /node_modules/.test(<span class="built_in">module</span>.context) &amp;&amp;</div><div class="line">          <span class="comment">// and not a CSS file (due to extract-text-webpack-plugin limitation)</span></div><div class="line">          !<span class="regexp">/\.css$/</span>.test(<span class="built_in">module</span>.request)</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name，</span></div><div class="line">    <span class="comment">// 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'manifest'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> VueSSRClientPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>bulid/webpack.server.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.server.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</div><div class="line">  <span class="comment">// 指定生成后的运行环境在node</span></div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  <span class="comment">// 设置代码调试map</span></div><div class="line">  devtool: <span class="string">'#source-map'</span>,</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: <span class="string">'./src/entry-server.js'</span>,</div><div class="line">  <span class="comment">// 设置输出文件名，并设置模块导出为commonjs2类型</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'server-bundle.js'</span>,</div><div class="line">    <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置好服务端数据请求API为create-api-server.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-server.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置不打包排除规则</span></div><div class="line">  externals: nodeExternals(&#123;</div><div class="line">    <span class="comment">// do not externalize CSS files in case we need to import it from a dep</span></div><div class="line">    whitelist: <span class="regexp">/\.css$/</span></div><div class="line">  &#125;),</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">	<span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"server"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">//设置VueSSRServerPlugin插件</span></div><div class="line">    <span class="keyword">new</span> VueSSRServerPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上，基于 webpack config 的<code>setup-dev-server</code>就到这里，接下来说<code>创建渲染器</code>。</p>
<h3 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`createRenderer`</span>)</div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line">   </div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建渲染器时重点两件事：<br>1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件<code>entry-server.js</code>打包生成的。<br>当渲染器调用<code>renderer.renderToString</code>开始渲染时，会执行该入口文件的默认方法。<br>2.传入了一个html模板<code>index.template.html</code>，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。</p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">index.template.html解读</a></p>
</blockquote>
<p>顺着readyPromise.then的调用链，接下来调用render方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">···</div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    res.end(html)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>renderer.renderToString</code>方法内部会先调用入口模块<code>entry-server.js</code>的默认方法，我们看下<code>entry-server.js</code>主要做了什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This exported function will be called by `bundleRenderer`.</span></div><div class="line"><span class="comment">// This is where we perform data-prefetching to determine the</span></div><div class="line"><span class="comment">// state of our application before actually rendering it.</span></div><div class="line"><span class="comment">// Since data fetching is async, this function is expected to</span></div><div class="line"><span class="comment">// return a Promise that resolves to the app instance.</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> s = isDev &amp;&amp; <span class="built_in">Date</span>.now()</div><div class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</div><div class="line"></div><div class="line">    <span class="comment">// set router's location</span></div><div class="line">    <span class="comment">// 手动路由切换到请求的url，即'/'</span></div><div class="line">    router.push(context.url)</div><div class="line"></div><div class="line">    <span class="comment">// wait until router has resolved possible async hooks</span></div><div class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js</span></div><div class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</div><div class="line">      <span class="comment">// no matched routes</span></div><div class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</div><div class="line">        reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Call fetchData hooks on components matched by the route.</span></div><div class="line">      <span class="comment">// A preFetch hook dispatches a store action and returns a Promise,</span></div><div class="line">      <span class="comment">// which is resolved when the action is complete and store state has been</span></div><div class="line">      <span class="comment">// updated.</span></div><div class="line">      <span class="comment">// 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据</span></div><div class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> component.asyncData &amp;&amp; component.asyncData(&#123;</div><div class="line">          store,</div><div class="line">          <span class="attr">route</span>: router.currentRoute</div><div class="line">        &#125;)</div><div class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        isDev &amp;&amp; <span class="built_in">console</span>.log(<span class="string">`data pre-fetch: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - s&#125;</span>ms`</span>)</div><div class="line">        <span class="comment">// After all preFetch hooks are resolved, our store is now</span></div><div class="line">        <span class="comment">// filled with the state needed to render the app.</span></div><div class="line">        <span class="comment">// Expose the state on the render context, and let the request handler</span></div><div class="line">        <span class="comment">// inline the state in the HTML response. This allows the client-side</span></div><div class="line">        <span class="comment">// store to pick-up the server-side state without having to duplicate</span></div><div class="line">        <span class="comment">// the initial data fetching on the client.</span></div><div class="line">        <span class="comment">// 把vuex的state设置到传入的context.initialState上</span></div><div class="line">        context.state = store.state</div><div class="line">        <span class="comment">// 返回state, router已经设置好的Vue实例app</span></div><div class="line">        resolve(app)</div><div class="line">      &#125;).catch(reject)</div><div class="line">    &#125;, reject)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>entry-server.js</code>的主要工作：<br>0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。<br>1.手动路由切换到请求的url，即’/‘<br>2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据<br>3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js）</p>
<blockquote>
<p>Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：<code>服务端渲染时的数据预取流程</code></p>
</blockquote>
<p>还记得<code>index.template.html</code>被设置到<code>template</code>属性中吗？<br>此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就是这里，这个<code>&lt;!--vue-ssr-outlet--&gt;</code>Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。<br>如果改动，服务端渲染时会有错误提示：<code>Error: Content placeholder not found in template.</code></p>
<p>接下来，Vue渲染器会回调callback方法，我们回到<code>server.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">	</div><div class="line">  ···</div><div class="line"></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line"></div><div class="line">    res.end(html)</div><div class="line"></div><div class="line">    ···</div><div class="line"></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时只需要将渲染好的<code>html</code>写入http响应体就结束了，浏览器客户端就可以看到页面了。</p>
<p>接下来我们看看服务端数据预取的实现</p>
<h2 id="服务端渲染时的数据预取流程"><a href="#服务端渲染时的数据预取流程" class="headerlink" title="服务端渲染时的数据预取流程"></a>服务端渲染时的数据预取流程</h2><p>上文提到，服务端渲染时，会手动将路由导航到请求地址即<code>&#39;/&#39;</code>下，然后调用该路由组件的asyncData方法来预取数据</p>
<p>那么我们看看路由配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/router/index.js</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="comment">// route-level code splitting</span></div><div class="line"><span class="keyword">const</span> createListView = <span class="function"><span class="params">id</span> =&gt;</span> () =&gt; System.import(<span class="string">'../views/CreateListView'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.default(id))</div><div class="line"><span class="keyword">const</span> ItemView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/ItemView.vue'</span>)</div><div class="line"><span class="keyword">const</span> UserView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/UserView.vue'</span>)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">    <span class="attr">mode</span>: <span class="string">'history'</span>,</div><div class="line">    <span class="attr">scrollBehavior</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</div><div class="line">    <span class="attr">routes</span>: [</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/top/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'top'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/new/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'new'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/show/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'show'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/ask/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'ask'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/job/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'job'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/item/:id(\\d+)'</span>, <span class="attr">component</span>: ItemView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: UserView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/top'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>地址<code>&#39;/&#39;</code>是做了redirect到<code>&#39;/top&#39;</code>,其实就是默认地址就是到top页面，在看第一条路由配置，<code>&#39;/top&#39;</code>路由对应的组件是<code>createListView(&#39;top&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createListView</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;type&#125;</span>-stories-view`</span>,</div><div class="line"></div><div class="line">    asyncData (&#123; store &#125;) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView asyncData`</span>)</div><div class="line">      <span class="keyword">return</span> store.dispatch(<span class="string">'FETCH_LIST_DATA'</span>, &#123; type &#125;)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">title</span>: camelize(type),</div><div class="line"></div><div class="line">    render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips: <a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">Vuex状态管理</a><br>1.dispatch对应Action，commit对应mutation<br>2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。</p>
</blockquote>
<p><code>Vuex state状态变更流程</code><br><img src="/assets/postImg/vuex_state.jpg" alt="vuex_state"></p>
<p>asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store.</p>
<p>最后数据就都保存在store这里了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/store/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">      <span class="attr">activeType</span>: <span class="literal">null</span>,</div><div class="line">      <span class="attr">itemsPerPage</span>: <span class="number">20</span>,</div><div class="line">      <span class="attr">items</span>: &#123;<span class="comment">/* [id: number]: Item */</span>&#125;,</div><div class="line">      <span class="attr">users</span>: &#123;<span class="comment">/* [id: string]: User */</span>&#125;,</div><div class="line">      <span class="attr">lists</span>: &#123;</div><div class="line">        <span class="attr">top</span>: [<span class="comment">/* number */</span>],</div><div class="line">        <span class="attr">new</span>: [],</div><div class="line">        <span class="attr">show</span>: [],</div><div class="line">        <span class="attr">ask</span>: [],</div><div class="line">        <span class="attr">job</span>: []</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    actions,</div><div class="line">    mutations,</div><div class="line">    getters</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将开始通过<a href="https://cn.vuejs.org/v2/guide/render-function.html#main" target="_blank" rel="external">Render 函数</a>创建HTML。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line">render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// /src/views/ItemList.vue</div><div class="line">···</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-view"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list-nav"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"page &gt; 1"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page - 1)"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"hasMore"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page + 1)"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"transition"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list"</span> <span class="attr">:key</span>=<span class="string">"displayedPage"</span> <span class="attr">v-if</span>=<span class="string">"displayedPage &gt; 0"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">v-for</span>=<span class="string">"item in displayedItems"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">:item</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line">···</div></pre></td></tr></table></figure>
<p>这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的<code>&lt;!--vue-ssr-outlet--&gt;</code>,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。</p>
<blockquote>
<p>Tips:<br>后续更新内容规划：<br>1.生产环境下的服务端渲染逻辑流程<br>2.客户端渲染逻辑流程<br>3.客户端vue组件细节解读</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-hackernews-2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HackerNews&lt;/a&gt;是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/hn-architecture.png&quot; alt=&quot;hn-architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. &lt;/p&gt;
&lt;p&gt;服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。&lt;/p&gt;
&lt;p&gt;客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过&lt;code&gt;app.$mount(&amp;#39;#app&amp;#39;)&lt;/code&gt;挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行&lt;a href=&quot;https://ssr.vuejs.org/en/hydration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hydration&lt;/a&gt;（合并）&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 细节解读</title>
    <link href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/"/>
    <id>https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2017-05-13T12:47:02.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对<a href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/">项目源码解读</a>的细节补充。</p>
<h2 id="package-json解读"><a href="#package-json解读" class="headerlink" title="package.json解读"></a>package.json解读</h2><p>该文件提供了四种命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install dependencies</span></div><div class="line">npm install <span class="comment"># or yarn</span></div><div class="line"></div><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line">npm run dev</div><div class="line"></div><div class="line"><span class="comment"># build for production</span></div><div class="line">npm run build</div><div class="line"></div><div class="line"><span class="comment"># serve in production mode</span></div><div class="line">npm start</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>执行<code>npm install</code><br>查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。</p>
<blockquote>
<p>Tips:dependencies与devDependencies的区别<br>devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。<br>dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。<br>这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？<br>答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。</p>
</blockquote>
<p>执行<code>npm run dev</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line"><span class="string">"dev"</span>: <span class="string">"node server"</span>,</div><div class="line"><span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node server"</span>,</div><div class="line"><span class="string">"build"</span>: <span class="string">"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server"</span>,</div><div class="line"><span class="string">"build:client"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules"</span>,</div><div class="line"><span class="string">"build:server"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<p>执行<code>npm run build</code><br>同样，找到build属性，并执行：<code>rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server</code>，即删除dist目录并执行<code>npm run build:client</code>和<code>npm run build:server</code><br>对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件</p>
<p>执行<code>npm start</code><br>同样，找到start属性，并执行：<code>cross-env NODE_ENV=production node server</code>，即通过cross-env模块设置NODE_ENV环境变量为production，并执行<code>node server</code></p>
<blockquote>
<p>Tips:为什么是<code>npm start</code>而不是<code>npm run start</code>?<br>1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见<code>npm --help</code><br>2.其他三个命令都不是内置命令，需要经由<code>npm run</code>去执行。</p>
</blockquote>
<h2 id="index-template-html解读"><a href="#index-template-html解读" class="headerlink" title="index.template.html解读"></a>index.template.html解读</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">sizes</span>=<span class="string">"48x48"</span> <span class="attr">href</span>=<span class="string">"/public/logo-48.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#f60"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这段html代码功能：移动端浏览器适配及PWA适配</p>
<blockquote>
<p>Tips:<a href="https://developer.mozilla.org/en-US/Apps/Progressive" target="_blank" rel="external">PWA (progressive web apps)</a>-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。</p>
</blockquote>
<p>接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。<br>浏览器体验：<br>在Chrome浏览器地址栏中输入项目地址，效果如下：</p>
<p><img src="/assets/postImg/open_by_chrome.png" alt="open_by_chrome"></p>
<p>PWA体验：<br>通过Chrome的<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="external">Add to Homescreen</a>功能，将该站点添加到桌面。效果如下：</p>
<p><img src="/assets/postImg/chrome_menu.png" alt="chrome_menu">  <img src="/assets/postImg/chrome_menu_add_to_homescrren.png" alt="chrome_menu_add_to_homescrren">  <img src="/assets/postImg/chrome_add_to_homescrren_pwa.png" alt="chrome_add_to_homescrren_pwa">  </p>
<p>点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。</p>
<p><img src="/assets/postImg/pwa_flash_white.png" alt="pwa_flash_white">  <img src="/assets/postImg/pwa_homepage.png" alt="pwa_homepage"></p>
<p>现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 主题色：绿色 启动图背景色：白色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f2f3f5"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//2. 主题色：绿色 启动图背景色：绿色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#48BB74"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//3. 主题色：橙色 启动图背景色：橙色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f60"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#f60"</span></div></pre></td></tr></table></figure></p>
<p><img src="/assets/postImg/pwa_flash.png" alt="pwa_flash">  <img src="/assets/postImg/pwa_flash_green.png" alt="pwa_flash_green">  <img src="/assets/postImg/pwa_flash_orange.png" alt="pwa_flash_orange"></p>
<blockquote>
<p>Tips:<br>这里用到的<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="external">manifest.json</a>不要与作为离线缓存的<a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">manifest</a>混淆。</p>
</blockquote>
<p>最后来对比感受下<code>非PWA的百度站点</code>Vs<code>PWA站点的hackernews</code>在Add to HomeScreen后，体验上的差异。</p>
<p><img src="/assets/postImg/pwa.gif" alt="pwa.gif"></p>
<p>概括下主要的差异：<br>1.增加了同原生应用一样的启动图过渡界面<br>2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。<br>3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。<br>注：PWA更多的特性这里并未应用，其实PWA可以做的更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对&lt;a href=&quot;https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/&quot;&gt;项目源码解读&lt;/a&gt;的细节补充。&lt;/p&gt;
&lt;h2 id=&quot;package-json解读&quot;&gt;&lt;a href=&quot;#package-json解读&quot; class=&quot;headerlink&quot; title=&quot;package.json解读&quot;&gt;&lt;/a&gt;package.json解读&lt;/h2&gt;&lt;p&gt;该文件提供了四种命令&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# install dependencies&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install &lt;span class=&quot;comment&quot;&gt;# or yarn&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in dev mode, with hot reload at localhost:8080&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build for production&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run build&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in production mode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
</feed>
