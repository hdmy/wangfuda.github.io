<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>osan&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangfuda.github.io/"/>
  <updated>2017-07-08T03:12:42.272Z</updated>
  <id>https://wangfuda.github.io/</id>
  
  <author>
    <name>osan</name>
    <email>o.san@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义View星空动画的内存占用/GPU渲染性能优化手记</title>
    <link href="https://wangfuda.github.io/2017/07/09/nebula_gpu_monitor_optimize/"/>
    <id>https://wangfuda.github.io/2017/07/09/nebula_gpu_monitor_optimize/</id>
    <published>2017-07-09T00:55:00.000Z</published>
    <updated>2017-07-08T03:12:42.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这是一个关于星空的自定义动画Sample,源码请戳 <a href="https://github.com/wangfuda/nebula" target="_blank" rel="external">https://github.com/wangfuda/nebula</a></p>
</blockquote>
<p>Gif图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-5ec7709da5e2649b.gif?imageMogr2/auto-orient/strip" alt="nebula.gif"><br>本文将重点讲解在本例自定义动画编程中，如何结合 Android Studio 的 Memory Monitor，GPU monitor 按步骤做内存优化，GPU渲染优化。<br>关于动画实现部分，源码已提交至github，请手动阅读理解，注释很详尽。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a9676a7b3d0cfa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<h2 id="内存占用优化"><a href="#内存占用优化" class="headerlink" title="内存占用优化"></a>内存占用优化</h2><h5 id="内存占用优化-步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi"><a href="#内存占用优化-步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi" class="headerlink" title="内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi."></a>内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi.</h5><p>先来彪一张直接撸完代码无任何优化的情况下，内存的占用图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-2d0ed671b2b54ec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_1_img_hdpi.png"><br>内存占用246M，不能忍。<br>问：为什么这么大？<br>答：因为资源图都是高清1K分辨率的图。<br>问：为什么这么大？<br>答：。。。<br>那么我们算一下这246M内存占用是怎么来的吧。<br>先来一条图片内存占用计算公式，公式溯源请自行去看源码：BitmapFactory.Java &amp; BitmapFactory.cpp<br>scaledWidth = int( Width <em> targetDensity / density + 0.5)<br>scaledHeight = int( Height </em> targetDensity / density + 0.5)<br>memory = scaledWidth <em> scaledHeight </em> 4<br>其中参数定义如下：</p>
<blockquote>
<p>Width：图片宽<br>Height：图片高<br>targetDensity：加载图片的目标手机的 density，这个值的来源是 DisplayMetrics 的 densityDpi，如果是小米note那么这个数值就是480，详见下图关于targetDensity的参数细节。<br>density：decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 hdpi 是240，xxhdpi 是480）<br>每像素字节数：ARGB8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-11211320242fa8ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="targetDensity.png"></p>
<p>对于一张1080x1920的图来说，放置在hdpi目录，并在小米note手机上（分辨率1080x1920,targetDensity为480），而且均默认以ARGB8888格式加载。<br>内存占用计算公式：<br>scaledWidth = int( 1080<em> 480/ 240+ 0.5) =2160<br>scaledHeight = int( 1920</em> 480/ 240+ 0.5)=3840<br>memory = scaledWidth <em> scaledHeight </em> 4=2160<em>3840</em>4 = 33177600 = 33.17M</p>
<p>一张背景图就占用33M,这个分辨率的图，我们res下一共有7张，还有其他几张小图。这回可以回答为什么占用245M的内存了。</p>
<p>那么内存占用的优化方案也就有了，我们尽量把图片资源放到大分辨率目录下，比如xxxhdpi（当然还有个前提，你的图片分辨率也确实符合大分辨率，否则会出现在大分辨率设备上，显示不全的问题）。</p>
<p>我们来看看把图片资源移动到xxxhdpi目录下后，内存占用情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-104cb4bcc3c4c393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_2_img_move_to_xxxhdpi.png"></p>
<p>把图片资源从hdpi移动到xxx-hdpi，从246M降低到56M,减少了190M，Bingo!</p>
<h5 id="内存占用优化-步骤-二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）"><a href="#内存占用优化-步骤-二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）" class="headerlink" title="内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）"></a>内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）</h5><p>初始单张图片大小都接近2M，经过<a href="https://tinypng.com/" target="_blank" rel="external">tinypng</a>优化后，压缩率达到70-80%，非常完美，包体大小减小了，不过，经过我们步骤一的科学计算，这个优化并不会影响图片在内存中的占用。</p>
<h5 id="内存占用优化-步骤-三：动画完成且不再循环展示的部分，相关bitmap释放"><a href="#内存占用优化-步骤-三：动画完成且不再循环展示的部分，相关bitmap释放" class="headerlink" title="内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放"></a>内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> releaseBitmap &#123;</div><div class="line">  ...</div><div class="line">  bitmap.recycle();</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看下bitmap释放后的memory monitor图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-6b1449a14902af41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_3_release_bitmap.png"></p>
<p>内存占用降低到36M,减少了20M</p>
<h5 id="内存占用优化-步骤-四：无用对象释放，非透明背景图片采用RGB-565颜色格式，并且将图片的inSampleSize设置为2"><a href="#内存占用优化-步骤-四：无用对象释放，非透明背景图片采用RGB-565颜色格式，并且将图片的inSampleSize设置为2" class="headerlink" title="内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2"></a>内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> releaseValueAnimator &#123;</div><div class="line">  ...</div><div class="line">  valueAnimator = <span class="keyword">null</span>;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> initBitmap &#123;</div><div class="line">  ...</div><div class="line">  localOptions.inSampleSize = <span class="number">2</span>;</div><div class="line">  localOptions.inPreferredConfig = Bitmap.Config.RGB_565;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看下变更图片颜色格式及采样率后的memory monitor图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-cd79479d9c5a1ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_5_bitmap_RGB_565_inSampleSize2.png"></p>
<p>内存占用降低到28M,减少了8M（后来monitor截图只对背景图片做inPreferredConfig调整，内存占用变为30M,相比全部设置为2，增加了2M）</p>
<p>##GPU渲染优化<br>接下来我们要专注于GPU渲染优化了。通过前面几张图，也能看到GPU monitor的状态，非常不乐观，完全达不到帧率刷新的要求：即每帧渲染不超过16ms，每秒可以渲染60帧。<br>先看GPU Monitor的各项指标含义：<br><img src="http://upload-images.jianshu.io/upload_images/1889129-2745cf0df2e05417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gpu_monitor.png"></p>
<blockquote>
<p>Misc Time：表示在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况；出现该线条的时候，可以在Log中看到这样的日志： Skipped xxx frames! The application may be doing too much work on its main thread</p>
<p>Swap Buffers：表示处理任务的时间，也可以说是CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多；</p>
<p>Command Issue：表示执行任务的时间，这部分主要是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，红色线条越高表示需要绘制的视图更多；</p>
<p>Sync：表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小；</p>
<p>Draw：表示测量和绘制视图列表所需要的时间，蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作；</p>
<p>Measure/Layout：表示布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题；</p>
<p>Animation：表示计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等；</p>
<p>Input Handling：表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作；<br>Vsync Delay：见Misc Time</p>
</blockquote>
<h5 id="GPU渲染优化-步骤一：优化内存占用"><a href="#GPU渲染优化-步骤一：优化内存占用" class="headerlink" title="GPU渲染优化 步骤一：优化内存占用"></a>GPU渲染优化 步骤一：优化内存占用</h5><p>可以回过头去看看内存优化过程演进中的Monitor图，随着内存占用的降低，GPU渲染的性能改善也是随之渐进的，所以GPU渲染性能优化，首选就是内存优化</p>
<h5 id="GPU渲染优化-步骤二：能在初始化中做的事，坚决不在onDraw中搞。"><a href="#GPU渲染优化-步骤二：能在初始化中做的事，坚决不在onDraw中搞。" class="headerlink" title="GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。"></a>GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。</h5><p>在sample代码中重构了onDraw中的画笔的属性设置，绘制区域的创建等代码，这些代码都重构到初始化中。而在onDraw中仅做参数值的动态调整。</p>
<blockquote>
<p>Tips.本例Sample最初始未经过任何优化的代码及最终优化版本代码均在github上可以查看到commit记录，这里不再写详细代码对比，请移动github阅读源码。</p>
</blockquote>
<p>我们看下重构前后的对比图<code>monitor_5_bitmap_RGB_565_inSampleSize2.png</code> Vs <code>monitor_6_gpu_optimize_object_and_paint_create.png</code>，对比发现，GPU渲染耗时明显降低。</p>
<blockquote>
<p>我们暂时先对比看GPU Monitor的 0s ~ 9s 部分的性能改善，目前GPU优化主要在这里体现，因为后半部分各位爷看到了，GPU渲染耗时飙升，掉帧严重，那部分的优化在后续步骤会提到。</p>
</blockquote>
<p>重构前 GPU Monitor：<br><img src="http://upload-images.jianshu.io/upload_images/1889129-e5d6a57904065bb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_5_bitmap_RGB_565_inSampleSize2.png"></p>
<p>重构后 GPU Monitor：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-49cbc9134eafa5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_6_gpu_optimize_object_and_paint_create.png"></p>
<h5 id="GPU渲染优化-步骤三：能用硬件加速，就别关闭它。"><a href="#GPU渲染优化-步骤三：能用硬件加速，就别关闭它。" class="headerlink" title="GPU渲染优化 步骤三：能用硬件加速，就别关闭它。"></a>GPU渲染优化 步骤三：能用硬件加速，就别关闭它。</h5><p>我们都看到了，在GPU Monitor中显示，9s后的GPU渲染，每帧耗时突然飙升，每帧渲染都是超60ms，<br>Draw上升至172ms，Vsync上升至148ms.<br>而且在logcat中也看到日志：<br><code>07-09 11:17:57.135 15980-15980/com.osan.nebula I/Choreographer: Skipped 31 frames!  The application may be doing too much work on its main thread.</code><br>每帧超时，掉帧严重。到底是什么原因呢？经过反复的排查，终于找到原因，我们来聊聊这个飙升的来龙去脉。<br>由于在后半部分的动画中，绘制小星星的光晕效果时，使用的画笔设置了模糊属性，为了给小星星加个光晕效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paintCircleStar.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">10</span>, BlurMaskFilter.Blur.SOLID));</div></pre></td></tr></table></figure></p>
<p>然后google官方文档都说了，硬件加速不支持的UI特效API之一就有它。也就是你要用硬件加速，这个模糊效果就失效。所以我一门心思的为了给小星星加光晕… 光晕…晕…，最后我选择了关闭硬件加速<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawState7</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    canvas.save();</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);<span class="comment">//关闭硬件加速</span></div><div class="line">    canvas.translate(halfWidth, halfHeight);</div><div class="line">    canvas.scale(scale, scale);</div><div class="line">    canvas.rotate(<span class="number">30f</span> * mValue7);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>呵呵，为了小星星，闯祸了。因为本例动画中，各种对画布的旋转，缩放，变换，透明度动态变化，在非硬件加速情况下，不停的重新绘制，是GPU渲染耗时飙升的唯一原因。<br>我们来看看开启硬件加速的情况下，GPU Monitor的指标监控：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a3a8a337954cdd56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_7_gpu_optimize_with_hardware_acce.png"></p>
<p>恢复硬件加速后，渲染耗时立刻恢复到绿线以下，即每帧渲染不超过16ms，达到渲染标准。而且，CPU消耗也明显下降。<br>那么为什么硬件加速有如此神奇之功效？<br>使用硬件加速在对一些view的属性改变上有更高的效率，因为不需要view的invalidate和redrawn。而我们动画中正式大量使用了对属性的改变。属性如:</p>
<blockquote>
<p>透明度：alpha<br>移动：x, y, translationX, translationY<br>缩放：scaleX, scaleY<br>旋转：rotation, rotationX, rotationY<br>坐标：pivotX, pivotY</p>
</blockquote>
<p>注：<br>1）使用硬件加速，对于渲染性能的提示是显著的，API&gt;14后，硬件加速是默认开启的。<br>2）硬件加速还不支持所有的2D绘图命令，开启后可能会影响自定义View和绘图操作。</p>
<h5 id="GPU渲染优化-步骤四：优化算数运算，并尽量从ondraw中移除算数运算"><a href="#GPU渲染优化-步骤四：优化算数运算，并尽量从ondraw中移除算数运算" class="headerlink" title="GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算"></a>GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算</h5><p>涉及计算任务，能不在ondraw中执行的，就坚决移走，即使只是一个a*b或a/b.<br>因为我们继续重构了onDraw方法，将可能优化的运算代码均做了优化，能放到初始化做的就移到初始化，能提炼共用的运算公式就共用，能不重复算的就绝对不算第二遍。<br>我们来看看优化算数运算后，GPU Monitor的指标监控：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-8f42751a65979c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_8_gpu_optimize_precalc.png"></p>
<p>相比步骤三中的GPU Monitor指标有了进一步降低，虽然降低幅度很小，但是还是对GPU渲染性能提升有效果的，而且观察发现，优化后，CPU和GPU的指标看起来更平稳。</p>
<p>最后附上nebula自定义动画的截图<br><img src="http://upload-images.jianshu.io/upload_images/1889129-d7befea486ac77fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/1889129-27590756c3aef735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a9676a7b3d0cfa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-be5b80a9b8fc343e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-1f4af7330ca64d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一个关于星空的自定义动画Sample,源码请戳 &lt;a href=&quot;https://github.com/wangfuda/nebula&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wan
    
    </summary>
    
    
      <category term="自定义View" scheme="https://wangfuda.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="自定义动画" scheme="https://wangfuda.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB/"/>
    
      <category term="GPU Monior" scheme="https://wangfuda.github.io/tags/GPU-Monior/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2.3.0 源码解析</title>
    <link href="https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/</id>
    <published>2017-07-01T07:24:47.838Z</published>
    <updated>2017-07-01T08:57:42.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> A type-safe HTTP client for Android and Java</p>
</blockquote>
<p>Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。</p>
<p>基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/retrofit/architecture.png" alt="architecture"></p>
<a id="more"></a>
<p>项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall<br>这里我们把基于Retrofit的HTTP通信比做是邮递信件。</p>
<blockquote>
<p>邮递信件</p>
</blockquote>
<ul>
<li>信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。</li>
<li>邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。</li>
<li>邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理</li>
<li>邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。</li>
</ul>
<blockquote>
<p>基于Retrofit的HTTP通信</p>
</blockquote>
<ul>
<li>Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。</li>
<li>Proxy：然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等</li>
<li>Invocation：这里负责调度同步或异步请求，请求装配和响应解析</li>
<li>RawCall：这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。</li>
</ul>
<p>来看看寄信和Retrofit之间的对比：<br><img src="/assets/postImg/retrofit/arch_flow.png" alt="arch_flow"></p>
<p>大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。</p>
<!--more-->
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><p><a href="http://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">官方 Javadoc</a><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">BuiltInConverters.java</span>					<span class="comment"># 内建Converter</span></div><div class="line"><span class="string">│</span>  <span class="string">Call.java</span>							<span class="comment"># 发送请求接收响应的retrofit方法调用</span></div><div class="line"><span class="string">│</span>  <span class="string">CallAdapter.java</span>						<span class="comment"># 适配Call的响应类型，将默认响应类型R转换为类型T</span></div><div class="line"><span class="string">│</span>  <span class="string">Callback.java</span>						<span class="comment"># 返回服务端或离线请求的响应体</span></div><div class="line"><span class="string">│</span>  <span class="string">Converter.java</span>						<span class="comment"># HTTP交互中，转换对象为数据 或 从数据转换为对象</span></div><div class="line"><span class="string">│</span>  <span class="string">DefaultCallAdapterFactory.java</span>				<span class="comment"># 默认CallAdapter工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">ExecutorCallAdapterFactory.java</span>				<span class="comment"># http请求执行器工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">HttpException.java</span>						<span class="comment"># 非2xx HTTP响应的异常处理</span></div><div class="line"><span class="string">│</span>  <span class="string">OkHttpCall.java</span>						<span class="comment"># 真正调用OkHttp3发送Http请求的类</span></div><div class="line"><span class="string">│</span>  <span class="string">package-info.java</span>						<span class="comment"># 包描述</span></div><div class="line"><span class="string">│</span>  <span class="string">ParameterHandler.java</span>					<span class="comment"># 参数注解解析器</span></div><div class="line"><span class="string">│</span>  <span class="string">Platform.java</span>						<span class="comment"># 平台适配(Java/Android)</span></div><div class="line"><span class="string">│</span>  <span class="string">RequestBuilder.java</span>						<span class="comment"># 请求拼装</span></div><div class="line"><span class="string">│</span>  <span class="string">Response.java</span>						<span class="comment"># 原汁原味的HTTP 响应体，所谓 T body</span></div><div class="line"><span class="string">│</span>  <span class="string">Retrofit.java</span>						<span class="comment"># 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口</span></div><div class="line"><span class="string">│</span>  <span class="string">ServiceMethod.java</span>						<span class="comment"># 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请</span></div><div class="line">								<span class="comment"># 求头、是否是multipart等等),并返回用于发起http请求的Call对象</span></div><div class="line"><span class="string">│</span>  <span class="string">Utils.java</span>							<span class="comment"># 工具类</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">└─http</span>								<span class="comment"># http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解）</span></div><div class="line"></div><div class="line">        <span class="string">Body.java</span>						<span class="comment"># control the request body of a POST/PUT request</span></div><div class="line">        <span class="string">DELETE.java</span>						<span class="comment"># Make a DELETE request</span></div><div class="line">        <span class="string">Field.java</span>						<span class="comment"># Named pair for a form-encoded request</span></div><div class="line">        <span class="string">FieldMap.java</span>						<span class="comment"># Named key/value pairs for a form-encoded request</span></div><div class="line">        <span class="string">FormUrlEncoded.java</span>					<span class="comment"># Denotes that the request body will use form URL encoding</span></div><div class="line">        <span class="string">GET.java</span>						<span class="comment"># Make a GET request</span></div><div class="line">        <span class="string">HEAD.java</span>						<span class="comment"># Make a HEAD request</span></div><div class="line">        <span class="string">Header.java</span>						<span class="comment"># Replaces the header with the value of its target</span></div><div class="line">        <span class="string">HeaderMap.java</span>						<span class="comment"># Adds headers specified in the Map</span></div><div class="line">        <span class="string">Headers.java</span>						<span class="comment"># Adds headers literally supplied in the value</span></div><div class="line">        <span class="string">HTTP.java</span>						<span class="comment"># Use a custom HTTP verb for a request</span></div><div class="line">        <span class="string">Multipart.java</span>						<span class="comment"># Denotes that the request body is multi-part</span></div><div class="line">        <span class="string">OPTIONS.java</span>						<span class="comment"># Make an OPTIONS request</span></div><div class="line">        <span class="string">package-info.java</span>					<span class="comment"># Package description</span></div><div class="line">        <span class="string">Part.java</span>						<span class="comment"># Denotes a single part of a multi-part request</span></div><div class="line">        <span class="string">PartMap.java</span>						<span class="comment"># Denotes name and value parts of a multi-part request</span></div><div class="line">        <span class="string">PATCH.java</span>						<span class="comment"># Make a PATCH request</span></div><div class="line">        <span class="string">Path.java</span>						<span class="comment"># Named replacement in a URL path segment</span></div><div class="line">        <span class="string">POST.java</span>						<span class="comment"># Make a POST request</span></div><div class="line">        <span class="string">PUT.java</span>						<span class="comment"># Make a PUT request</span></div><div class="line">        <span class="string">Query.java</span>						<span class="comment"># Query parameter appended to the URL</span></div><div class="line">        <span class="string">QueryMap.java</span>						<span class="comment"># Query parameter keys and values appended to the URL</span></div><div class="line">        <span class="string">QueryName.java</span>						<span class="comment"># Query parameter appended to the URL that has no value</span></div><div class="line">        <span class="string">Streaming.java</span>						<span class="comment"># Treat the response body on methods returning Response as is, i.e. </span></div><div class="line">								<span class="comment"># without converting body() to byte[]</span></div><div class="line">        <span class="string">Url.java</span>						<span class="comment"># URL resolved against the base URL</span></div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的基本用法"><a href="#Retrofit的基本用法" class="headerlink" title="Retrofit的基本用法"></a>Retrofit的基本用法</h2><p>让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。</p>
<p>用 Java 接口的方式定义一个HTTP API.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Retrofit 类生成一个 GitHubService 接口的实现实例.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>
<p>Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.<br>GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure></p>
<p>执行同步或异步HTTP请求，得到HTTP响应数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的源码解析"><a href="#Retrofit的源码解析" class="headerlink" title="Retrofit的源码解析"></a>Retrofit的源码解析</h2><p>首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器</p>
<p>Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。</p>
<p>下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall.</p>
<blockquote>
<p>Flow - Builder</p>
</blockquote>
<p><code>Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
    ...
    .build();</code><br><a href="https://en.wikipedia.org/wiki/Builder_pattern" target="_blank" rel="external">Tips.设计模式之Builder模式</a></p>
<p>基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java -&gt; class Builder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      </div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">          callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。<br>注：<code>validateEagerly</code>，用于指定是否预先解析注解，加速接口访问效率。</p>
<blockquote>
<p>Flow - Proxy</p>
</blockquote>
<p><code>GitHubService service = retrofit.create(GitHubService.class);</code><br>我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。<br>为什么用动态代理？<br>这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。</p>
<blockquote>
<p>Tips.<a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="external">动态代理</a></p>
</blockquote>
<p><code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code><br>通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。</p>
<p>invoke中主要由ServiceMethod和CallAdapter完成了三件事：</p>
<ul>
<li>请求方法的注解解析</li>
<li>创建OkHttpCall实例，为后续流程中的HTTP请求执行做准备，详见 Flow - Invocation.</li>
<li>适配Call的响应类型，将默认响应类型R转换为类型T</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p>ServiceMethod.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      callAdapter = createCallAdapter();</div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">      </div><div class="line">	  ...</div><div class="line"></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">        Type parameterType = parameterTypes[p];</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>获取callAdapter、responseType、responseConverter接口对象</p>
<p>解析Method的注解</p>
<p>解析Method的参数注解</p>
<p>解析Method的参数中使用了依赖请求API的动态参数的注解，交由ParameterHandler处理</p>
<p>CallAdapter.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>适配Call的响应类型，将默认响应类型R转换为类型T.比如官方的RxJavaCallAdapter可以结合Rxjava特性对Call的响应做RxJava观察者模式转换，进一步解放生产力。</p>
<p>注：未在Builder阶段指定CallAdapter(如 RxJavaCallAdapterFactory )的情况下，默认的 CallAdapter 不对Call做任何处理。<br>见 DefaultCallAdapterFactory:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CallAdapter.Factory INSTANCE = <span class="keyword">new</span> DefaultCallAdapterFactory();</div><div class="line"></div><div class="line">  ...</div><div class="line">	  ...</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> call;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Flow - Invocation</p>
</blockquote>
<p><code>Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</code></p>
<p>这一步开始基于同步的方式执行HTTP请求，并得到返回的HTTP响应数据.</p>
<p>本质上是执行了 OkHttpCall 的 execute方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">     </div><div class="line">     ...</div><div class="line">        ...</div><div class="line">          call = rawCall = createRawCall();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parseResponse(call.execute());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，这里创建了RawCall，即真正的去执行HTTP请求任务的对象。<br>这里还负责HTTP请求的响应数据解析。<br>我们看下<code>createRawCall()</code>干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = serviceMethod.toRequest(args);</div><div class="line">    okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> call;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>serviceMethod.toRequest()的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="comment">/** Builds an HTTP request from method arguments. */</span></div><div class="line">  <span class="function">Request <span class="title">toRequest</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,</div><div class="line">        contentType, hasBody, isFormEncoded, isMultipart);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> requestBuilder.build();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>toRequest 方法通过 RequestBuilder 创建了 okhttp3 做 HTTP 请求时需要的 Request 对象。</p>
<p>serviceMethod.callFactory.newCall(request)的功能：<br>建立一个请求通道，为执行HTTP请求做准备。<br>这里callFactory可以由使用者指定，默认为 OkHttpClient，见：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>回头看下 OkHttpCall 中 execute 方法最后一句: <code>return parseResponse(call.execute());</code><br>这里调用真正的HTTP请求客户端的请求执行方法。也就是来到了接下来的一个流程。</p>
<blockquote>
<p>Flow - RawCall</p>
</blockquote>
<p>上个 Flow 中最后一步， <code>call.execute()</code>,开启了真正的HTTP请求，即通过 okhttp3 完成HTTP请求。<br>这个部分没什么代码可讲，属于面向接口开发的典范，要讲就该去讲 Okhttp 框架的源码了。</p>
<p>这个部分引出了 Retrofit 的开源拥有者-Square 公司的另一个优秀的开源项目 Okhttp,是不是也很想一探究竟？</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>最后我想拿 Retrofit 官方的一段话来结束：</p>
<p>Contributing</p>
<p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
<p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running mvn clean verify.</p>
<p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>
<p>纳尼？</p>
<p>Cos 我想把亲手画的两副图贡献给 Retrofit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit&lt;/a&gt; A type-safe HTTP client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。&lt;/p&gt;
&lt;p&gt;基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/retrofit/architecture.png&quot; alt=&quot;architecture&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Retrofit" scheme="https://wangfuda.github.io/tags/Retrofit/"/>
    
      <category term="okhttp" scheme="https://wangfuda.github.io/tags/okhttp/"/>
    
      <category term="http" scheme="https://wangfuda.github.io/tags/http/"/>
    
      <category term="restful api" scheme="https://wangfuda.github.io/tags/restful-api/"/>
    
  </entry>
  
  <entry>
    <title>todo-mvp-dagger 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-07-01T08:53:39.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>The Android Architecture Blueprints project demonstrates strategies to help solve or avoid these common problems. This project implements the same app using different architectural concepts and tools.</p>
</blockquote>
<p>敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/googlesamples/android-archite
    
    </summary>
    
    
      <category term="mvp" scheme="https://wangfuda.github.io/tags/mvp/"/>
    
      <category term="dagger" scheme="https://wangfuda.github.io/tags/dagger/"/>
    
      <category term="android architecture" scheme="https://wangfuda.github.io/tags/android-architecture/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-05-14T09:48:44.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="external">HackerNews</a>是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。</p>
</blockquote>
<p>vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/hn-architecture.png" alt="hn-architecture"></p>
<p>项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. </p>
<p>服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。</p>
<p>客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过<code>app.$mount(&#39;#app&#39;)</code>挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行<a href="https://ssr.vuejs.org/en/hydration.html" target="_blank" rel="external">Hydration</a>（合并）</p>
<a id="more"></a>
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">manifest.json</span>				<span class="comment"># progressive web apps配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">package.json</span>					<span class="comment"># 项目配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">server.js</span>					<span class="comment"># 服务端渲染</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">├─public</span>                                    	<span class="comment"># 静态资源</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-120.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-144.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-152.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-192.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-384.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-48.png</span></div><div class="line"><span class="string">│</span>      </div><div class="line"><span class="string">└─src</span></div><div class="line">    <span class="string">│</span>  <span class="string">app.js</span>					<span class="comment"># 整合 router,filters,vuex 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">App.vue</span>					<span class="comment"># 根 vue 组件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-client.js</span>				<span class="comment"># client 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-server.js</span>				<span class="comment"># server 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">index.template.html</span>			<span class="comment"># html 模板</span></div><div class="line">    <span class="string">│</span>  </div><div class="line">    <span class="string">├─api</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-client.js</span>			<span class="comment"># Client数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-server.js</span>			<span class="comment"># server数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 数据请求API</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─components</span></div><div class="line">    <span class="string">│</span>      <span class="string">Comment.vue</span>				<span class="comment"># 评论组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Item.vue</span>				<span class="comment"># </span></div><div class="line">    <span class="string">│</span>      <span class="string">ProgressBar.vue</span>			<span class="comment"># 进度条组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Spinner.vue</span>				<span class="comment"># 加载提示组件</span></div><div class="line">    <span class="string">│</span>     </div><div class="line">    <span class="string">├─router</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># router配置</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─store</span>					<span class="comment"># Vue store模块</span></div><div class="line">    <span class="string">│</span>      <span class="string">actions.js</span>				<span class="comment"># 根级别的 action</span></div><div class="line">    <span class="string">│</span>      <span class="string">getters.js</span>				<span class="comment"># 属性接口</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 我们组装模块并导出 store 的地方</span></div><div class="line">    <span class="string">│</span>      <span class="string">mutations.js</span>				<span class="comment"># 根级别的 mutation</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─util</span></div><div class="line">    <span class="string">│</span>      <span class="string">filters.js</span>				<span class="comment"># 过滤器</span></div><div class="line">    <span class="string">│</span>      <span class="string">title.js</span>				<span class="comment"># 工具类</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">└─views</span></div><div class="line">            <span class="string">CreateListView.js</span>			<span class="comment"># 动态生成列表界面的工厂方法</span></div><div class="line">            <span class="string">ItemList.vue</span>			<span class="comment"># List界面组件</span></div><div class="line">            <span class="string">ItemView.vue</span>			<span class="comment"># 单List项组件</span></div><div class="line">            <span class="string">UserView.vue</span>			<span class="comment"># 用户界面组件</span></div></pre></td></tr></table></figure>
<p>本项目包含开发环境及生产环境，我们先学习开发环境。</p>
<h2 id="开发环境的服务端渲染流程"><a href="#开发环境的服务端渲染流程" class="headerlink" title="开发环境的服务端渲染流程"></a>开发环境的服务端渲染流程</h2><p>让我们从node环境下执行命令开始。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line"><span class="string">$npm</span> <span class="string">run</span> <span class="string">dev</span></div></pre></td></tr></table></figure></p>
<p>然后发生了什么？我们来看一张图。<br><img src="/assets/postImg/rundev.png" alt="rundev"></p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">package.json解读</a></p>
</blockquote>
<p>上述执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"><span class="comment">// 服务端渲染的HTML模板</span></div><div class="line"><span class="keyword">const</span> template = fs.readFileSync(resolve(<span class="string">'./src/index.template.html'</span>), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">  <span class="comment">// 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中</span></div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line"></div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> renderer</div><div class="line"><span class="keyword">let</span> readyPromise</div><div class="line"><span class="keyword">if</span> (isProd) &#123;</div><div class="line">  <span class="comment">// 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle</span></div><div class="line">  <span class="keyword">const</span> bundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</div><div class="line">  <span class="comment">//client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能</span></div><div class="line">  <span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</div><div class="line">  <span class="comment">//vue-server-renderer创建bundle渲染器并绑定server bundle</span></div><div class="line">  renderer = createRenderer(bundle, &#123;</div><div class="line">    clientManifest</div><div class="line">  &#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回</span></div><div class="line">  <span class="comment">// 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新</span></div><div class="line">  <span class="comment">//以及通过webpack的watch功能实现服务端代码的热更新</span></div><div class="line">  readyPromise = <span class="built_in">require</span>(<span class="string">'./build/setup-dev-server'</span>)(app, (bundle, options) =&gt; &#123;</div><div class="line">	<span class="comment">// 基于热更新，回调生成最新的bundle渲染器</span></div><div class="line">    renderer = createRenderer(bundle, options)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//依次装载一系列Express中间件，用来处理静态资源，数据压缩等</span></div><div class="line">···</div><div class="line">app.use(···)</div><div class="line">···</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  ···</div><div class="line"> </div><div class="line">  <span class="comment">// 设置请求的url</span></div><div class="line">  <span class="keyword">const</span> context = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'Vue HN 2.0'</span>, <span class="comment">// default title</span></div><div class="line">    url: req.url</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 为渲染器绑定的server bundle（即entry-server.js）设置入参context</span></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    ···</div><div class="line">    res.end(html)</div><div class="line">	···</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//启动一个服务并监听从 8080 端口进入的所有连接请求。</span></div><div class="line">app.get(<span class="string">'*'</span>, isProd ? render : <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">  readyPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> render(req, res))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">8080</span></div><div class="line">app.listen(port, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`server started at localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips<br>1.<a href="https://ssr.vuejs.org" target="_blank" rel="external">vue-server-renderer</a>(Vue服务端渲染，同时支持prefetch、prerender特性)<br>2.<a href="https://webpack.js.org/guides/development/#webpack-dev-server" target="_blank" rel="external">webpack-dev-server</a>(webpack-dev-middleware/webpack-hot-middleware)<br>3.此项目全面使用<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6语法</a>，包括箭头函数，解构赋值，Promise等特性。</p>
</blockquote>
<p><code>server.js</code>最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080<br>请求经由<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">express</a>路由接收后，执行处理逻辑:<code>readyPromise.then(() =&gt; render(req, res))</code><br>沿着Promise的调用链处理：<br>开发环境下<br>1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。<br>最终通过回调把生成在内存中的server bundle传回。<br>2.创建渲染器，绑定server bundle，设置渲染模板，缓存等<br>3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等<br>4.最后将渲染好的HTML写入http响应体，传回浏览器。</p>
<p>接下来分解解读下这几个的实现。</p>
<h3 id="setup-dev-server"><a href="#setup-dev-server" class="headerlink" title="setup-dev-server"></a>setup-dev-server</h3><p>看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色）<br><img src="/assets/postImg/serverjs.png" alt="serverjs"></p>
<p><code>build/setup-dev-server.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setup-dev-server.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'./webpack.client.config'</span>)</div><div class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'./webpack.server.config'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">setupDevServer</span> (<span class="params">app, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> bundle, clientManifest</div><div class="line">  <span class="keyword">let</span> resolve</div><div class="line">  <span class="keyword">const</span> readyPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123; resolve = r &#125;)</div><div class="line">  <span class="keyword">const</span> ready = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    resolve()</div><div class="line">    cb(...args)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem</span></div><div class="line">  <span class="comment">// 读取内存中的bundle 并通过传入的回调更新server.js中的bundle</span></div><div class="line">  clientCompiler.plugin(<span class="string">'done'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> fs = devMiddleware.fileSystem</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> fs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line">    clientManifest = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-client-manifest.json'</span>))</div><div class="line">    <span class="keyword">if</span> (bundle) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// hot middleware</span></div><div class="line">  app.use(<span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(clientCompiler))</div><div class="line"></div><div class="line">  <span class="comment">// watch and update server renderer</span></div><div class="line">  <span class="keyword">const</span> serverCompiler = webpack(serverConfig)</div><div class="line">  <span class="comment">// 获取基于memory-fs创建的内存文件系统对象</span></div><div class="line">  <span class="keyword">const</span> mfs = <span class="keyword">new</span> MFS()</div><div class="line">  serverCompiler.outputFileSystem = mfs</div><div class="line">  <span class="comment">// 设置文件重新编译监听并通过传入的回调更新server.js中的bundle</span></div><div class="line">  serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">    stats = stats.toJson()</div><div class="line">    stats.errors.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div><div class="line">    stats.warnings.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.warn(err))</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> mfs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// read bundle generated by vue-ssr-webpack-plugin</span></div><div class="line">    bundle = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-server-bundle.json'</span>))</div><div class="line">    <span class="keyword">if</span> (clientManifest) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> readyPromise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.base.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.base.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map</span></div><div class="line">  devtool: isProd</div><div class="line">    ? <span class="literal">false</span></div><div class="line">    : <span class="string">'#cheap-module-source-map'</span>,</div><div class="line">  <span class="comment">// 打包输出配置</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    <span class="attr">publicPath</span>: <span class="string">'/dist/'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[chunkhash].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'public'</span>: path.resolve(__dirname, <span class="string">'../public'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line"></div><div class="line">    ···</div><div class="line">	<span class="comment">// 一系列加载器</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="attr">plugins</span>:[</div><div class="line">    <span class="comment">// 压缩js的插件</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      <span class="attr">compress</span>: &#123; <span class="attr">warnings</span>: <span class="literal">false</span> &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来</span></div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.client.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.client.config.js</span></div><div class="line"></div><div class="line"><span class="comment">// 基于webpack-merge工具合并base以及client特定配置项</span></div><div class="line"><span class="keyword">const</span> config = merge(base, &#123;</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: &#123;</div><div class="line">    <span class="attr">app</span>: <span class="string">'./src/entry-client.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置客户端数据请求API为create-api-client.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-client.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"client"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 设置打包时公共模块的提取规则</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="attr">minChunks</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">        <span class="comment">// a module is extracted into the vendor chunk if...</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="comment">// it's inside node_modules</span></div><div class="line">          /node_modules/.test(<span class="built_in">module</span>.context) &amp;&amp;</div><div class="line">          <span class="comment">// and not a CSS file (due to extract-text-webpack-plugin limitation)</span></div><div class="line">          !<span class="regexp">/\.css$/</span>.test(<span class="built_in">module</span>.request)</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name，</span></div><div class="line">    <span class="comment">// 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'manifest'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> VueSSRClientPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>bulid/webpack.server.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.server.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</div><div class="line">  <span class="comment">// 指定生成后的运行环境在node</span></div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  <span class="comment">// 设置代码调试map</span></div><div class="line">  devtool: <span class="string">'#source-map'</span>,</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: <span class="string">'./src/entry-server.js'</span>,</div><div class="line">  <span class="comment">// 设置输出文件名，并设置模块导出为commonjs2类型</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'server-bundle.js'</span>,</div><div class="line">    <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置好服务端数据请求API为create-api-server.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-server.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置不打包排除规则</span></div><div class="line">  externals: nodeExternals(&#123;</div><div class="line">    <span class="comment">// do not externalize CSS files in case we need to import it from a dep</span></div><div class="line">    whitelist: <span class="regexp">/\.css$/</span></div><div class="line">  &#125;),</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">	<span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"server"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">//设置VueSSRServerPlugin插件</span></div><div class="line">    <span class="keyword">new</span> VueSSRServerPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上，基于 webpack config 的<code>setup-dev-server</code>就到这里，接下来说<code>创建渲染器</code>。</p>
<h3 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`createRenderer`</span>)</div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line">   </div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建渲染器时重点两件事：<br>1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件<code>entry-server.js</code>打包生成的。<br>当渲染器调用<code>renderer.renderToString</code>开始渲染时，会执行该入口文件的默认方法。<br>2.传入了一个html模板<code>index.template.html</code>，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。</p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">index.template.html解读</a></p>
</blockquote>
<p>顺着readyPromise.then的调用链，接下来调用render方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">···</div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    res.end(html)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>renderer.renderToString</code>方法内部会先调用入口模块<code>entry-server.js</code>的默认方法，我们看下<code>entry-server.js</code>主要做了什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This exported function will be called by `bundleRenderer`.</span></div><div class="line"><span class="comment">// This is where we perform data-prefetching to determine the</span></div><div class="line"><span class="comment">// state of our application before actually rendering it.</span></div><div class="line"><span class="comment">// Since data fetching is async, this function is expected to</span></div><div class="line"><span class="comment">// return a Promise that resolves to the app instance.</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> s = isDev &amp;&amp; <span class="built_in">Date</span>.now()</div><div class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</div><div class="line"></div><div class="line">    <span class="comment">// set router's location</span></div><div class="line">    <span class="comment">// 手动路由切换到请求的url，即'/'</span></div><div class="line">    router.push(context.url)</div><div class="line"></div><div class="line">    <span class="comment">// wait until router has resolved possible async hooks</span></div><div class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js</span></div><div class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</div><div class="line">      <span class="comment">// no matched routes</span></div><div class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</div><div class="line">        reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Call fetchData hooks on components matched by the route.</span></div><div class="line">      <span class="comment">// A preFetch hook dispatches a store action and returns a Promise,</span></div><div class="line">      <span class="comment">// which is resolved when the action is complete and store state has been</span></div><div class="line">      <span class="comment">// updated.</span></div><div class="line">      <span class="comment">// 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据</span></div><div class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> component.asyncData &amp;&amp; component.asyncData(&#123;</div><div class="line">          store,</div><div class="line">          <span class="attr">route</span>: router.currentRoute</div><div class="line">        &#125;)</div><div class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        isDev &amp;&amp; <span class="built_in">console</span>.log(<span class="string">`data pre-fetch: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - s&#125;</span>ms`</span>)</div><div class="line">        <span class="comment">// After all preFetch hooks are resolved, our store is now</span></div><div class="line">        <span class="comment">// filled with the state needed to render the app.</span></div><div class="line">        <span class="comment">// Expose the state on the render context, and let the request handler</span></div><div class="line">        <span class="comment">// inline the state in the HTML response. This allows the client-side</span></div><div class="line">        <span class="comment">// store to pick-up the server-side state without having to duplicate</span></div><div class="line">        <span class="comment">// the initial data fetching on the client.</span></div><div class="line">        <span class="comment">// 把vuex的state设置到传入的context.initialState上</span></div><div class="line">        context.state = store.state</div><div class="line">        <span class="comment">// 返回state, router已经设置好的Vue实例app</span></div><div class="line">        resolve(app)</div><div class="line">      &#125;).catch(reject)</div><div class="line">    &#125;, reject)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>entry-server.js</code>的主要工作：<br>0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。<br>1.手动路由切换到请求的url，即’/‘<br>2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据<br>3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js）</p>
<blockquote>
<p>Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：<code>服务端渲染时的数据预取流程</code></p>
</blockquote>
<p>还记得<code>index.template.html</code>被设置到<code>template</code>属性中吗？<br>此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就是这里，这个<code>&lt;!--vue-ssr-outlet--&gt;</code>Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。<br>如果改动，服务端渲染时会有错误提示：<code>Error: Content placeholder not found in template.</code></p>
<p>接下来，Vue渲染器会回调callback方法，我们回到<code>server.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">	</div><div class="line">  ···</div><div class="line"></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line"></div><div class="line">    res.end(html)</div><div class="line"></div><div class="line">    ···</div><div class="line"></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时只需要将渲染好的<code>html</code>写入http响应体就结束了，浏览器客户端就可以看到页面了。</p>
<p>接下来我们看看服务端数据预取的实现</p>
<h2 id="服务端渲染时的数据预取流程"><a href="#服务端渲染时的数据预取流程" class="headerlink" title="服务端渲染时的数据预取流程"></a>服务端渲染时的数据预取流程</h2><p>上文提到，服务端渲染时，会手动将路由导航到请求地址即<code>&#39;/&#39;</code>下，然后调用该路由组件的asyncData方法来预取数据</p>
<p>那么我们看看路由配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/router/index.js</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="comment">// route-level code splitting</span></div><div class="line"><span class="keyword">const</span> createListView = <span class="function"><span class="params">id</span> =&gt;</span> () =&gt; System.import(<span class="string">'../views/CreateListView'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.default(id))</div><div class="line"><span class="keyword">const</span> ItemView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/ItemView.vue'</span>)</div><div class="line"><span class="keyword">const</span> UserView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/UserView.vue'</span>)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">    <span class="attr">mode</span>: <span class="string">'history'</span>,</div><div class="line">    <span class="attr">scrollBehavior</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</div><div class="line">    <span class="attr">routes</span>: [</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/top/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'top'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/new/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'new'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/show/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'show'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/ask/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'ask'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/job/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'job'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/item/:id(\\d+)'</span>, <span class="attr">component</span>: ItemView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: UserView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/top'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>地址<code>&#39;/&#39;</code>是做了redirect到<code>&#39;/top&#39;</code>,其实就是默认地址就是到top页面，在看第一条路由配置，<code>&#39;/top&#39;</code>路由对应的组件是<code>createListView(&#39;top&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createListView</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;type&#125;</span>-stories-view`</span>,</div><div class="line"></div><div class="line">    asyncData (&#123; store &#125;) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView asyncData`</span>)</div><div class="line">      <span class="keyword">return</span> store.dispatch(<span class="string">'FETCH_LIST_DATA'</span>, &#123; type &#125;)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">title</span>: camelize(type),</div><div class="line"></div><div class="line">    render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips: <a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">Vuex状态管理</a><br>1.dispatch对应Action，commit对应mutation<br>2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。</p>
</blockquote>
<p><code>Vuex state状态变更流程</code><br><img src="/assets/postImg/vuex_state.jpg" alt="vuex_state"></p>
<p>asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store.</p>
<p>最后数据就都保存在store这里了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/store/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">      <span class="attr">activeType</span>: <span class="literal">null</span>,</div><div class="line">      <span class="attr">itemsPerPage</span>: <span class="number">20</span>,</div><div class="line">      <span class="attr">items</span>: &#123;<span class="comment">/* [id: number]: Item */</span>&#125;,</div><div class="line">      <span class="attr">users</span>: &#123;<span class="comment">/* [id: string]: User */</span>&#125;,</div><div class="line">      <span class="attr">lists</span>: &#123;</div><div class="line">        <span class="attr">top</span>: [<span class="comment">/* number */</span>],</div><div class="line">        <span class="attr">new</span>: [],</div><div class="line">        <span class="attr">show</span>: [],</div><div class="line">        <span class="attr">ask</span>: [],</div><div class="line">        <span class="attr">job</span>: []</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    actions,</div><div class="line">    mutations,</div><div class="line">    getters</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将开始通过<a href="https://cn.vuejs.org/v2/guide/render-function.html#main" target="_blank" rel="external">Render 函数</a>创建HTML。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line">render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// /src/views/ItemList.vue</div><div class="line">···</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-view"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list-nav"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"page &gt; 1"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page - 1)"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"hasMore"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page + 1)"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"transition"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list"</span> <span class="attr">:key</span>=<span class="string">"displayedPage"</span> <span class="attr">v-if</span>=<span class="string">"displayedPage &gt; 0"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">v-for</span>=<span class="string">"item in displayedItems"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">:item</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line">···</div></pre></td></tr></table></figure>
<p>这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的<code>&lt;!--vue-ssr-outlet--&gt;</code>,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。</p>
<blockquote>
<p>Tips:<br>后续更新内容规划：<br>1.生产环境下的服务端渲染逻辑流程<br>2.客户端渲染逻辑流程<br>3.客户端vue组件细节解读</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-hackernews-2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HackerNews&lt;/a&gt;是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/hn-architecture.png&quot; alt=&quot;hn-architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. &lt;/p&gt;
&lt;p&gt;服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。&lt;/p&gt;
&lt;p&gt;客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过&lt;code&gt;app.$mount(&amp;#39;#app&amp;#39;)&lt;/code&gt;挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行&lt;a href=&quot;https://ssr.vuejs.org/en/hydration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hydration&lt;/a&gt;（合并）&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 细节解读</title>
    <link href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/"/>
    <id>https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2017-05-13T12:47:02.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对<a href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/">项目源码解读</a>的细节补充。</p>
<h2 id="package-json解读"><a href="#package-json解读" class="headerlink" title="package.json解读"></a>package.json解读</h2><p>该文件提供了四种命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install dependencies</span></div><div class="line">npm install <span class="comment"># or yarn</span></div><div class="line"></div><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line">npm run dev</div><div class="line"></div><div class="line"><span class="comment"># build for production</span></div><div class="line">npm run build</div><div class="line"></div><div class="line"><span class="comment"># serve in production mode</span></div><div class="line">npm start</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>执行<code>npm install</code><br>查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。</p>
<blockquote>
<p>Tips:dependencies与devDependencies的区别<br>devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。<br>dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。<br>这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？<br>答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。</p>
</blockquote>
<p>执行<code>npm run dev</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line"><span class="string">"dev"</span>: <span class="string">"node server"</span>,</div><div class="line"><span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node server"</span>,</div><div class="line"><span class="string">"build"</span>: <span class="string">"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server"</span>,</div><div class="line"><span class="string">"build:client"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules"</span>,</div><div class="line"><span class="string">"build:server"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<p>执行<code>npm run build</code><br>同样，找到build属性，并执行：<code>rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server</code>，即删除dist目录并执行<code>npm run build:client</code>和<code>npm run build:server</code><br>对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件</p>
<p>执行<code>npm start</code><br>同样，找到start属性，并执行：<code>cross-env NODE_ENV=production node server</code>，即通过cross-env模块设置NODE_ENV环境变量为production，并执行<code>node server</code></p>
<blockquote>
<p>Tips:为什么是<code>npm start</code>而不是<code>npm run start</code>?<br>1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见<code>npm --help</code><br>2.其他三个命令都不是内置命令，需要经由<code>npm run</code>去执行。</p>
</blockquote>
<h2 id="index-template-html解读"><a href="#index-template-html解读" class="headerlink" title="index.template.html解读"></a>index.template.html解读</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">sizes</span>=<span class="string">"48x48"</span> <span class="attr">href</span>=<span class="string">"/public/logo-48.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#f60"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这段html代码功能：移动端浏览器适配及PWA适配</p>
<blockquote>
<p>Tips:<a href="https://developer.mozilla.org/en-US/Apps/Progressive" target="_blank" rel="external">PWA (progressive web apps)</a>-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。</p>
</blockquote>
<p>接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。<br>浏览器体验：<br>在Chrome浏览器地址栏中输入项目地址，效果如下：</p>
<p><img src="/assets/postImg/open_by_chrome.png" alt="open_by_chrome"></p>
<p>PWA体验：<br>通过Chrome的<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="external">Add to Homescreen</a>功能，将该站点添加到桌面。效果如下：</p>
<p><img src="/assets/postImg/chrome_menu.png" alt="chrome_menu">  <img src="/assets/postImg/chrome_menu_add_to_homescrren.png" alt="chrome_menu_add_to_homescrren">  <img src="/assets/postImg/chrome_add_to_homescrren_pwa.png" alt="chrome_add_to_homescrren_pwa">  </p>
<p>点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。</p>
<p><img src="/assets/postImg/pwa_flash_white.png" alt="pwa_flash_white">  <img src="/assets/postImg/pwa_homepage.png" alt="pwa_homepage"></p>
<p>现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 主题色：绿色 启动图背景色：白色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f2f3f5"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//2. 主题色：绿色 启动图背景色：绿色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#48BB74"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//3. 主题色：橙色 启动图背景色：橙色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f60"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#f60"</span></div></pre></td></tr></table></figure></p>
<p><img src="/assets/postImg/pwa_flash.png" alt="pwa_flash">  <img src="/assets/postImg/pwa_flash_green.png" alt="pwa_flash_green">  <img src="/assets/postImg/pwa_flash_orange.png" alt="pwa_flash_orange"></p>
<blockquote>
<p>Tips:<br>这里用到的<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="external">manifest.json</a>不要与作为离线缓存的<a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">manifest</a>混淆。</p>
</blockquote>
<p>最后来对比感受下<code>非PWA的百度站点</code>Vs<code>PWA站点的hackernews</code>在Add to HomeScreen后，体验上的差异。</p>
<p><img src="/assets/postImg/pwa.gif" alt="pwa.gif"></p>
<p>概括下主要的差异：<br>1.增加了同原生应用一样的启动图过渡界面<br>2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。<br>3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。<br>注：PWA更多的特性这里并未应用，其实PWA可以做的更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对&lt;a href=&quot;https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/&quot;&gt;项目源码解读&lt;/a&gt;的细节补充。&lt;/p&gt;
&lt;h2 id=&quot;package-json解读&quot;&gt;&lt;a href=&quot;#package-json解读&quot; class=&quot;headerlink&quot; title=&quot;package.json解读&quot;&gt;&lt;/a&gt;package.json解读&lt;/h2&gt;&lt;p&gt;该文件提供了四种命令&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# install dependencies&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install &lt;span class=&quot;comment&quot;&gt;# or yarn&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in dev mode, with hot reload at localhost:8080&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build for production&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run build&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in production mode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
</feed>
