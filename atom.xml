<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>osan&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangfuda.github.io/"/>
  <updated>2018-02-25T10:35:08.012Z</updated>
  <id>https://wangfuda.github.io/</id>
  
  <author>
    <name>osan</name>
    <email>o.san@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Travis CI实现github开源项目在线持续集成和版本发布</title>
    <link href="https://wangfuda.github.io/2017/08/23/Travis-ci-github/"/>
    <id>https://wangfuda.github.io/2017/08/23/Travis-ci-github/</id>
    <published>2017-08-23T12:28:00.000Z</published>
    <updated>2018-02-25T10:35:08.012Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>开启github项目的Travis CI<ul>
<li>访问<a href="https://travis-ci.org/，使用github账号登录" target="_blank" rel="external">https://travis-ci.org/，使用github账号登录</a><br><img src="http://upload-images.jianshu.io/upload_images/1889129-b48b2d8e0f203d1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>开启github项目CI开关<br><img src="http://upload-images.jianshu.io/upload_images/1889129-ce2d086361a517b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><a id="more"></a>
<ul>
<li>配置自动编译脚本:.travis.yml</li>
</ul>
</li>
<li>ubuntu环境，安装ruby，gem，通过gem安装Travis<br>$ gem install travis</li>
<li>通过Travis的travis setup releases命令生成并配置.travis.yml（需要输入github账号和密码）<br>在您的github项目工程根目录下，执行如下命令，就会自动在根目录生成一个.travis.yml（中间会提示输入github账号密码等信息）：<br>$ travis setup releases<br>这里提供一份参考解释:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">android</span></div><div class="line"><span class="attr">sudo:</span> <span class="literal">false</span></div><div class="line"><span class="attr">android:</span></div><div class="line"><span class="attr">  components:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">build-tools-25.0.2</span></div><div class="line"><span class="bullet">  -</span> <span class="string">android-25</span></div><div class="line"><span class="bullet">  -</span> <span class="string">extra-android-m2repository</span></div><div class="line"><span class="bullet">  -</span> <span class="string">extra-android-support</span></div><div class="line"></div><div class="line">  <span class="comment">#  before install any dependencies required</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></div><div class="line"></div><div class="line">  <span class="comment">#  run the build script</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">-</span> <span class="string">"./gradlew assembleRelease"</span></div><div class="line"></div><div class="line">  <span class="comment">#  deploy stage base on tags</span></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  provider:</span> <span class="string">releases</span></div><div class="line"><span class="attr">  api_key:</span></div><div class="line">	<span class="attr">secure:</span> <span class="string">eY1MPVqsgMQs0deLMeHH0hJrkdxgP8VauCc0AW3MEDy+89EkPQiWK+mQgnNVExGL54ajMurYAs3Y3evRZNNxeIUnhXiFLTLTg9sZlbT1lhK+/0wjQ0pQ6B2RbQLeNUq5dXrJbgLEWTpDgvABZomnYvDiUll7iJESX1Eo2NOZ/YKsjkPXILnm63P37UOrxBzOi45ZTZ5hd4L+E1oDq9k0fI0YEh7HKJYR5RfpFK3fvcNqyoAPG2cBlwGS33dfg4LeZN2Yxb+7cNMraEipj7ZjiiaYFXeGOgBz8xWWqcG+k8MjqpxOKJtlSqKjxFYpa0J97yFxxmmMtIEJX+lExc6XMbm9xeYKMqeJJLwSpmNFk6ggkk/vUsTzMy8+LdczyuQhBvCGMRt/IZRSxGIOznZD3KbmK5/Ceex3aXgin2pEhNA4LmwSLf+zMhniJNIZj3b2cF8u18LR1lGTNxTD03w170lDtX1fizmUQYFSiPJHeBiGp3W5HD9uTLbJfnh9tfJnOIhlKMN5C1Nl2HUyeV4KXCnkl4q73DtMuuNBn66JnFUhuzh0diFVpdAUK0KhwYTGew6DNz3GsnxFuPr/6MnrpUKKxSucDjprA2G0bfd7XbrVSw9BYR3wk5mU3ust5HXqh0erTIh6kRkin6NphPm+NLyQTvvbeXc/+M/zkXWAU9w=</span></div><div class="line"><span class="attr">  file:</span> <span class="string">"app/build/outputs/apk/app-release-unsigned.apk"</span></div><div class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  on:</span></div><div class="line">	<span class="attr">tags:</span> <span class="literal">true</span></div><div class="line">	<span class="attr">repo:</span> <span class="string">wangfuda/nebula</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>以上配置主要实现了：<br>编译前，先授权了gradlew的执行权限<br>然后执行编译脚本：<code>./gradlew assembleRelease</code><br>最后基于tag触发，发布apk文件至github release中<br>以上配置中的具体含义可参考<a href="https://docs.travis-ci.com/user/customizing-the-build/" target="_blank" rel="external">官方文档</a></p>
<p>其中，<code>api_key</code>中的<code>secure</code>为<code>travis setup releases</code>命令执行中基于github账号密码自动生成的。<br>注：其实Travis CI提供了多种账号加密token的形式，但是其他几种均存在一些bug导致账号校验有问题，目前亲测这种可行。</p>
<ul>
<li>配置Bintray oss账号并发布版本至Bintray<ul>
<li>Bintray上注册账号，或用github账号登录，地址为：<a href="https://bintray.com/signup/oss，而非这个地址：https://bintray.com/signup" target="_blank" rel="external">https://bintray.com/signup/oss，而非这个地址：https://bintray.com/signup</a>  （注意，开源项目必须要用OSS账号，否则会因鉴权问题导致无法上传发布版本）</li>
<li>配置bintray.gradle（即发布版本的gradle脚本）<br>注：这里可以无需显示提供账号，可使用Travis CI上的该项目的环境变量来设置<br><img src="http://upload-images.jianshu.io/upload_images/1889129-19d7f6ac4c44f296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1889129-08d411f0703b605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
</ul>
<p>在gradle中基于Travis CI环境变量实现共用一套配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">bintray</span> <span class="string">&#123;</span></div><div class="line">    <span class="string">user</span> <span class="string">=</span> <span class="string">project.hasProperty("BINTRAY_USER")</span> <span class="string">?</span> <span class="string">BINTRAY_USER</span> <span class="string">:</span> <span class="string">System.getenv("BINTRAY_USER")</span></div><div class="line">    <span class="string">key</span> <span class="string">=</span> <span class="string">project.hasProperty("BINTRAY_KEY")</span> <span class="string">?</span> <span class="string">BINTRAY_KEY</span> <span class="string">:</span> <span class="string">System.getenv("BINTRAY_KEY")</span></div><div class="line">    <span class="string">...</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;开启github项目的Travis CI&lt;ul&gt;
&lt;li&gt;访问&lt;a href=&quot;https://travis-ci.org/，使用github账号登录&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://travis-ci.org/，使用github账号登录&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-b48b2d8e0f203d1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;开启github项目CI开关&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-ce2d086361a517b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="Travis CI" scheme="https://wangfuda.github.io/tags/Travis-CI/"/>
    
      <category term="GitHub" scheme="https://wangfuda.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>replugin源码解析之replugin-plugin-gradle（插件的gradle插件）</title>
    <link href="https://wangfuda.github.io/2017/07/20/replugin-plugin-gradle/"/>
    <id>https://wangfuda.github.io/2017/07/20/replugin-plugin-gradle/</id>
    <published>2017-07-20T14:21:00.000Z</published>
    <updated>2018-02-25T10:31:27.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/wangfuda/RePlugin/tree/master/replugin-plugin-gradle" target="_blank" rel="external">replugin-plugin-gradle</a> 是 RePlugin 插件框架中提供给replugin插件用的gradle插件，是一种动态编译方案实现。<br>主要在插件应用的编译期，基于Transform api 注入到编译流程中, 再通过Java字节码类库对编译中间环节的 Java 字节码文件进行修改，以便实现编译期动态修改插件应用的目的。<br><a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="external">RePlugin</a> 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。</p>
</blockquote>
<p>注 ：文件会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念：</p>
<ul>
<li>replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。</li>
<li>gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。</li>
</ul>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="http://upload-images.jianshu.io/upload_images/1889129-c3f36a60e25128e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a><br>replugin-plugin-gradle，针对插件应用编译期的注入任务：<br>动态修改插件中的调用代码，改为调用<a href="https://github.com/wangfuda/RePlugin/tree/master/replugin-plugin-library" target="_blank" rel="external">replugin-plugin-library</a>中的代码（如Activity的继承、Provider的重定向等）</p>
<ul>
<li><code>LoaderActivityInjector</code> 动态将插件中的Activity的继承相关代码 修改为 replugin-plugin-library 中的XXPluginActivity父类</li>
<li><code>LocalBroadcastInjector</code> 替换插件中的LocalBroadcastManager调用代码 为 插件库的调用代码。</li>
<li><code>ProviderInjector</code> 替换 插件中的 ContentResolver 调用代码 为 插件库的调用代码</li>
<li><code>ProviderInjector2</code> 替换 插件中的 ContentProviderClient 调用代码 为 插件库的调用代码</li>
<li><code>GetIdentifierInjector</code> 替换 插件中的 Resource.getIdentifier 调用代码的参数 为 动态适配的参数</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-de0da61e12da54a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>replugin-plugin-gradle插件的工作流：基于Gradle的<a href="http://google.github.io/android-gradle-dsl/javadoc/current/" target="_blank" rel="external">Transform API</a>，在编译期的构建任务流中，class转为dex之前，插入一个Transform，并在此Transform流中，基于<a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="external">Javassist</a>实现对字节码文件的注入。</li>
</ul>
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="string">\qihoo\replugin\replugin-plugin-gradle\src</span></div><div class="line"><span class="string">└─main</span></div><div class="line">    <span class="string">├─groovy</span></div><div class="line">    <span class="string">│</span>  <span class="string">└─com</span></div><div class="line">    <span class="string">│</span>      <span class="string">└─qihoo360</span></div><div class="line">    <span class="string">│</span>          <span class="string">└─replugin</span></div><div class="line">    <span class="string">│</span>              <span class="string">└─gradle</span></div><div class="line">    <span class="string">│</span>                  <span class="string">└─plugin</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">AppConstant.groovy</span>                      <span class="comment"># 程序常量定义区</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">ReClassPlugin.groovy</span>                    <span class="comment"># 插件动态编译方案入口</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  </div><div class="line">    <span class="string">│</span>                      <span class="string">├─debugger</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">PluginDebugger.groovy</span>               <span class="comment"># 用于插件调试的gradle task实现</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">├─injector</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  <span class="string">BaseInjector.groovy</span>                  <span class="comment"># 注入器基类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  <span class="string">IClassInjector.groovy</span>                <span class="comment"># 注入器接口类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  <span class="string">Injectors.groovy</span>                     <span class="comment"># 注入器枚举类，定义了全部注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">├─identifier</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      <span class="string">GetIdentifierExprEditor.groovy</span>   <span class="comment"># javassist 允许修改方法里的某个表达式，此类为替换 getIdentifier 方法中表达式的实现类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      <span class="string">GetIdentifierInjector.groovy</span>     <span class="comment"># GetIdentifier 方法注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">├─loaderactivity</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      <span class="string">LoaderActivityInjector.groovy</span>    <span class="comment"># Activity代码注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">├─localbroadcast</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      <span class="string">LocalBroadcastExprEditor.groovy</span>  <span class="comment"># 替换几个广播相关方法表达式的实现类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      <span class="string">LocalBroadcastInjector.groovy</span>    <span class="comment"># 广播代码注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">└─provider</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>          <span class="string">ProviderExprEditor.groovy</span>       <span class="comment"># 替换ContentResolver类的几个方法表达式</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>          <span class="string">ProviderExprEditor2.groovy</span>      <span class="comment"># 替换ContentProviderClient类的几个方法表达式</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>          <span class="string">ProviderInjector.groovy</span>         <span class="comment"># Provider之ContentResolver代码注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>          <span class="string">ProviderInjector2.groovy</span>        <span class="comment"># Provider之ContentProviderClient代码注入器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>          </div><div class="line">    <span class="string">│</span>                      <span class="string">├─inner</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">ClassFileVisitor.groovy</span>             <span class="comment"># 类文件遍历类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">CommonData.groovy</span>                   <span class="comment"># 实体类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">ReClassTransform.groovy</span>             <span class="comment"># 核心类，基于 transform api 实现动态修改class文件的总调度入口</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">Util.groovy</span>                         <span class="comment"># 工具类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">├─manifest</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">IManifest.groovy</span>                    <span class="comment"># 接口类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">ManifestAPI.groovy</span>                  <span class="comment"># 操作Manifest的API类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">ManifestReader.groovy</span>               <span class="comment"># Manifest读取工具类</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">└─util</span></div><div class="line">    <span class="string">│</span>                              <span class="string">CmdUtil.groovy</span>                     <span class="comment"># 命令行工具类</span></div><div class="line">    <span class="string">│</span>                              </div><div class="line">    <span class="string">└─resources</span></div><div class="line">        <span class="string">└─META-INF</span></div><div class="line">            <span class="string">└─gradle-plugins</span></div><div class="line">                    <span class="string">replugin-plugin-gradle.properties</span>                 <span class="comment"># 指定 gradle 插件实现类</span></div></pre></td></tr></table></figure>
<h2 id="replugin-plugin-gradle的基本用法"><a href="#replugin-plugin-gradle的基本用法" class="headerlink" title="replugin-plugin-gradle的基本用法"></a>replugin-plugin-gradle的基本用法</h2><ul>
<li>添加 RePlugin Plugin Gradle 依赖<br>在项目根目录的 build.gradle（注意：不是 app/build.gradle） 中添加 replugin-plugin-gradle 依赖：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.qihoo360.replugin:replugin-plugin-gradle:2.1.5'</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在项目的app模块中的build.gradle应用插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'replugin-plugin-gradle'</span></div></pre></td></tr></table></figure></p>
<h2 id="replugin-plugin-gradle的源码解析"><a href="#replugin-plugin-gradle的源码解析" class="headerlink" title="replugin-plugin-gradle的源码解析"></a>replugin-plugin-gradle的源码解析</h2><p>我们在开始阅读源码前，要思考下，<code>replugin-plugin-gradle</code>是什么？<br>A:<code>replugin-plugin-gradle</code>是一个自定义的gradle插件。<br>这个清楚了，没上车的上车，上车了的别动！</p>
<p><code>replugin-plugin-gradle.properties</code>文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation-<span class="class"><span class="keyword">class</span></span>=com.qihoo360.replugin.gradle.plugin.ReClassPlugin</div></pre></td></tr></table></figure></p>
<p>在开发自定义gradle插件时，都会先定义这么个文件。这里有 2 个知识点：</p>
<ul>
<li>文件中的<code>implementation-class</code>用来指定插件实现类。</li>
<li>文件名用来指定插件名，即在插件中使用gradle插件时的<code>apply plugin: &#39;replugin-plugin-gradle&#39;</code>中的<code>replugin-plugin-gradle</code>.</li>
</ul>
<p>我们到插件实现类看看这个插件是如何工作的。</p>
<p><code>ReClassPlugin.groovy</code>文件<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReClassPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line">		    println <span class="string">"$&#123;AppConstant.TAG&#125; Welcome to replugin world ! "</span></div><div class="line">            ...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了一个类ReClassPlugin，继承自gradle-api 库中的接口类 Plugin<project> ，实现了apply接口方法，apply方法会在 build.gradle 中执行 <code>apply plugin: &#39;replugin-plugin-gradle&#39;</code>时被调用。</project></p>
<p>接下来解读下 apply 方法的具体实现。</p>
<h2 id="用于快速调试的gradle-task"><a href="#用于快速调试的gradle-task" class="headerlink" title="用于快速调试的gradle task"></a>用于快速调试的gradle task</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line"></div><div class="line">        println <span class="string">"$&#123;AppConstant.TAG&#125; Welcome to replugin world ! "</span></div><div class="line"></div><div class="line">        <span class="comment">/* Extensions */</span></div><div class="line">        project.extensions.create(AppConstant.USER_CONFIG, ReClassConfig)</div><div class="line"></div><div class="line">        <span class="keyword">def</span> isApp = project.plugins.hasPlugin(AppPlugin)</div><div class="line">        <span class="keyword">if</span> (isApp) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">def</span> config = project.extensions.getByName(AppConstant.USER_CONFIG)</div><div class="line"></div><div class="line">            <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            android.applicationVariants.all &#123; variant -&gt;</div><div class="line">                PluginDebugger pluginDebugger = <span class="keyword">new</span> PluginDebugger(project, config, variant)</div><div class="line"></div><div class="line">                <span class="keyword">def</span> variantData = variant.variantData</div><div class="line">                <span class="keyword">def</span> scope = variantData.scope</div><div class="line"></div><div class="line">                <span class="keyword">def</span> assembleTask = variant.getAssemble()</div><div class="line"></div><div class="line">                <span class="keyword">def</span> installPluginTaskName = scope.getTaskName(AppConstant.TASK_INSTALL_PLUGIN, <span class="string">""</span>)</div><div class="line">                <span class="keyword">def</span> installPluginTask = project.task(installPluginTaskName)</div><div class="line"></div><div class="line">                installPluginTask.doLast &#123;</div><div class="line">                    pluginDebugger.startHostApp()</div><div class="line">                    pluginDebugger.uninstall()</div><div class="line">                    pluginDebugger.forceStopHostApp()</div><div class="line">                    pluginDebugger.startHostApp()</div><div class="line">                    pluginDebugger.install()</div><div class="line">                &#125;</div><div class="line">                installPluginTask.group = AppConstant.TASKS_GROUP</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先向Plugin传递参数，通过<code>project.extensions.create(AppConstant.USER_CONFIG, ReClassConfig)</code>，将ReClassConfig类的常量配置信息赋值给<code>AppConstant.USER_CONFIG</code>，后面有两个地方会用到：一个是<code>PluginDebugger</code>类中要用到一些参数；另一个是做动态编译时要用到一些参数；后面逻辑会陆续用到。</li>
<li><p>判断project中是否含有<code>AppPlugin</code>类型插件，即是否有’application’ projects类型的Gradle plugin。我们在replugin插件项目中是应用了该类型插件的：<code>apply plugin: &#39;com.android.application&#39;</code>.</p>
</li>
<li><p>获取project中的AppExtension类型extension，即<code>com.android.application</code> projects的android extension.也就是在你的app模块的build.gradle中定义的闭包：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>android.applicationVariants.all</code>，遍历android extension的Application variants 组合。android gradle 插件，会对最终的包以多个维度进行组合。ApplicationVariant的组合 = {ProductFlavor} x {BuildType} 种组合.</p>
</li>
<li><p><code>new PluginDebugger(project, config, variant)</code>，初始化PluginDebugger类实例，主要配置了最终生成的插件应用的文件路径，以及adb文件的路径，是为了后续基于adb命令做push apk到SD卡上做准备。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apkFile = <span class="keyword">new</span> File(apkDir, apkName)</div><div class="line">adbFile = globalScope.androidBuilder.sdkInfo.adb;</div></pre></td></tr></table></figure>
</li>
<li><p><code>def assembleTask = variant.getAssemble()</code>，获取assemble task(即打包apk的task)，后续的task需要依赖此task，比如安装插件的task，肯定要等到assemble task打包生成apk后，才能去执行。</p>
</li>
<li>生成<code>installPluginTask</code> 的gradle task 名字，并调用project的task()方法创建此Task。然后指定此task的任务内容：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">installPluginTask.doLast &#123;</div><div class="line">	pluginDebugger.startHostApp()</div><div class="line">	pluginDebugger.uninstall()</div><div class="line">	pluginDebugger.forceStopHostApp()</div><div class="line">	pluginDebugger.startHostApp()</div><div class="line">	pluginDebugger.install()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>流程：启动宿主 -&gt; 卸载插件 -&gt; 强制停止宿主 -&gt; 启动宿主 -&gt; 安装插件</li>
<li>pluginDebugger 内的方法实现：基于adb shell + am 命令，实现 发送广播，push apk 等功能。,比如：<code>pluginDebugger.startHostApp()</code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> startHostApp() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isConfigNull()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String cmd = <span class="string">"$&#123;adbFile.absolutePath&#125; shell am start -n \"$&#123;config.hostApplicationId&#125;/$&#123;config.hostAppLauncherActivity&#125;\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER"</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != CmdUtil.syncExecute(cmd)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>pluginDebugger类的其他操作应用的方法，基本思路是一致的，基于adb+am命令。</p>
<ul>
<li><code>apply()</code>方法中共有如下几个gradle task(<code>查看task： gradlew.bat task 或 gradlew.bat tasks --all</code>):</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-5d266e6f8cd88600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>以上task分别有不同的调试目的，可以去分别了解下，细节实现大同小异。<br>看到这里，我们该插播一下调试方案的整体原理了：</p>
<ol>
<li><a href="https://github.com/Qihoo360/RePlugin/tree/master/replugin-host-library" target="_blank" rel="external">replugin-host-lib</a> 的DebuggerReceivers类中，注册了一系列用于快速调试的广播，而replugin-host-lib是会内置在宿主应用中的。</li>
<li>replugin-plugin-gradle 中创建了一系列gradle task，用于启动停止重启宿主应用，安装卸载运行插件应用。这些gradle task都是被动型task，需要通过命令行主动的运行这些task。</li>
<li>打开命令行终端，执行replugin插件项目的某个gradle task，以实现快速调试功能。比如：gradlew.bat rpInstallPluginDebug，最终就会将宿主和插件运行起来。</li>
<li>这些gradle task被手动执行后，task会执行一系列任务，比如通过adb push 插件到sdcard，或通过am命令发送广播，启动activity等。当发送一系列步骤1中注册的广播后，宿主应用收到广播后会执行对应的操作，比如启动插件的activity等。<blockquote>
<p>Tips.调试模式开启方法：<a href="https://github.com/Qihoo360/RePlugin/wiki/%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95" target="_blank" rel="external">插件调试</a><br>Debug阶段建议开启,Release阶段建议关闭,默认为关闭状态</p>
</blockquote>
</li>
</ol>
<p>继续看<code>apply()</code>方法中的源码。</p>
<p>##Transform:动态编译方案实现</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (isApp) &#123;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            <span class="keyword">def</span> transform = <span class="keyword">new</span> ReClassTransform(project)</div><div class="line">            <span class="comment">// 将 transform 注册到 android</span></div><div class="line">            android.registerTransform(transform)</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>重点来了，这里就是动态编译方案的实现入口。<br>在详细解读动态编译实现之前，先了解2个概念：</p>
<ul>
<li><p>什么是 Transform？</p>
<ul>
<li>Transform 是 Android Gradle API ，允许第三方插件在class文件转为dex文件前操作编译完成的class文件，这个API的引入是为了简化class文件的自定义操作而无需对Task进行处理。在做代码插桩时，本质上是在<code>merge{ProductFlavor}{BuildType}Assets</code> Task 之后，<code>transformClassesWithDexFor{ProductFlavor}{BuildType}</code> Transform 之前,插入一个<code>transformClassesWith{YourTransformName}For{ProductFlavor}{BuildType}</code> Transform，此Transform中完成对class文件的自定义操作（包括修改父类继承，方法中的super方法调用，方法参数替换等等，这个class交给你，理论上是可以改到怀疑人生）。</li>
<li>详细API参见：<a href="http://google.github.io/android-gradle-dsl/javadoc/current/" target="_blank" rel="external">Transform</a></li>
</ul>
</li>
<li><p>如何使用 Transform？</p>
<ul>
<li>实现一个继承自<code>Transform</code>的自定义 Transform 类。</li>
<li>通过<code>registerTransform(@NonNull Transform transform, Object... dependencies)</code>注册自定义 Transform 类。</li>
</ul>
</li>
</ul>
<p>去看看 ReClassTransform 类的核心实现。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReClassTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    String getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'___ReClass___'</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">void</span> transform(Context context,</div><div class="line">                   Collection&lt;TransformInput&gt; inputs,</div><div class="line">                   Collection&lt;TransformInput&gt; referencedInputs,</div><div class="line">                   TransformOutputProvider outputProvider,</div><div class="line">                   <span class="keyword">boolean</span> isIncremental) <span class="keyword">throws</span> IOException, TransformException, InterruptedException &#123;</div><div class="line"></div><div class="line">        welcome()</div><div class="line"></div><div class="line">        <span class="comment">/* 读取用户配置 */</span></div><div class="line">        <span class="keyword">def</span> config = project.extensions.getByName(<span class="string">'repluginPluginConfig'</span>)</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// Compatible with path separators for window and Linux, and fit split param based on 'Pattern.quote'</span></div><div class="line">        <span class="keyword">def</span> variantDir = rootLocation.absolutePath.split(getName() + Pattern.quote(File.separator))[<span class="number">1</span>]</div><div class="line"></div><div class="line">        CommonData.appModule = config.appModule</div><div class="line">        CommonData.ignoredActivities = config.ignoredActivities</div><div class="line"></div><div class="line">        <span class="keyword">def</span> injectors = includedInjectors(config, variantDir)</div><div class="line">        <span class="keyword">if</span> (injectors.isEmpty()) &#123;</div><div class="line">            copyResult(inputs, outputProvider) <span class="comment">// 跳过 reclass</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            doTransform(inputs, outputProvider, config, injectors) <span class="comment">// 执行 reclass</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</div><div class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    Set&lt;QualifiedContent.Scope&gt; getScopes() &#123;</div><div class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">boolean</span> isIncremental() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>getName()</code>，即指定刚才提到的那个插入的transform <code>transformClassesWith{YourTransformName}For{ProductFlavor}{BuildType}</code>中的<code>{YourTransformName}</code>。</li>
<li><code>transform()</code> 方法会在执行你的transform时被调用。</li>
<li><code>project.extensions.getByName(&#39;repluginPluginConfig&#39;)</code>读取用户在replugin插件项目的build.gradle中配置的参数，比如设置了需要忽略的注入器<code>ignoredInjectors</code>、需要忽略替换的Activity<code>ignoredActivities</code>、自定义的代码注入器<code>customInjectors</code>等。</li>
<li><code>includedInjectors()</code>返回用户未忽略的注入器的集合<ul>
<li><code>LoaderActivityInjector</code> 替换插件中的Activity的继承相关代码 为 replugin-plugin-library 中的XXPluginActivity父类</li>
<li><code>LocalBroadcastInjector</code> 替换插件中的LocalBroadcastManager调用代码 为 插件库的调用代码。</li>
<li><code>ProviderInjector</code> 替换 插件中的 ContentResolver 调用代码 为 插件库的调用代码</li>
<li><code>ProviderInjector2</code> 替换 插件中的 ContentProviderClient 调用代码 为 插件库的调用代码</li>
<li><code>GetIdentifierInjector</code> 替换 插件中的 Resource.getIdentifier 调用代码的参数 为 动态适配的参数</li>
</ul>
</li>
<li><code>getInputTypes()</code> 指明当前Trasfrom要处理的数据类型,可选类型包括<code>CONTENT_CLASS</code>（代表要处理的数据是编译过的Java代码，而这些数据的容器可以是jar包也可以是文件夹），<code>CONTENT_JARS</code>（包括编译过的Java代码和标准的Java资源），<code>CONTENT_RESOURCES</code>，<code>CONTENT_NATIVE_LIBS</code>等。在replugin-plugin-gradle中是使用Transform来做代码插桩,所以选用<code>CONTENT_CLASS</code>类型。</li>
<li><p><code>getScopes()</code> 配置当前Transform的作用域，实际使用中可以根据需求配置多种<code>Scope</code>。</p>
</li>
<li><p><code>doTransform()</code>方法是执行reclass的关键</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doTransform(Collection&lt;TransformInput&gt; inputs,</div><div class="line">                TransformOutputProvider outputProvider,</div><div class="line">                Object config,</div><div class="line">                <span class="keyword">def</span> injectors) &#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 初始化 ClassPool */</span></div><div class="line">    Object pool = initClassPool(inputs)</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Transform方法中的参数<code>inputs</code>和<code>outputProvider</code>一定程度上反映了Transform的工作流，接受输入-&gt;处理输入-&gt;输出数据。</li>
<li><code>initClassPool(...)</code>方法主要的工作：添加<code>编译时引用到的类</code>到 <code>ClassPool</code>，同时记录<code>要修改的 jar</code> 到 <code>includeJars</code>。方便后续拿到这些class文件去修改。比如Sample中会添加的class路径：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; ClassPath:</div><div class="line">...</div><div class="line">// 插件项目replugin-sample的class目录</div><div class="line">    E:\opensource\qihoo\RePlugin\replugin-sample\plugin\plugin-demo1\app\build\intermediates\classes\debug</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="external">Javassit</a> 是一个处理Java字节码的类库。<br><code>CtMethod</code>：是一个class文件中的方法的抽象表示。一个<code>CtMethod</code>对象表示一个方法。（Javassit 库API）<br><code>CtClass</code>：是一个class文件的抽象表示。一个<code>CtClass</code>（compile-time class)对象可以用来处理一个class文件。（Javassit 库API）<br><code>ClassPool</code>：是一个<code>CtClass</code>对象的容器类。（Javassit 库API）<br><code>.class文件</code>：.class文件是一种存储Java字节码的二进制文件，里面包含一个Java类或者接口。</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doTransform(Collection&lt;TransformInput&gt; inputs,</div><div class="line">                TransformOutputProvider outputProvider,</div><div class="line">                Object config,</div><div class="line">                <span class="keyword">def</span> injectors) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* 进行注入操作 */</span></div><div class="line">    Injectors.values().each &#123;</div><div class="line">        </div><div class="line">        ...    </div><div class="line">            doInject(inputs, pool, it.injector, config.properties[<span class="string">"$&#123;configPre&#125;Config"</span>])</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (config.customInjectors != <span class="literal">null</span>) &#123;</div><div class="line">        config.customInjectors.each &#123;</div><div class="line">            doInject(inputs, pool, it)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会遍历除了用户已忽略过的全部代码注入器，依次执行每个注入器的特定注入任务。<br>看下<code>doInject(...)</code>方法实现。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 执行注入操作</div><div class="line"> */</div><div class="line"><span class="keyword">def</span> doInject(Collection&lt;TransformInput&gt; inputs, ClassPool pool,</div><div class="line">             IClassInjector injector, Object config) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        inputs.each &#123; TransformInput input -&gt;</div><div class="line">            input.directoryInputs.each &#123;</div><div class="line">                handleDir(pool, it, injector, config)</div><div class="line">            &#125;</div><div class="line">            input.jarInputs.each &#123;</div><div class="line">                handleJar(pool, it, injector, config)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        println t.toString()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分别处理目录中的 class 文件和处理 jar<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> handleDir(ClassPool pool, DirectoryInput input, IClassInjector injector, Object config) &#123;</div><div class="line">    println <span class="string">"&gt;&gt;&gt; Handle Dir: $&#123;input.file.absolutePath&#125;"</span></div><div class="line">    injector.injectClass(pool, input.file.absolutePath, config)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是那些注入器八仙过海，各显神通的时候了。还记得吗，前面那句代码<code>Injectors.values().each {</code>，这是要用每个注入器都把class们撸一遍。</p>
<p>##LoaderActivityInjector<br>第一个被执行的就是 <code>LoaderActivityInjector</code>,用来修改插件中XXActivity类中的顶级XXActivity父类 为 XXPluginActivity父类。看看如何实现的。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">def</span> injectClass(ClassPool pool, String dir, Map config) &#123;</div><div class="line">        println <span class="string">"&gt;&gt;&gt; LoaderActivityInjector dir: $dir"</span></div><div class="line">        init()</div><div class="line"></div><div class="line">        <span class="comment">/* 遍历程序中声明的所有 Activity */</span></div><div class="line">        <span class="comment">//每次都new一下，否则多个variant一起构建时只会获取到首个manifest</span></div><div class="line">        <span class="keyword">new</span> ManifestAPI().getActivities(project, variantDir).each &#123;</div><div class="line">            <span class="comment">// 处理没有被忽略的 Activity</span></div><div class="line">            <span class="keyword">if</span> (!(it <span class="keyword">in</span> CommonData.ignoredActivities)) &#123;</div><div class="line">                handleActivity(pool, it, dir)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>init()</code>指定了 Activity 替换规则，只替换那些顶级Activity父类为 replugin-plugin-lib 库中的 XXPluginActivity。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> <span class="keyword">private</span> <span class="keyword">static</span> loaderActivityRules = [</div><div class="line">            <span class="string">'android.app.Activity'</span>                    : <span class="string">'com.qihoo360.replugin.loader.a.PluginActivity'</span>,</div><div class="line">            <span class="string">'android.app.TabActivity'</span>                 : <span class="string">'com.qihoo360.replugin.loader.a.PluginTabActivity'</span>,</div><div class="line">            <span class="string">'android.app.ListActivity'</span>                : <span class="string">'com.qihoo360.replugin.loader.a.PluginListActivity'</span>,</div><div class="line">            <span class="string">'android.app.ActivityGroup'</span>               : <span class="string">'com.qihoo360.replugin.loader.a.PluginActivityGroup'</span>,</div><div class="line">            <span class="string">'android.support.v4.app.FragmentActivity'</span> : <span class="string">'com.qihoo360.replugin.loader.a.PluginFragmentActivity'</span>,</div><div class="line">            <span class="string">'android.support.v7.app.AppCompatActivity'</span>: <span class="string">'com.qihoo360.replugin.loader.a.PluginAppCompatActivity'</span>,</div><div class="line">            <span class="string">'android.preference.PreferenceActivity'</span>   : <span class="string">'com.qihoo360.replugin.loader.a.PluginPreferenceActivity'</span>,</div><div class="line">            <span class="string">'android.app.ExpandableListActivity'</span>      : <span class="string">'com.qihoo360.replugin.loader.a.PluginExpandableListActivity'</span></div><div class="line">    ]</div></pre></td></tr></table></figure>
</li>
<li><p>接下来遍历插件应用AndroidManifest.xml中声明的所有 Activity名称，并在<code>handleActivity(...)</code>方法中处理这些Activity类的.class文件。看下<code>handleActivity(...)</code>的实现细节。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">def</span> handleActivity(ClassPool pool, String activity, String classesDir) &#123;</div><div class="line">        <span class="keyword">def</span> clsFilePath = classesDir + File.separatorChar + activity.replaceAll(<span class="string">'\\.'</span>, <span class="string">'/'</span>) + <span class="string">'.class'</span></div><div class="line">        ...</div><div class="line">        <span class="keyword">def</span> stream, ctCls</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            stream = <span class="keyword">new</span> FileInputStream(clsFilePath)</div><div class="line">            ctCls = pool.makeClass(stream);</div><div class="line"></div><div class="line">            <span class="comment">// ctCls 之前的父类</span></div><div class="line">            <span class="keyword">def</span> originSuperCls = ctCls.superclass</div><div class="line"></div><div class="line">            <span class="comment">/* 从当前 Activity 往上回溯，直到找到需要替换的 Activity */</span></div><div class="line">            <span class="keyword">def</span> superCls = originSuperCls</div><div class="line">            <span class="keyword">while</span> (superCls != <span class="literal">null</span> &amp;&amp; !(superCls.name <span class="keyword">in</span> loaderActivityRules.keySet())) &#123;</div><div class="line">                <span class="comment">// println "&gt;&gt;&gt; 向上查找 $superCls.name"</span></div><div class="line">                ctCls = superCls</div><div class="line">                superCls = ctCls.superclass</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 如果 ctCls 已经是 LoaderActivity，则不修改</span></div><div class="line">            <span class="keyword">if</span> (ctCls.name <span class="keyword">in</span> loaderActivityRules.values()) &#123;</div><div class="line">                <span class="comment">// println "    跳过 $&#123;ctCls.getName()&#125;"</span></div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* 找到需要替换的 Activity, 修改 Activity 的父类为 LoaderActivity */</span></div><div class="line">            <span class="keyword">if</span> (superCls != <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">def</span> targetSuperClsName = loaderActivityRules.get(superCls.name)</div><div class="line">                <span class="comment">// println "    $&#123;ctCls.getName()&#125; 的父类 $superCls.name 需要替换为 $&#123;targetSuperClsName&#125;"</span></div><div class="line">                CtClass targetSuperCls = pool.get(targetSuperClsName)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (ctCls.isFrozen()) &#123;</div><div class="line">                    ctCls.defrost()</div><div class="line">                &#125;</div><div class="line">                ctCls.setSuperclass(targetSuperCls)</div><div class="line"></div><div class="line">                <span class="comment">// 修改声明的父类后，还需要方法中所有的 super 调用。</span></div><div class="line">                ctCls.getDeclaredMethods().each &#123; outerMethod -&gt;</div><div class="line">                    outerMethod.instrument(<span class="keyword">new</span> ExprEditor() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="keyword">void</span> edit(MethodCall call) <span class="keyword">throws</span> CannotCompileException &#123;</div><div class="line">                            <span class="keyword">if</span> (call.isSuper()) &#123;</div><div class="line">                                <span class="keyword">if</span> (call.getMethod().getReturnType().getName() == <span class="string">'void'</span>) &#123;</div><div class="line">                                    String statement = <span class="string">'&#123;super.'</span> + call.getMethodName() + <span class="string">'($$);&#125;'</span></div><div class="line">                                    println <span class="string">"&gt;&gt;&gt; $&#123;outerMethod&#125; call.replace 1 to statement $&#123;statement&#125;"</span></div><div class="line">                                    call.replace(<span class="string">'&#123;super.'</span> + call.getMethodName() + <span class="string">'($$);&#125;'</span>)</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    String statement = <span class="string">'&#123;super.'</span> + call.getMethodName() + <span class="string">'($$);&#125;'</span></div><div class="line">                                    println <span class="string">"&gt;&gt;&gt; $&#123;outerMethod&#125; call.replace 2 to statement $&#123;statement&#125;"</span></div><div class="line">                                    call.replace(<span class="string">'&#123;$_ = super.'</span> + call.getMethodName() + <span class="string">'($$);&#125;'</span>)</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ctCls.writeFile(CommonData.getClassPath(ctCls.name))</div><div class="line">                println <span class="string">"    Replace $&#123;ctCls.name&#125;'s SuperClass $&#123;superCls.name&#125; to $&#123;targetSuperCls.name&#125;"</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            println <span class="string">"    [Warning] --&gt; $&#123;t.toString()&#125;"</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ctCls != <span class="literal">null</span>) &#123;</div><div class="line">                ctCls.detach()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;</div><div class="line">                stream.close()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>ctCls = pool.makeClass(stream)</code>，从文件流中加载.class文件，创建一个CtClass实例，这个实例表示.class文件对应的类或接口。通过CtClass可以很方便的对.class文件进行自定义操作，比如添加方法，改方法参数，添加类成员，改继承关系等。</p>
</li>
<li><code>while (superCls != null &amp;&amp; !(superCls.name in loaderActivityRules.keySet()))</code>，一级级向上遍历ctCls的父类，找到需要替换的Activity类。</li>
<li><p><code>ctCls.setSuperclass(targetSuperCls)</code>，根据初始化中设置的Activity替换规则，修改 此Activity类 的父类为 对应的插件库中的父类。例：<br><code>public class MainActivity extends Activity {</code>修改为<code>public class MainActivity extends PluginActivity {</code></p>
</li>
<li><p><code>if (ctCls.isFrozen()) { ctCls.defrost() }</code>，如果class被冻结，则通过<code>defrost()</code>解冻class，以便class重新允许被修改。<br>注：当CtClass 调用writeFile()、toClass()、toBytecode() 这些方法的时候，Javassist会冻结CtClass Object，将不允许对CtClass object进行修改。</p>
</li>
<li>补充2个 Javassist 知识点：<ul>
<li>如何修改方法体？<br>1.获得一个CtMethod实例，即class中的一个方法。<br>2.调用CtMethod实例的<code>instrument(ExprEditor editor)</code>方法，并传递一个<code>ExprEditor</code>实例(A translator of method bodies.)<br>3.在ExprEditor实例中覆盖<code>edit(MethodCall m)</code>方法，这里可以调用MethodCall的<code>replace()</code>方法来更改方法体内的代码。</li>
<li>修改方法体的原理？<br>调用CtMethod的<code>instrument()</code>，方法体会被逐行进行扫描，从第一行扫描到最后一行。发现有方法调用或表达式时(object creation),<code>edit()</code>会被调用，根据<code>edit()</code>内的<code>replace()</code>方法来修改这一行代码。</li>
</ul>
</li>
<li><code>ctCls.getDeclaredMethods().each { }</code>，经过对修改方法体的背景知识的了解，我们再看这段插桩代码实现就能看懂了：<ul>
<li>遍历class中声明的全部方法</li>
<li>调用每个方法的instrument方法</li>
<li>扫描方法中的每一行表达式，如果这一行表达式的调用方为此类的super类，那么就分两种情况做处理：<br>1.返回类型为void时，调用MethodCall的replace方法，替换这一行代码为<code>super.&#39; + call.getMethodName() + &#39;($$);</code>，其中$$ 是所有方法参数的简写，例如：m($$)等同于m($1,$2,…)。<br>2.返回类型非void时，调用MethodCall的replace方法，替换这一行代码为<code>$_ = super.&#39; + call.getMethodName() + &#39;($$);</code>，其中特殊变量$_代表的是方法的返回值。因为方法调用是有返回值的，所以statement必须将返回值赋值给它，这是javassist.expr.MethodCall方法的明确要求。</li>
</ul>
</li>
<li>Javassist提供了一些特殊的变量来代表特定含义：<br><img src="http://upload-images.jianshu.io/upload_images/1889129-669dc8716e0a9f0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">注：在不同的 javassist 方法中使用时，这些特殊变量代表的含义可能会略有不同。参见：<a href="http://jboss-javassist.github.io/javassist/tutorial/tutorial2.html" target="_blank" rel="external">javassist tutorial</a></li>
<li>全部的类遍历完后，将ctCls对象写回到class文件中。这样就全部完成了class文件的Activity顶级父类动态注入。</li>
<li><code>CtClass.detach()</code>，最后调用detach()方法，把CtClass object 从ClassPool中移除，避免当加载过多的CtClass object的时候，会造成OutOfMemory的异常。因为ClassPool是一个CtClass objects的装载容器。加载CtClass object后，默认是不释放的。</li>
</ul>
<ul>
<li>关于Jar包中的class注入：在initClassPool时已经把Jar做了unzip，解压出也是一堆.class文件，其他处理逻辑同上。也就是说，你引用的第三方sdk中的jar，以及你依赖的库中的jar，都会被注入器撸一遍。<blockquote>
<p>1.如果希望看看具体的代码插桩效果，可以基于<code>dex2jar工具</code>+<code>jd-gui工具</code>逆向你的插件apk。先zip工具解压你的apk，用<code>dex2jar工具</code>从dex拿到完整的jar，然后用<code>jd-gui工具</code>看看jar中的Activity父类是不是神奇的变了。或者直接<code>apktool工具</code>反编译插件apk，看smali文件的改变。<br><img src="http://upload-images.jianshu.io/upload_images/1889129-7783628e7bbecbab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1889129-9274007bcf16e088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1889129-29a5f2ebcba80bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2.可以基于命令行的方式<code>gradlew.bat build</code>编译你的插件应用，然后查看命令行中的编译日志，会有助于你更好的理解。</p>
</blockquote>
</li>
</ul>
<p>##LocalBroadcastInjector<br><code>LocalBroadcastInjector</code>，实现了替换插件中的 LocalBroadcastManager的方法调用 为 插件库的PluginLocalBroadcastManager中的方法调用。<br>直接看<code>injectClass</code>的实现，遍历class目录并访问到文件时，执行以下这段逻辑。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">def</span> injectClass(ClassPool pool, String dir, Map config) &#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 不处理 LocalBroadcastManager.class</span></div><div class="line">		<span class="keyword">if</span> (filePath.contains(<span class="string">'android/support/v4/content/LocalBroadcastManager'</span>)) &#123;</div><div class="line">			println <span class="string">"Ignore $&#123;filePath&#125;"</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		stream = <span class="keyword">new</span> FileInputStream(filePath)</div><div class="line">		ctCls = pool.makeClass(stream);</div><div class="line"></div><div class="line">		<span class="comment">// println ctCls.name</span></div><div class="line">		<span class="keyword">if</span> (ctCls.isFrozen()) &#123;</div><div class="line">			ctCls.defrost()</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* 检查方法列表 */</span></div><div class="line">		ctCls.getDeclaredMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctCls.getMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctCls.writeFile(dir)</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>if (filePath.contains(&#39;android/support/v4/content/LocalBroadcastManager&#39;))</code>，保护性逻辑，避免替换掉v4包中的源码实现。</li>
<li><code>pool.makeClass()</code>，创建当前类文件的CtClass实例。</li>
<li><code>ctCls.defrost()</code> 如果CtClass实例被冻结，则执行解冻操作。</li>
<li><code>ctCls.getDeclaredMethods().each { }</code>和<code>ctCls.getMethods().each { }</code>，遍历全部方法，并执行<code>instrument</code>方法，逐个扫描每个方法体内每一行代码，并交由<code>LocalBroadcastExprEditor</code>的<code>edit()</code>处理对方法体代码的修改。</li>
</ul>
<p><code>LocalBroadcastExprEditor.groovy</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBroadcastExprEditor</span> <span class="keyword">extends</span> <span class="title">ExprEditor</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">def</span> TARGET_CLASS = <span class="string">'android.support.v4.content.LocalBroadcastManager'</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">def</span> PROXY_CLASS = <span class="string">'com.qihoo360.replugin.loader.b.PluginLocalBroadcastManager'</span></div><div class="line"></div><div class="line">    <span class="comment">/** 处理以下方法 */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">def</span> includeMethodCall = [<span class="string">'getInstance'</span>,</div><div class="line">                                    <span class="string">'registerReceiver'</span>,</div><div class="line">                                    <span class="string">'unregisterReceiver'</span>,</div><div class="line">                                    <span class="string">'sendBroadcast'</span>,</div><div class="line">                                    <span class="string">'sendBroadcastSync'</span>]</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">void</span> edit(MethodCall call) <span class="keyword">throws</span> CannotCompileException &#123;</div><div class="line">        <span class="keyword">if</span> (call.getClassName().equalsIgnoreCase(TARGET_CLASS)) &#123;</div><div class="line">            <span class="keyword">if</span> (!(call.getMethodName() <span class="keyword">in</span> includeMethodCall)) &#123;</div><div class="line">                <span class="comment">// println "Skip $methodName"</span></div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            replaceStatement(call)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">def</span> <span class="keyword">private</span> replaceStatement(MethodCall call) &#123;</div><div class="line">        String method = call.getMethodName()</div><div class="line">        <span class="keyword">if</span> (method == <span class="string">'getInstance'</span>) &#123;</div><div class="line">            call.replace(<span class="string">'&#123;$_ = '</span> + PROXY_CLASS + <span class="string">'.'</span> + method + <span class="string">'($$);&#125;'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">def</span> returnType = call.method.returnType.getName()</div><div class="line">            <span class="comment">// getInstance 之外的调用，要增加一个参数，请参看 i-library 的 LocalBroadcastClient.java</span></div><div class="line">            <span class="keyword">if</span> (returnType == <span class="string">'void'</span>) &#123;</div><div class="line">                call.replace(<span class="string">'&#123;'</span> + PROXY_CLASS + <span class="string">'.'</span> + method + <span class="string">'($0, $$);&#125;'</span>)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                call.replace(<span class="string">'&#123;$_ = '</span> + PROXY_CLASS + <span class="string">'.'</span> + method + <span class="string">'($0, $$);&#125;'</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>TARGET_CLASS</code>和<code>PROXY_CLASS</code>分别指定了需要处理的目标类和对应的代理类</li>
<li><code>static def includeMethodCall</code>中定义了需要处理的目标方法名</li>
<li><code>replaceStatement(...)</code>中，替换方法体：<ul>
<li>替换<code>getInstance</code>:<br>1）调用原型：<code>PluginLocalBroadcastManager.getInstance(context);</code><br>2）replace statement：<code>&#39;{$_ = &#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($$);}&#39;</code>，$$表示全部参数的简写。$_表示resulting value即返回值。</li>
<li>替换<code>registerReceiver</code> <code>unregisterReceiver</code> <code>sendBroadcastSync</code>（<code>returnType == &#39;void&#39;</code>）:<br>1）调用原型：<code>PluginLocalBroadcastManager.registerReceiver(instance, receiver, filter);</code><br>2）replace statement：<code>&#39;{&#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($0, $$);}&#39;</code>，$0在这里就不代表this了，而是表示方法的调用方（参见：<a href="http://jboss-javassist.github.io/javassist/tutorial/tutorial2.html" target="_blank" rel="external">javassist tutorial</a>），即PluginLocalBroadcastManager。因为调用原型中需要入参instance（要求是PluginLocalBroadcastManager类型），所以这里必须传入$0。<br>注：<code>unregisterReceiver</code>和<code>sendBroadcastSync</code>同上，调用原型请参见<code>replugin-plugin-lib</code>插件库中的<code>PluginLocalBroadcastManager.java</code>文件。</li>
<li>替换<code>sendBroadcast</code> （<code>returnType != &#39;void&#39;</code>）:<br>1）调用原型：<code>PluginLocalBroadcastManager.sendBroadcast(instance, intent);</code><br>2）replace statement：<code>&#39;{$_ = &#39; + PROXY_CLASS + &#39;.&#39; + method + &#39;($0, $$);}&#39;</code>，传入调用方，全部参数，以及把返回值赋给特殊变量$_。</li>
</ul>
</li>
</ul>
<p>到这里广播注入器的工作就完成了。接下来看看ProviderInjector。</p>
<p>##ProviderInjector<br><code>ProviderInjector</code>，主要用来替换 插件中的 ContentResolver相关的方法调用 为 插件库的PluginProviderClient中的对应方法调用。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理以下方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">def</span> includeMethodCall = [<span class="string">'query'</span>,</div><div class="line">									   <span class="string">'getType'</span>,</div><div class="line">									   <span class="string">'insert'</span>,</div><div class="line">									   <span class="string">'bulkInsert'</span>,</div><div class="line">									   <span class="string">'delete'</span>,</div><div class="line">									   <span class="string">'update'</span>,</div><div class="line">									   <span class="string">'openInputStream'</span>,</div><div class="line">									   <span class="string">'openOutputStream'</span>,</div><div class="line">									   <span class="string">'openFileDescriptor'</span>,</div><div class="line">									   <span class="string">'registerContentObserver'</span>,</div><div class="line">									   <span class="string">'acquireContentProviderClient'</span>,</div><div class="line">									   <span class="string">'notifyChange'</span>,</div><div class="line">]</div></pre></td></tr></table></figure></p>
<ul>
<li><code>static def includeMethodCall</code>中定义了需要处理的目标方法名</li>
</ul>
<p>直接看<code>injectClass</code>的实现，遍历class目录并访问到文件时，执行以下逻辑。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">def</span> injectClass(ClassPool pool, String dir, Map config) &#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		...</div><div class="line"></div><div class="line">		<span class="comment">/* 检查方法列表 */</span></div><div class="line">		ctCls.getDeclaredMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctCls.getMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>ctCls.getDeclaredMethods().each { }</code>和<code>ctCls.getMethods().each { }</code>，遍历全部方法，并执行<code>instrument</code>方法，逐个扫描每个方法体内每一行代码，并交由<code>ProviderExprEditor</code>的<code>edit()</code>处理对方法体代码的修改。</li>
</ul>
<p><code>ProviderExprEditor.groovy</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderExprEditor</span> <span class="keyword">extends</span> <span class="title">ExprEditor</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">def</span> PROVIDER_CLASS = <span class="string">'com.qihoo360.replugin.loader.p.PluginProviderClient'</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">void</span> edit(MethodCall m) <span class="keyword">throws</span> CannotCompileException &#123;</div><div class="line">      ...</div><div class="line">      replaceStatement(m, methodName, m.lineNumber)</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">def</span> <span class="keyword">private</span> replaceStatement(MethodCall methodCall, String method, <span class="keyword">def</span> line) &#123;</div><div class="line">        <span class="keyword">if</span> (methodCall.getMethodName() == <span class="string">'registerContentObserver'</span> || methodCall.getMethodName() == <span class="string">'notifyChange'</span>) &#123;</div><div class="line">            methodCall.replace(<span class="string">'&#123;'</span> + PROVIDER_CLASS + <span class="string">'.'</span> + method + <span class="string">'(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            methodCall.replace(<span class="string">'&#123;$_ = '</span> + PROVIDER_CLASS + <span class="string">'.'</span> + method + <span class="string">'(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;'</span>)</div><div class="line">        &#125;</div><div class="line">        println <span class="string">"&gt;&gt;&gt; Replace: $&#123;filePath&#125; Provider.$&#123;method&#125;():$&#123;line&#125;"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>PROVIDER_CLASS</code>指定了对应的替代实现类</li>
<li><code>replaceStatement(...)</code>中，替换方法体：<ul>
<li>替换<code>registerContentObserver</code>或<code>notifyChange</code> :<br>replace statement：<code>&#39;{&#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;</code>，唯一特别的地方就是入参中传入了特定的context。</li>
<li>替换<code>query</code> 等方法:<br>replace statement：<code>&#39;{$_ = &#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;</code>，因为方法调用是有返回值的，所以statement必须将返回值赋值给特殊变量$_，这是javassist.expr.MethodCall方法的明确要求。</li>
</ul>
</li>
</ul>
<p>到这里Provider注入器的工作就完成了。接下来看看ProviderInjector2。</p>
<p>##ProviderInjector2<br><code>ProviderInjector2</code>，主要用来替换 插件中的 ContentProviderClient 相关的方法调用。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理以下方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">def</span> includeMethodCall = [<span class="string">'query'</span>, <span class="string">'update'</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>static def includeMethodCall</code>中定义了需要处理的目标方法名</li>
</ul>
<p>看下<code>injectClass</code>的实现，遍历class目录并访问到文件时，执行以下这段逻辑。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">def</span> injectClass(ClassPool pool, String dir, Map config) &#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		...</div><div class="line"></div><div class="line">		<span class="comment">/* 检查方法列表 */</span></div><div class="line">		ctCls.getDeclaredMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctCls.getMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>ctCls.getDeclaredMethods().each { }</code>和<code>ctCls.getMethods().each { }</code>，遍历全部方法，并执行<code>instrument</code>方法，逐个扫描每个方法体内每一行代码，并交由<code>ProviderExprEditor2</code>的<code>edit()</code>处理对方法体代码的修改。</li>
</ul>
<p><code>ProviderExprEditor2.groovy</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderExprEditor2</span> <span class="keyword">extends</span> <span class="title">ExprEditor</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">def</span> PROVIDER_CLASS = <span class="string">'com.qihoo360.loader2.mgr.PluginProviderClient2'</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">void</span> edit(MethodCall m) <span class="keyword">throws</span> CannotCompileException &#123;</div><div class="line">      ...</div><div class="line">      replaceStatement(m, methodName, m.lineNumber)</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">def</span> <span class="keyword">private</span> replaceStatement(MethodCall methodCall, String method, <span class="keyword">def</span> line) &#123;</div><div class="line">        methodCall.replace(<span class="string">'&#123;$_ = '</span> + PROVIDER_CLASS + <span class="string">'.'</span> + method + <span class="string">'(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);&#125;'</span>)</div><div class="line">        println <span class="string">"&gt;&gt;&gt; Replace: $&#123;filePath&#125; Provider.$&#123;method&#125;():$&#123;line&#125;"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>PROVIDER_CLASS</code>指定了对应的替代实现类</li>
<li><code>replaceStatement(...)</code>中，替换方法体：<ul>
<li>替换<code>query</code>和<code>update</code>:<br>replace statement：<code>&#39;{$_ = &#39; + PROVIDER_CLASS + &#39;.&#39; + method + &#39;(com.qihoo360.replugin.RePlugin.getPluginContext(), $$);}&#39;</code>，因为方法调用是有返回值的，所以statement必须将返回值赋值给特殊变量$_，这是javassist.expr.MethodCall方法的明确要求。</li>
</ul>
</li>
</ul>
<p>到这里ProviderInjector2注入器的工作就完成了。接下来看看GetIdentifierInjector。</p>
<p>##GetIdentifierInjector<br><code>GetIdentifierInjector</code>，主要用来替换 插件中的 Resource.getIdentifier 方法调用的参数 为 动态适配的参数。</p>
<p>看下<code>injectClass</code>的实现，遍历class目录并访问到文件时，执行以下这段逻辑。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">def</span> injectClass(ClassPool pool, String dir, Map config) &#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		...</div><div class="line"></div><div class="line">		<span class="comment">/* 检查方法列表 */</span></div><div class="line">		ctCls.getDeclaredMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctCls.getMethods().each &#123;</div><div class="line">			it.instrument(editor)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>ctCls.getDeclaredMethods().each { }</code>和<code>ctCls.getMethods().each { }</code>，遍历全部方法，并执行<code>instrument</code>方法，逐个扫描每个方法体内每一行代码，并交由<code>GetIdentifierExprEditor</code>的<code>edit()</code>处理对方法体代码的修改。</li>
</ul>
<p><code>GetIdentifierExprEditor.groovy</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetIdentifierExprEditor</span> <span class="keyword">extends</span> <span class="title">ExprEditor</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">def</span> filePath</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">void</span> edit(MethodCall m) <span class="keyword">throws</span> CannotCompileException &#123;</div><div class="line">        String clsName = m.getClassName()</div><div class="line">        String methodName = m.getMethodName()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (clsName.equalsIgnoreCase(<span class="string">'android.content.res.Resources'</span>)) &#123;</div><div class="line">            <span class="keyword">if</span> (methodName == <span class="string">'getIdentifier'</span>) &#123;</div><div class="line">                m.replace(<span class="string">'&#123; $3 = \"'</span> + CommonData.appPackage + <span class="string">'\"; '</span> +</div><div class="line">                        <span class="string">'$_ = $proceed($$);'</span> +</div><div class="line">                        <span class="string">' &#125;'</span>)</div><div class="line">                println <span class="string">" GetIdentifierCall =&gt; "</span> +<span class="string">'&#123; $3 = \"'</span> + CommonData.appPackage + <span class="string">'\"; '</span> +</div><div class="line">                        <span class="string">'$_ = $proceed($$);'</span> +</div><div class="line">                        <span class="string">' &#125;'</span></div><div class="line">                println <span class="string">" \n"</span>;</div><div class="line">                println <span class="string">" GetIdentifierCall =&gt; $&#123;filePath&#125; $&#123;methodName&#125;():$&#123;m.lineNumber&#125;"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>edit(...)</code>中，遍历到调用方为android.content.res.Resources且方法为getIdentifier的MethodCall，动态适配这些MethodCall中的方法参数：<br>1）调用原型： <code>int id = res.getIdentifier(&quot;com.qihoo360.replugin.sample.demo2:layout/from_demo1&quot;, null, null);</code><br>2）replace statement：<code>&#39;{ $3 = \&quot;&#39; + CommonData.appPackage + &#39;\&quot;; &#39; +&#39;$_ = $proceed($$);&#39; + &#39; }&#39;</code>，为特殊变量$3赋值，即动态修改参数3的值为插件的包名；’$_ = $proceed($$);’表示按原样调用。</li>
</ul>
<p>到此GetIdentifierInjector注入器的工作就已完成，全部的注入器也都遍历完毕并完成了全部的注入工作。</p>
<p>伴随着注入器的遍历结束，整个replugin-plugin-gradle插件的Tansfrom的注入工作完成了，Tansfrom还有一点整理的工作要做，用Tansfrom自然要按照Tansfrom的套路，把处理过的数据输出给下一个Tansfrom。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doTransform(Collection&lt;TransformInput&gt; inputs,</div><div class="line">                    TransformOutputProvider outputProvider,</div><div class="line">                    Object config,</div><div class="line">                    <span class="keyword">def</span> injectors) &#123;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">/* 重打包 */</span></div><div class="line">        repackage()</div><div class="line"></div><div class="line">        <span class="comment">/* 拷贝 class 和 jar 包 */</span></div><div class="line">        copyResult(inputs, outputProvider)</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>repackage()</code>，将解压的 class 文件重新打包，然后删除 class 文件</li>
<li><code>copyResult(...)</code>最终会调用<code>output.getContentLocation(...)</code>，按照Tansfrom的API范式，把处理过的数据输出给下一个Tansfrom。</li>
</ul>
<p>ReclassTansfrom任务完成，将会把输出继续传递给下一个Transfrom<code>transformClassesWithDexFor{ProductFlavor}{BuildType}</code>，把处理权交还给android gradle插件。至此，<code>replugin-plugin-gradle 插件</code>的工作就全部结束了。</p>
<p>##End<br><code>replugin-plugin-gradle 插件</code>是一个compile-time gradle plugin，基于两大核心技术<code>Transform + Javassist</code>，完成了编译期对class文件的动态注入，进而实现动态修改构建目标文件的为replugin插件服务的gradle插件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wangfuda/RePlugin/tree/master/replugin-plugin-gradle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;replugin-plugin-gradle&lt;/a&gt; 是 RePlugin 插件框架中提供给replugin插件用的gradle插件，是一种动态编译方案实现。&lt;br&gt;主要在插件应用的编译期，基于Transform api 注入到编译流程中, 再通过Java字节码类库对编译中间环节的 Java 字节码文件进行修改，以便实现编译期动态修改插件应用的目的。&lt;br&gt;&lt;a href=&quot;https://github.com/Qihoo360/RePlugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RePlugin&lt;/a&gt; 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注 ：文件会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。&lt;/li&gt;
&lt;li&gt;gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-c3f36a60e25128e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="RePlugin" scheme="https://wangfuda.github.io/tags/RePlugin/"/>
    
      <category term="Gradle" scheme="https://wangfuda.github.io/tags/Gradle/"/>
    
      <category term="replugin-plugin-gradle" scheme="https://wangfuda.github.io/tags/replugin-plugin-gradle/"/>
    
  </entry>
  
  <entry>
    <title>replugin源码解析之replugin-host-gradle（宿主的gradle插件）</title>
    <link href="https://wangfuda.github.io/2017/07/15/replugin-host-gradle/"/>
    <id>https://wangfuda.github.io/2017/07/15/replugin-host-gradle/</id>
    <published>2017-07-15T14:53:00.000Z</published>
    <updated>2018-02-25T09:55:43.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/Qihoo360/RePlugin/tree/master/replugin-host-gradle" target="_blank" rel="external">replugin-host-gradle</a> 是 RePlugin 插件框架中的宿主gradle插件，主要用于在宿主应用的编译期常规构建任务流中，插入一些定制化的构建任务，以便实现自动化编译期修改宿主应用的目的。<br><a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="external">RePlugin</a> 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。</p>
</blockquote>
<p>注：文中会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念：</p>
<ul>
<li>replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。</li>
<li>gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。</li>
</ul>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="http://upload-images.jianshu.io/upload_images/1889129-8cf8b272cb126f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="https://github.com/wangfuda/wangfuda.github.io/blob/master/assets/postImg/replugin-host-gradle-flow-en.png" target="_blank" rel="external">结构概览 - 英文高清大图 </a>   ——————   <a href="https://github.com/wangfuda/wangfuda.github.io/blob/master/assets/postImg/replugin-host-gradle-flow.png" target="_blank" rel="external">结构概览 - 中文高清大图</a><br><a id="more"></a></p>
<p>replugin-host-gradle，针对宿主应用执行的构建任务：</p>
<ul>
<li>生成带 RePlugin 插件坑位的 AndroidManifest.xml（允许自定义数量）</li>
<li>生成 RepluginHostConfig 类，方便插件框架读取并自定义其属性</li>
<li>生成 plugins-builtin.json，json中含有插件应用的信息，包名，插件名，插件路径等。</li>
</ul>
<p><code>replugin-host-gradle 插件</code>的构建任务基于{productFlavors}{buildTypes}组合出多维构建任务，在android gradle 插件构建规则内执行构建任务，举个具体的例子：<br>在宿主中配置了 两个渠道<code>{baidu} {xiaomi}</code>，两个编译类型<code>{debug} {release}</code><br>共会生成四种编译组合:<br><code>{baidu}{debug}</code> <code>{xiaomi}{debug}</code> <code>{baidu}{release}</code> <code>{xiaomi}{release}</code><br>每种组合都会执行经由<code>replugin-host-gradle 插件</code>插入或修改到默认构建任务流中的gradle task为：<br><code>rpGenerate{productFlavors}{buildTypes}HostConfig</code> - 生成RePluginHostConfig.java配置文件到buildConfig目录下<br><code>process{productFlavors}{buildTypes}Manifest</code> - 拼装生成 AndroidManifest.xml（坑位组件+原xml中的组件）<br><code>rpGenerate{productFlavors}{buildTypes}BuiltinJson</code> - 生成插件信息文件plugins-builtin.json到assets目录下</p>
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="string">\qihoo\RePlugin\replugin-host-gradle\src</span></div><div class="line"><span class="string">│</span></div><div class="line"><span class="string">└─main</span></div><div class="line">    <span class="string">├─groovy</span></div><div class="line">    <span class="string">│</span>  <span class="string">└─com</span></div><div class="line">    <span class="string">│</span>      <span class="string">└─qihoo360</span></div><div class="line">    <span class="string">│</span>          <span class="string">└─replugin</span></div><div class="line">    <span class="string">│</span>              <span class="string">└─gradle</span></div><div class="line">    <span class="string">│</span>                  <span class="string">└─host</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">AppConstant.groovy</span>				    <span class="comment"># 程序常量定义区</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">RePlugin.groovy</span>				       <span class="comment"># 针对宿主的特定构建任务创建及调度</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  </div><div class="line">    <span class="string">│</span>                      <span class="string">├─creator</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  <span class="string">FileCreators.groovy</span>				<span class="comment"># 组装生成器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  <span class="string">IFileCreator.groovy</span>				<span class="comment"># 文件生成器接口</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">│</span>  </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>  <span class="string">└─impl</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">├─java</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">│</span>      <span class="string">RePluginHostConfigCreator.groovy</span>		<span class="comment"># RePluginHostConfig.java 生成器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">│</span>      </div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>      <span class="string">└─json</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>              <span class="string">PluginBuiltinJsonCreator.groovy</span>		<span class="comment"># plugins-builtin.json 生成器</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>              <span class="string">PluginInfo.groovy</span>				      <span class="comment"># 插件信息模型</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>              <span class="string">PluginInfoParser.groovy</span>				<span class="comment"># 从 manifest 的 xml 中抽取 PluginInfo信息</span></div><div class="line">    <span class="string">│</span>                      <span class="string">│</span>              </div><div class="line">    <span class="string">│</span>                      <span class="string">└─handlemanifest</span></div><div class="line">    <span class="string">│</span>                              <span class="string">ComponentsGenerator.groovy</span>		<span class="comment"># 动态生成插件化框架中需要的组件</span></div><div class="line">    <span class="string">│</span>                              </div><div class="line">    <span class="string">└─resources</span></div><div class="line">        <span class="string">└─META-INF</span></div><div class="line">            <span class="string">└─gradle-plugins</span></div><div class="line">                    <span class="string">replugin-host-gradle.properties</span>				  <span class="comment"># 指定 gradle 插件实现类</span></div></pre></td></tr></table></figure>
<h2 id="replugin-host-gradle的基本用法"><a href="#replugin-host-gradle的基本用法" class="headerlink" title="replugin-host-gradle的基本用法"></a>replugin-host-gradle的基本用法</h2><ul>
<li>添加 RePlugin Host Gradle 依赖<br>在项目根目录的 build.gradle（注意：不是 app/build.gradle） 中添加 replugin-host-gradle 依赖：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.qihoo360.replugin:replugin-host-gradle:2.1.5'</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在项目的app模块中的build.gradle应用插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'replugin-host-gradle'</span></div></pre></td></tr></table></figure></p>
<h2 id="replugin-host-gradle的源码解析"><a href="#replugin-host-gradle的源码解析" class="headerlink" title="replugin-host-gradle的源码解析"></a>replugin-host-gradle的源码解析</h2><p>我们在开始阅读源码前，要思考下，<code>replugin-host-gradle</code>是什么？<br>A:<code>replugin-host-gradle</code>是一个自定义的gradle插件。<br>这个清楚了，那就上车吧。</p>
<blockquote>
<p>讲解replugin-host-gradle源码的同时，还会讲解一些开发自定义gradle插件的知识，希望能和您一起：知其然，亦知其所以然。</p>
</blockquote>
<p><code>replugin-host-gradle.properties</code>文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation-<span class="class"><span class="keyword">class</span></span>=com.qihoo360.replugin.gradle.host.Replugin</div></pre></td></tr></table></figure></p>
<p>在开发自定义gradle插件时，都会先定义这么个文件。这里有 2 个知识点：</p>
<ul>
<li>文件中的<code>implementation-class</code>用来指定插件实现类。</li>
<li>文件名用来指定插件名，即在宿主中使用插件时的<code>apply plugin: &#39;replugin-host-gradle&#39;</code>中的<code>replugin-host-gradle</code>.</li>
</ul>
<p>我们到插件实现类看看这个插件是如何工作的。</p>
<blockquote>
<p>此 gradle 插件基于 groovy 开发，groovy 也是 JVM 系的编程语言，对于 java 系程序员来说，几乎可以闭着眼就开撸代码，不过 gradle 基于 Groovy，build 脚本使用 Groovy 编写，想写出 gradle style 的代码，还是可以去学学这门语言。</p>
</blockquote>
<p><code>RePlugin.groovy</code>文件<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Replugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line">		    println <span class="string">"$&#123;TAG&#125; Welcome to replugin world ! "</span></div><div class="line">            ...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了一个类RePlugin，继承自gradle-api 库中的接口类 Plugin<project> ，实现了apply接口方法，apply方法会在 build.gradle 中执行 apply plugin: ‘replugin-host-gradle’ 时被调用。</project></p>
<p>那我们分小节，循序渐进的看看 apply 方法的具体实现。</p>
<h2 id="预生成AndroidManifest-xml中的组件坑位"><a href="#预生成AndroidManifest-xml中的组件坑位" class="headerlink" title="预生成AndroidManifest.xml中的组件坑位"></a>预生成AndroidManifest.xml中的组件坑位</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line"></div><div class="line">        println <span class="string">"$&#123;TAG&#125; Welcome to replugin world ! "</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.project = project</div><div class="line"></div><div class="line">        <span class="comment">/* Extensions */</span></div><div class="line">        project.extensions.create(AppConstant.USER_CONFIG, RepluginConfig)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</div><div class="line">            android.applicationVariants.all &#123; variant -&gt;</div><div class="line"></div><div class="line">                addShowPluginTask(variant)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</div><div class="line">                    config = project.extensions.getByName(AppConstant.USER_CONFIG)</div><div class="line">                    checkUserConfig(config)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">def</span> appID = variant.generateBuildConfig.appPackageName</div><div class="line">                println <span class="string">"$&#123;TAG&#125; appID: $&#123;appID&#125;"</span></div><div class="line">                <span class="keyword">def</span> newManifest = ComponentsGenerator.generateComponent(appID, config)</div><div class="line"> </div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先向Plugin传递参数，通过<code>project.extensions.create(AppConstant.USER_CONFIG, RepluginConfig)</code>，将RepluginConfig类的常量配置信息赋值给<code>AppConstant.USER_CONFIG</code>，在接下来<code>checkUserConfig(config)</code>检查配置信息时有用到,主要检查配置信息数据类型是否正确。</li>
<li>判断project中是否含有<code>AppPlugin</code>类型插件，即是否有’application’ projects类型的Gradle plugin。我们在宿主项目中是应用了该类型插件的：<code>apply plugin: &#39;com.android.application&#39;</code>.<br>如果希望判断是否有libraryPlugin,可以这样写：<code>if (project.plugins.hasPlugin(LibraryPlugin))</code>，it’s for ‘library’ projects.</li>
<li>获取project中的AppExtension类型extension，即<code>com.android.application</code> projects的android extension.也就是在你的app模块的build.gradle中定义的闭包：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>遍历android extension的Application variants 列表。这里说下，这可以说是 Hook Android gradle 插件的一种方式，因为通过遍历applicationVariants，你可以修改属性，名字，描述，输出文件名等，如果是Android library库，那么就将applicationVariants替换为libraryVariants。很多人可能在build.gradle中这样定义过闭包：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            applicationVariants.all &#123; variant -&gt;</div><div class="line">                variant.outputs.each &#123; output -&gt;</div><div class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</div><div class="line">                    <span class="keyword">def</span> fileName = <span class="string">"xxx_$&#123;variant.productFlavors[0].name&#125;_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;.apk"</span></div><div class="line">                    output.outputFile = <span class="keyword">new</span> File(outputFile.parent, fileName)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实这也是一种插件的创建方式，Hook Android gradle 插件动态修改variants属性值，修改打包输出的apk文件名。<br>创建自定义gradle插件，Gradle提供了多种方式：</p>
<ul>
<li>在build.gradle脚本中直接创建（上述代码即是）</li>
<li>在独立Module中创建（replugin-host-gradle即是）<ul>
<li>继续看代码，<code>addShowPluginTask(variant)</code>这个方法执行了，但是方法内指定的task并未挂到android gradle task上，即task不会执行。这个task是方便调试时查看插件信息的，任务内容同接下来将讲到的<code>生成 plugins-builtin.json 插件信息文件</code>task一致。</li>
<li><code>checkUserConfig(config)</code>，获取到<code>AppConstant.USER_CONFIG</code>内一系列参数后，做数据类型正确性校验。</li>
<li>关键代码来了，下面一行代码，搞定了宿主中AndroidManifest.xml中的组件坑位生成，注意，结合结构概览中的gradle Flow 看，这里只是生成组件坑位的xml代码，最终的xml文件是在后续的task中拼装出来的，稍后会讲到。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> newManifest = ComponentsGenerator.generateComponent(appID, config)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>在代码面前，一切都是纸老虎。上车，进去看如何生成坑位的。</p>
<pre><code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> <span class="keyword">static</span> generateComponent(<span class="keyword">def</span> applicationID, <span class="keyword">def</span> config) &#123;</div><div class="line">		<span class="comment">// 是否使用 AppCompat 库（涉及到默认主题）</span></div><div class="line">		<span class="keyword">if</span> (config.useAppCompat) &#123;</div><div class="line">			themeNTS = THEME_NTS_NOT_APP_COMPAT</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			themeNTS = THEME_NTS_NOT_USE_APP_COMPAT</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">def</span> writer = <span class="keyword">new</span> StringWriter()</div><div class="line">		<span class="keyword">def</span> xml = <span class="keyword">new</span> MarkupBuilder(writer)</div><div class="line"></div><div class="line">		<span class="comment">/* UI 进程 */</span></div><div class="line">		xml.application &#123;</div><div class="line">			<span class="comment">/* 透明坑 */</span></div><div class="line">			config.countTranslucentStandard.times &#123;</div><div class="line">				activity(</div><div class="line">						<span class="string">"$&#123;name&#125;"</span>: <span class="string">"$&#123;applicationID&#125;.$&#123;infix&#125;N1NRTS$&#123;it&#125;"</span>,</div><div class="line">						<span class="string">"$&#123;cfg&#125;"</span>: <span class="string">"$&#123;cfgV&#125;"</span>,</div><div class="line">						<span class="string">"$&#123;exp&#125;"</span>: <span class="string">"$&#123;expV&#125;"</span>,</div><div class="line">						<span class="string">"$&#123;ori&#125;"</span>: <span class="string">"$&#123;oriV&#125;"</span>,</div><div class="line">						<span class="string">"$&#123;theme&#125;"</span>: <span class="string">"$&#123;themeTS&#125;"</span>)</div><div class="line">				...</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			...</div><div class="line"></div><div class="line">			<span class="comment">/* 不透明坑 */</span></div><div class="line">			config.countNotTranslucentStandard.times&#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			...</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 删除 application 标签</span></div><div class="line">		<span class="keyword">def</span> normalStr = writer.toString().replace(<span class="string">"&lt;application&gt;"</span>, <span class="string">""</span>).replace(<span class="string">"&lt;/application&gt;"</span>, <span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="comment">//        println "$&#123;TAG&#125; normalStr: $&#123;normalStr&#125;"</span></div><div class="line"></div><div class="line">		<span class="comment">// 将单进程和多进程的组件相加</span></div><div class="line">		normalStr + generateMultiProcessComponent(applicationID, config)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</code></pre><p>一定要用一句话总结的话，那就是:基于 Groovy 的 MarkupBuilder api，根据 RepluginConfig 类中的配置，拼出组件坑位的xml 字符串。<br>就像搭积木一样，看一组就明白了。<br>生成坑位的代码：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">config.countTranslucentStandard.times &#123;</div><div class="line">                activity(</div><div class="line">                        <span class="string">"$&#123;name&#125;"</span>: <span class="string">"$&#123;applicationID&#125;.$&#123;infix&#125;N1NRTS$&#123;it&#125;"</span>,</div><div class="line">                        <span class="string">"$&#123;cfg&#125;"</span>: <span class="string">"$&#123;cfgV&#125;"</span>,</div><div class="line">                        <span class="string">"$&#123;exp&#125;"</span>: <span class="string">"$&#123;expV&#125;"</span>,</div><div class="line">                        <span class="string">"$&#123;ori&#125;"</span>: <span class="string">"$&#123;oriV&#125;"</span>,</div><div class="line">                        <span class="string">"$&#123;theme&#125;"</span>: <span class="string">"$&#123;themeTS&#125;"</span>)</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>注：<code>config.countTranslucentStandard.times</code> 含义：根据<code>config.countTranslucentStandard</code>的值循环<br>生成的坑位：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line"><span class="symbol">            android:</span>theme=<span class="string">"@ref/0x01030010"</span></div><div class="line"><span class="symbol">            android:</span>name=<span class="string">"com.qihoo360.replugin.sample.host.loader.a.ActivityN1NRTS0"</span></div><div class="line"><span class="symbol">            android:</span>exported=<span class="string">"false"</span></div><div class="line"><span class="symbol">            android:</span>screenOrientation=<span class="string">"1"</span></div><div class="line"><span class="symbol">            android:</span>configChanges=<span class="string">"0x4b0"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>一个字总结：replace.</p>
<blockquote>
<p>Tips. 可以用Android Studio的Analyze APK…功能查看host gradle插件构建后宿主的AndroidManifest.xml，看看生成的坑位的样子就明白了。</p>
</blockquote>
<p>##生成 RePluginHostConfig 配置文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</div><div class="line">            android.applicationVariants.all &#123; variant -&gt;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                <span class="keyword">def</span> variantData = variant.variantData</div><div class="line">                <span class="keyword">def</span> scope = variantData.scope</div><div class="line"></div><div class="line">                <span class="comment">//host generate task</span></div><div class="line">                <span class="keyword">def</span> generateHostConfigTaskName = scope.getTaskName(AppConstant.TASK_GENERATE, <span class="string">"HostConfig"</span>)</div><div class="line">                <span class="keyword">def</span> generateHostConfigTask = project.task(generateHostConfigTaskName)</div><div class="line"></div><div class="line">                generateHostConfigTask.doLast &#123;</div><div class="line">                    FileCreators.createHostConfig(project, variant, config)</div><div class="line">                &#125;</div><div class="line">                generateHostConfigTask.group = AppConstant.TASKS_GROUP</div><div class="line"></div><div class="line">                <span class="comment">//depends on build config task</span></div><div class="line">                String generateBuildConfigTaskName = variant.getVariantData().getScope().getGenerateBuildConfigTask().name</div><div class="line">                <span class="keyword">def</span> generateBuildConfigTask = project.tasks.getByName(generateBuildConfigTaskName)</div><div class="line">                <span class="keyword">if</span> (generateBuildConfigTask) &#123;</div><div class="line">                    generateHostConfigTask.dependsOn generateBuildConfigTask</div><div class="line">                    generateBuildConfigTask.finalizedBy generateHostConfigTask</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>继续回到 apply 方法，接下来该到生成 RePluginHostConfig  的时候了，即 注释中的<code>host generate task</code>。</p>
<ul>
<li>首先生成了 HostConfig 的gradle task 名字，并调用project的task()方法创建此Task。</li>
<li>指定了 generateHostConfigTask 的task任务：自动创建RePluginHostConfig.java至BuildConfig目录。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">generateHostConfigTask.doLast &#123;</div><div class="line">	FileCreators.createHostConfig(project, variant, config)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：<code>createHostConfig(...)</code>方法内的实现，也是根据配置类 <code>RepluginConfig</code>中的配置信息拼装生成的java文件。</p>
<ul>
<li>设置generateHostConfigTask的执行依赖<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//depends on build config task</span></div><div class="line"><span class="keyword">if</span> (generateBuildConfigTask) &#123;</div><div class="line">	generateHostConfigTask.dependsOn generateBuildConfigTask</div><div class="line">	generateBuildConfigTask.finalizedBy generateHostConfigTask</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为此task中创建的RePluginHostConfig.java希望放置到编译输出目录<code>..\replugin-sample\host\app\build\generated\source\buildConfig\{productFlavors}\{buildTypes}\...</code>下，所以此task依赖于生成 BuildConfig.java 的task并设置为 BuildConfigTask 执行完后，就执行HostConfigTask。<br>关于gradle 的 task 相关知识，可以去gradle 官网或某搜索引擎查看学习，属于字典型知识点，需要时候查阅下。</p>
<p>##生成 plugins-builtin.json 插件信息文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</div><div class="line">            android.applicationVariants.all &#123; variant -&gt;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                <span class="comment">//json generate task</span></div><div class="line">                <span class="keyword">def</span> generateBuiltinJsonTaskName = scope.getTaskName(AppConstant.TASK_GENERATE, <span class="string">"BuiltinJson"</span>)</div><div class="line">                <span class="keyword">def</span> generateBuiltinJsonTask = project.task(generateBuiltinJsonTaskName)</div><div class="line"></div><div class="line">                generateBuiltinJsonTask.doLast &#123;</div><div class="line">                    FileCreators.createBuiltinJson(project, variant, config)</div><div class="line">                &#125;</div><div class="line">                generateBuiltinJsonTask.group = AppConstant.TASKS_GROUP</div><div class="line"></div><div class="line">                <span class="comment">//depends on mergeAssets Task</span></div><div class="line">                String mergeAssetsTaskName = variant.getVariantData().getScope().getMergeAssetsTask().name</div><div class="line">                <span class="keyword">def</span> mergeAssetsTask = project.tasks.getByName(mergeAssetsTaskName)</div><div class="line">                <span class="keyword">if</span> (mergeAssetsTask) &#123;</div><div class="line">                    generateBuiltinJsonTask.dependsOn mergeAssetsTask</div><div class="line">                    mergeAssetsTask.finalizedBy generateBuiltinJsonTask</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>继续回到 apply 方法，接下来该到生成 plugins-builtin.json  这个包含了插件信息的文件的时候了，即 注释中的<code>json generate task</code>。</p>
<ul>
<li>首先生成个gradle task 名字，并调用project的task()方法创建此Task。</li>
<li><p>指定了 generateBuiltinJsonTask 的task任务：扫描宿主<code>\assets\plugins</code>目录下的插件文件，并基于apk文件规则解析出插件信息，包名，版本号等，然后拼装成json文件。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">generateBuiltinJsonTask.doLast &#123;</div><div class="line">	FileCreators.createBuiltinJson(project, variant, config)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设置 generateBuiltinJsonTask 的执行依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//depends on build config task</span></div><div class="line"><span class="keyword">if</span> (mergeAssetsTask) &#123;</div><div class="line">	generateBuiltinJsonTask.dependsOn mergeAssetsTask</div><div class="line">	mergeAssetsTask.finalizedBy generateBuiltinJsonTask</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为此task中创建的 plugins-builtin.json 希望放置到编译输出目录<code>...\replugin-sample\host\app\build\intermediates\assets\{productFlavors}\{buildTypes}\...</code>下，所以此task依赖于merge assets文件 的task并设置为 mergeAssetsTask 执行完后，就执行BuiltinJsonTask。</p>
<p>##拼装 AndroidManifest.xml<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output.processManifest.doLast &#123;</div><div class="line">	<span class="keyword">def</span> manifestPath = output.processManifest.outputFile.absolutePath</div><div class="line">	<span class="keyword">def</span> updatedContent = <span class="keyword">new</span> File(manifestPath).getText(<span class="string">"UTF-8"</span>).replaceAll(<span class="string">"&lt;/application&gt;"</span>, newManifest + <span class="string">"&lt;/application&gt;"</span>)</div><div class="line">	<span class="keyword">new</span> File(manifestPath).write(updatedContent, <span class="string">'UTF-8'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>将坑位 xml 字符串 与 原有xml <application></application> 标签内的配置信息合二为一。</li>
</ul>
<p>至此，<code>replugin-host-gradle 插件</code>的工作就全部结束了。</p>
<p>##End<br><code>replugin-host-gradle 插件</code>是一个compile-time gradle plugin，基于赋予android gradle 构建任务流中新的构建任务及修改已有的构建任务，进而实现动态修改构建目标文件的为replugin宿主服务的gradle插件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Qihoo360/RePlugin/tree/master/replugin-host-gradle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;replugin-host-gradle&lt;/a&gt; 是 RePlugin 插件框架中的宿主gradle插件，主要用于在宿主应用的编译期常规构建任务流中，插入一些定制化的构建任务，以便实现自动化编译期修改宿主应用的目的。&lt;br&gt;&lt;a href=&quot;https://github.com/Qihoo360/RePlugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RePlugin&lt;/a&gt; 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：文中会提及两种插件，请阅读本文时注意提及插件的上下文情景，避免混淆概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replugin插件：即replugin插件化框架所指的插件，这个插件指android应用业务拆分出的独立模块，是android应用或模块。&lt;/li&gt;
&lt;li&gt;gradle插件：即gradle构建所需的构建插件，是gradle应用或模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-8cf8b272cb126f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wangfuda/wangfuda.github.io/blob/master/assets/postImg/replugin-host-gradle-flow-en.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;结构概览 - 英文高清大图 &lt;/a&gt;   ——————   &lt;a href=&quot;https://github.com/wangfuda/wangfuda.github.io/blob/master/assets/postImg/replugin-host-gradle-flow.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;结构概览 - 中文高清大图&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="RePlugin" scheme="https://wangfuda.github.io/tags/RePlugin/"/>
    
      <category term="Gradle" scheme="https://wangfuda.github.io/tags/Gradle/"/>
    
      <category term="replugin-host-gradle" scheme="https://wangfuda.github.io/tags/replugin-host-gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义View星空动画的内存占用/GPU渲染性能优化手记</title>
    <link href="https://wangfuda.github.io/2017/07/09/nebula_gpu_monitor_optimize/"/>
    <id>https://wangfuda.github.io/2017/07/09/nebula_gpu_monitor_optimize/</id>
    <published>2017-07-09T00:55:00.000Z</published>
    <updated>2017-07-08T04:11:43.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这是一个关于星空的自定义动画Sample,源码请戳 <a href="https://github.com/wangfuda/nebula" target="_blank" rel="external">https://github.com/wangfuda/nebula</a></p>
</blockquote>
<p>Gif图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-5ec7709da5e2649b.gif?imageMogr2/auto-orient/strip" alt="nebula.gif"><br>本文将重点讲解在本例自定义动画编程中，如何结合 Android Studio 的 Memory Monitor，GPU monitor 按步骤做内存优化，GPU渲染优化。<br>关于动画实现部分，源码已提交至github，请手动阅读理解，注释很详尽。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a9676a7b3d0cfa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br><a id="more"></a></p>
<h2 id="内存占用优化"><a href="#内存占用优化" class="headerlink" title="内存占用优化"></a>内存占用优化</h2><h5 id="内存占用优化-步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi"><a href="#内存占用优化-步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi" class="headerlink" title="内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi."></a>内存占用优化 步骤一：移动图片资源至大分辨率目录下，比如xxxhdpi.</h5><p>先来彪一张直接撸完代码无任何优化的情况下，内存的占用图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-2d0ed671b2b54ec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_1_img_hdpi.png"><br>内存占用246M，不能忍。<br>问：为什么这么大？<br>答：因为资源图都是高清1K分辨率的图。<br>问：为什么这么大？<br>答：。。。<br>那么我们算一下这246M内存占用是怎么来的吧。<br>先来一条图片内存占用计算公式，公式溯源请自行去看源码：BitmapFactory.Java &amp; BitmapFactory.cpp<br>scaledWidth = int( Width <em> targetDensity / density + 0.5)<br>scaledHeight = int( Height </em> targetDensity / density + 0.5)<br>memory = scaledWidth <em> scaledHeight </em> 4<br>其中参数定义如下：</p>
<blockquote>
<p>Width：图片宽<br>Height：图片高<br>targetDensity：加载图片的目标手机的 density，这个值的来源是 DisplayMetrics 的 densityDpi，如果是小米note那么这个数值就是480，详见下图关于targetDensity的参数细节。<br>density：decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 hdpi 是240，xxhdpi 是480）<br>每像素字节数：ARGB8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-11211320242fa8ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="targetDensity.png"></p>
<p>对于一张1080x1920的图来说，放置在hdpi目录，并在小米note手机上（分辨率1080x1920,targetDensity为480），而且均默认以ARGB8888格式加载。<br>内存占用计算公式：<br>scaledWidth = int( 1080<em> 480/ 240+ 0.5) =2160<br>scaledHeight = int( 1920</em> 480/ 240+ 0.5)=3840<br>memory = scaledWidth <em> scaledHeight </em> 4=2160<em>3840</em>4 = 33177600 = 33.17M</p>
<p>一张背景图就占用33M,这个分辨率的图，我们res下一共有7张，还有其他几张小图。这回可以回答为什么占用245M的内存了。</p>
<p>那么内存占用的优化方案也就有了，我们尽量把图片资源放到大分辨率目录下，比如xxxhdpi（当然还有个前提，你的图片分辨率也确实符合大分辨率，否则会出现在大分辨率设备上，显示不全的问题）。</p>
<p>我们来看看把图片资源移动到xxxhdpi目录下后，内存占用情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-104cb4bcc3c4c393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_2_img_move_to_xxxhdpi.png"></p>
<p>把图片资源从hdpi移动到xxx-hdpi，从246M降低到56M,减少了190M，Bingo!</p>
<h5 id="内存占用优化-步骤-二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）"><a href="#内存占用优化-步骤-二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）" class="headerlink" title="内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）"></a>内存占用优化 步骤 二：压缩png图片大小（包体大小会减小，但与内存占用情况无关）</h5><p>初始单张图片大小都接近2M，经过<a href="https://tinypng.com/" target="_blank" rel="external">tinypng</a>优化后，压缩率达到70-80%，非常完美，包体大小减小了，不过，经过我们步骤一的科学计算，这个优化并不会影响图片在内存中的占用。</p>
<h5 id="内存占用优化-步骤-三：动画完成且不再循环展示的部分，相关bitmap释放"><a href="#内存占用优化-步骤-三：动画完成且不再循环展示的部分，相关bitmap释放" class="headerlink" title="内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放"></a>内存占用优化 步骤 三：动画完成且不再循环展示的部分，相关bitmap释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> releaseBitmap &#123;</div><div class="line">  ...</div><div class="line">  bitmap.recycle();</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看下bitmap释放后的memory monitor图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-6b1449a14902af41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_3_release_bitmap.png"></p>
<p>内存占用降低到36M,减少了20M</p>
<h5 id="内存占用优化-步骤-四：无用对象释放，非透明背景图片采用RGB-565颜色格式，并且将图片的inSampleSize设置为2"><a href="#内存占用优化-步骤-四：无用对象释放，非透明背景图片采用RGB-565颜色格式，并且将图片的inSampleSize设置为2" class="headerlink" title="内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2"></a>内存占用优化 步骤 四：无用对象释放，非透明背景图片采用RGB_565颜色格式，并且将图片的inSampleSize设置为2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> releaseValueAnimator &#123;</div><div class="line">  ...</div><div class="line">  valueAnimator = <span class="keyword">null</span>;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> initBitmap &#123;</div><div class="line">  ...</div><div class="line">  localOptions.inSampleSize = <span class="number">2</span>;</div><div class="line">  localOptions.inPreferredConfig = Bitmap.Config.RGB_565;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看下变更图片颜色格式及采样率后的memory monitor图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-cd79479d9c5a1ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_5_bitmap_RGB_565_inSampleSize2.png"></p>
<p>内存占用降低到28M,减少了8M（后来monitor截图只对背景图片做inPreferredConfig调整，内存占用变为30M,相比全部设置为2，增加了2M）</p>
<p>##GPU渲染优化<br>接下来我们要专注于GPU渲染优化了。通过前面几张图，也能看到GPU monitor的状态，非常不乐观，完全达不到帧率刷新的要求：即每帧渲染不超过16ms，每秒可以渲染60帧。<br>先看GPU Monitor的各项指标含义：<br><img src="http://upload-images.jianshu.io/upload_images/1889129-2745cf0df2e05417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gpu_monitor.png"></p>
<blockquote>
<p>Misc Time：表示在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况；出现该线条的时候，可以在Log中看到这样的日志： Skipped xxx frames! The application may be doing too much work on its main thread</p>
<p>Swap Buffers：表示处理任务的时间，也可以说是CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多；</p>
<p>Command Issue：表示执行任务的时间，这部分主要是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，红色线条越高表示需要绘制的视图更多；</p>
<p>Sync：表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小；</p>
<p>Draw：表示测量和绘制视图列表所需要的时间，蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作；</p>
<p>Measure/Layout：表示布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题；</p>
<p>Animation：表示计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等；</p>
<p>Input Handling：表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作；<br>Vsync Delay：见Misc Time</p>
</blockquote>
<h5 id="GPU渲染优化-步骤一：优化内存占用"><a href="#GPU渲染优化-步骤一：优化内存占用" class="headerlink" title="GPU渲染优化 步骤一：优化内存占用"></a>GPU渲染优化 步骤一：优化内存占用</h5><p>可以回过头去看看内存优化过程演进中的Monitor图，随着内存占用的降低，GPU渲染的性能改善也是随之渐进的，所以GPU渲染性能优化，首选就是内存优化</p>
<h5 id="GPU渲染优化-步骤二：能在初始化中做的事，坚决不在onDraw中搞。"><a href="#GPU渲染优化-步骤二：能在初始化中做的事，坚决不在onDraw中搞。" class="headerlink" title="GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。"></a>GPU渲染优化 步骤二：能在初始化中做的事，坚决不在onDraw中搞。</h5><p>在sample代码中重构了onDraw中的画笔的属性设置，绘制区域的创建等代码，这些代码都重构到初始化中。而在onDraw中仅做参数值的动态调整。</p>
<blockquote>
<p>Tips.本例Sample最初始未经过任何优化的代码及最终优化版本代码均在github上可以查看到commit记录，这里不再写详细代码对比，请移动github阅读源码。</p>
</blockquote>
<p>我们看下重构前后的对比图<code>monitor_5_bitmap_RGB_565_inSampleSize2.png</code> Vs <code>monitor_6_gpu_optimize_object_and_paint_create.png</code>，对比发现，GPU渲染耗时明显降低。</p>
<blockquote>
<p>我们暂时先对比看GPU Monitor的 0s ~ 9s 部分的性能改善，目前GPU优化主要在这里体现，因为后半部分各位爷看到了，GPU渲染耗时飙升，掉帧严重，那部分的优化在后续步骤会提到。</p>
</blockquote>
<p>重构前 GPU Monitor：<br><img src="http://upload-images.jianshu.io/upload_images/1889129-e5d6a57904065bb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_5_bitmap_RGB_565_inSampleSize2.png"></p>
<p>重构后 GPU Monitor：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-49cbc9134eafa5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_6_gpu_optimize_object_and_paint_create.png"></p>
<h5 id="GPU渲染优化-步骤三：能用硬件加速，就别关闭它。"><a href="#GPU渲染优化-步骤三：能用硬件加速，就别关闭它。" class="headerlink" title="GPU渲染优化 步骤三：能用硬件加速，就别关闭它。"></a>GPU渲染优化 步骤三：能用硬件加速，就别关闭它。</h5><p>我们都看到了，在GPU Monitor中显示，9s后的GPU渲染，每帧耗时突然飙升，每帧渲染都是超60ms，<br>Draw上升至172ms，Vsync上升至148ms.<br>而且在logcat中也看到日志：<br><code>07-09 11:17:57.135 15980-15980/com.osan.nebula I/Choreographer: Skipped 31 frames!  The application may be doing too much work on its main thread.</code><br>每帧超时，掉帧严重。到底是什么原因呢？经过反复的排查，终于找到原因，我们来聊聊这个飙升的来龙去脉。<br>由于在后半部分的动画中，绘制小星星的光晕效果时，使用的画笔设置了模糊属性，为了给小星星加个光晕效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paintCircleStar.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">10</span>, BlurMaskFilter.Blur.SOLID));</div></pre></td></tr></table></figure></p>
<p>然后google官方文档都说了，硬件加速不支持的UI特效API之一就有它。也就是你要用硬件加速，这个模糊效果就失效。所以我一门心思的为了给小星星加光晕… 光晕…晕…，最后我选择了关闭硬件加速<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawState7</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    canvas.save();</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);<span class="comment">//关闭硬件加速</span></div><div class="line">    canvas.translate(halfWidth, halfHeight);</div><div class="line">    canvas.scale(scale, scale);</div><div class="line">    canvas.rotate(<span class="number">30f</span> * mValue7);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>呵呵，为了小星星，闯祸了。因为本例动画中，各种对画布的旋转，缩放，变换，透明度动态变化，在非硬件加速情况下，不停的重新绘制，是GPU渲染耗时飙升的唯一原因。<br>我们来看看开启硬件加速的情况下，GPU Monitor的指标监控：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a3a8a337954cdd56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_7_gpu_optimize_with_hardware_acce.png"></p>
<p>恢复硬件加速后，渲染耗时立刻恢复到绿线以下，即每帧渲染不超过16ms，达到渲染标准。而且，CPU消耗也明显下降。<br>那么为什么硬件加速有如此神奇之功效？<br>使用硬件加速在对一些view的属性改变上有更高的效率，因为不需要view的invalidate和redrawn。而我们动画中正式大量使用了对属性的改变。属性如:</p>
<blockquote>
<p>透明度：alpha<br>移动：x, y, translationX, translationY<br>缩放：scaleX, scaleY<br>旋转：rotation, rotationX, rotationY<br>坐标：pivotX, pivotY</p>
</blockquote>
<p>注：<br>1）使用硬件加速，对于渲染性能的提示是显著的，API&gt;14后，硬件加速是默认开启的。<br>2）硬件加速还不支持所有的2D绘图命令，开启后可能会影响自定义View和绘图操作。</p>
<h5 id="GPU渲染优化-步骤四：优化算数运算，并尽量从ondraw中移除算数运算"><a href="#GPU渲染优化-步骤四：优化算数运算，并尽量从ondraw中移除算数运算" class="headerlink" title="GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算"></a>GPU渲染优化 步骤四：优化算数运算，并尽量从ondraw中移除算数运算</h5><p>涉及计算任务，能不在ondraw中执行的，就坚决移走，即使只是一个a*b或a/b.<br>因为我们继续重构了onDraw方法，将可能优化的运算代码均做了优化，能放到初始化做的就移到初始化，能提炼共用的运算公式就共用，能不重复算的就绝对不算第二遍。<br>我们来看看优化算数运算后，GPU Monitor的指标监控：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-8f42751a65979c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="monitor_8_gpu_optimize_precalc.png"></p>
<p>相比步骤三中的GPU Monitor指标有了进一步降低，虽然降低幅度很小，但是还是对GPU渲染性能提升有效果的，而且观察发现，优化后，CPU和GPU的指标看起来更平稳。</p>
<p>最后附上一张coding过程中的草图以及nebula自定义动画的截图<br><img src="http://upload-images.jianshu.io/upload_images/1889129-8b9b92dbc97e24d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="craft.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-d7befea486ac77fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/1889129-27590756c3aef735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-a9676a7b3d0cfa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-be5b80a9b8fc343e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1889129-1f4af7330ca64d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一个关于星空的自定义动画Sample,源码请戳 &lt;a href=&quot;https://github.com/wangfuda/nebula&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wangfuda/nebula&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gif图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-5ec7709da5e2649b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;nebula.gif&quot;&gt;&lt;br&gt;本文将重点讲解在本例自定义动画编程中，如何结合 Android Studio 的 Memory Monitor，GPU monitor 按步骤做内存优化，GPU渲染优化。&lt;br&gt;关于动画实现部分，源码已提交至github，请手动阅读理解，注释很详尽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1889129-a9676a7b3d0cfa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="自定义View" scheme="https://wangfuda.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="自定义动画" scheme="https://wangfuda.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB/"/>
    
      <category term="GPU Monior" scheme="https://wangfuda.github.io/tags/GPU-Monior/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2.3.0 源码解析</title>
    <link href="https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/07/01/Retrofit-2.3.0-code-explain/</id>
    <published>2017-07-01T07:24:47.838Z</published>
    <updated>2017-07-01T08:57:42.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> A type-safe HTTP client for Android and Java</p>
</blockquote>
<p>Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。</p>
<p>基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/retrofit/architecture.png" alt="architecture"></p>
<a id="more"></a>
<p>项目结构整体分四个部分，Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall<br>这里我们把基于Retrofit的HTTP通信比做是邮递信件。</p>
<blockquote>
<p>邮递信件</p>
</blockquote>
<ul>
<li>信封：当我们准备好信件之后，要在信封上写邮寄地址，收件人，可能还要备注勿折（是的，我暴露了我的年龄，如今很多人可能都没有过写信寄信的体验）。</li>
<li>邮递员：然后我们亲自去送信吗？No，我们把信投入邮箱，交给邮递员代为送信就行了。</li>
<li>邮局：然后邮递员会根据信封上的信息对信件进行分拣，寄信或收信均经由邮局统一处理</li>
<li>邮寄方式：最后就是交给运送单位送信了，空运或是陆运等。</li>
</ul>
<blockquote>
<p>基于Retrofit的HTTP通信</p>
</blockquote>
<ul>
<li>Builder：当我们准备好数据之后，要指定服务端的通信地址，处理接口地址，请求方法，可能还要备注是否有body、是否是multipart。</li>
<li>Proxy：然后通信的事交给代理去做，代理会帮你做好一系列的工作，比如注解解析，Call适配，以及请求调度等</li>
<li>Invocation：这里负责调度同步或异步请求，请求装配和响应解析</li>
<li>RawCall：这里就是具体的通信工具了，可选Okhttp等框架来做具体的Http通信。</li>
</ul>
<p>来看看寄信和Retrofit之间的对比：<br><img src="/assets/postImg/retrofit/arch_flow.png" alt="arch_flow"></p>
<p>大概过程就是这样，邮递员会把信送出去，并在适合的时机把对方的回信取回来送给你，当然如果你的信件是表白情书，那也很可能会收不到回信的，毕竟表白成功的概率要看人品的。不要伤心，HTTP通信也会有时候收不到服务端的回信噢。</p>
<!--more-->
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><p><a href="http://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">官方 Javadoc</a><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">BuiltInConverters.java</span>					<span class="comment"># 内建Converter</span></div><div class="line"><span class="string">│</span>  <span class="string">Call.java</span>							<span class="comment"># 发送请求接收响应的retrofit方法调用</span></div><div class="line"><span class="string">│</span>  <span class="string">CallAdapter.java</span>						<span class="comment"># 适配Call的响应类型，将默认响应类型R转换为类型T</span></div><div class="line"><span class="string">│</span>  <span class="string">Callback.java</span>						<span class="comment"># 返回服务端或离线请求的响应体</span></div><div class="line"><span class="string">│</span>  <span class="string">Converter.java</span>						<span class="comment"># HTTP交互中，转换对象为数据 或 从数据转换为对象</span></div><div class="line"><span class="string">│</span>  <span class="string">DefaultCallAdapterFactory.java</span>				<span class="comment"># 默认CallAdapter工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">ExecutorCallAdapterFactory.java</span>				<span class="comment"># http请求执行器工厂</span></div><div class="line"><span class="string">│</span>  <span class="string">HttpException.java</span>						<span class="comment"># 非2xx HTTP响应的异常处理</span></div><div class="line"><span class="string">│</span>  <span class="string">OkHttpCall.java</span>						<span class="comment"># 真正调用OkHttp3发送Http请求的类</span></div><div class="line"><span class="string">│</span>  <span class="string">package-info.java</span>						<span class="comment"># 包描述</span></div><div class="line"><span class="string">│</span>  <span class="string">ParameterHandler.java</span>					<span class="comment"># 参数注解解析器</span></div><div class="line"><span class="string">│</span>  <span class="string">Platform.java</span>						<span class="comment"># 平台适配(Java/Android)</span></div><div class="line"><span class="string">│</span>  <span class="string">RequestBuilder.java</span>						<span class="comment"># 请求拼装</span></div><div class="line"><span class="string">│</span>  <span class="string">Response.java</span>						<span class="comment"># 原汁原味的HTTP 响应体，所谓 T body</span></div><div class="line"><span class="string">│</span>  <span class="string">Retrofit.java</span>						<span class="comment"># 组装工厂，基于建造者模式拼装自定义HTTP交互所需的组件，并作为总调度暴露接口</span></div><div class="line"><span class="string">│</span>  <span class="string">ServiceMethod.java</span>						<span class="comment"># 框架核心处理类，注解解析器调度，生成请求(包含api url、path、http请求方法、请</span></div><div class="line">								<span class="comment"># 求头、是否是multipart等等),并返回用于发起http请求的Call对象</span></div><div class="line"><span class="string">│</span>  <span class="string">Utils.java</span>							<span class="comment"># 工具类</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">└─http</span>								<span class="comment"># http注解定义 （直接引用了Javadoc中的描述，均为提高生产力的注解）</span></div><div class="line"></div><div class="line">        <span class="string">Body.java</span>						<span class="comment"># control the request body of a POST/PUT request</span></div><div class="line">        <span class="string">DELETE.java</span>						<span class="comment"># Make a DELETE request</span></div><div class="line">        <span class="string">Field.java</span>						<span class="comment"># Named pair for a form-encoded request</span></div><div class="line">        <span class="string">FieldMap.java</span>						<span class="comment"># Named key/value pairs for a form-encoded request</span></div><div class="line">        <span class="string">FormUrlEncoded.java</span>					<span class="comment"># Denotes that the request body will use form URL encoding</span></div><div class="line">        <span class="string">GET.java</span>						<span class="comment"># Make a GET request</span></div><div class="line">        <span class="string">HEAD.java</span>						<span class="comment"># Make a HEAD request</span></div><div class="line">        <span class="string">Header.java</span>						<span class="comment"># Replaces the header with the value of its target</span></div><div class="line">        <span class="string">HeaderMap.java</span>						<span class="comment"># Adds headers specified in the Map</span></div><div class="line">        <span class="string">Headers.java</span>						<span class="comment"># Adds headers literally supplied in the value</span></div><div class="line">        <span class="string">HTTP.java</span>						<span class="comment"># Use a custom HTTP verb for a request</span></div><div class="line">        <span class="string">Multipart.java</span>						<span class="comment"># Denotes that the request body is multi-part</span></div><div class="line">        <span class="string">OPTIONS.java</span>						<span class="comment"># Make an OPTIONS request</span></div><div class="line">        <span class="string">package-info.java</span>					<span class="comment"># Package description</span></div><div class="line">        <span class="string">Part.java</span>						<span class="comment"># Denotes a single part of a multi-part request</span></div><div class="line">        <span class="string">PartMap.java</span>						<span class="comment"># Denotes name and value parts of a multi-part request</span></div><div class="line">        <span class="string">PATCH.java</span>						<span class="comment"># Make a PATCH request</span></div><div class="line">        <span class="string">Path.java</span>						<span class="comment"># Named replacement in a URL path segment</span></div><div class="line">        <span class="string">POST.java</span>						<span class="comment"># Make a POST request</span></div><div class="line">        <span class="string">PUT.java</span>						<span class="comment"># Make a PUT request</span></div><div class="line">        <span class="string">Query.java</span>						<span class="comment"># Query parameter appended to the URL</span></div><div class="line">        <span class="string">QueryMap.java</span>						<span class="comment"># Query parameter keys and values appended to the URL</span></div><div class="line">        <span class="string">QueryName.java</span>						<span class="comment"># Query parameter appended to the URL that has no value</span></div><div class="line">        <span class="string">Streaming.java</span>						<span class="comment"># Treat the response body on methods returning Response as is, i.e. </span></div><div class="line">								<span class="comment"># without converting body() to byte[]</span></div><div class="line">        <span class="string">Url.java</span>						<span class="comment"># URL resolved against the base URL</span></div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的基本用法"><a href="#Retrofit的基本用法" class="headerlink" title="Retrofit的基本用法"></a>Retrofit的基本用法</h2><p>让我们从基本用法开始，先看如何使用，顺着这个藤，摸摸如何实现的瓜。</p>
<p>用 Java 接口的方式定义一个HTTP API.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Retrofit 类生成一个 GitHubService 接口的实现实例.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>
<p>Each Call from the created GitHubService can make a synchronous or asynchronous HTTP request to the remote webserver.<br>GitHubService实例的每一个方法调用都支持同步或异步HTTP请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure></p>
<p>执行同步或异步HTTP请求，得到HTTP响应数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</div></pre></td></tr></table></figure></p>
<h2 id="Retrofit的源码解析"><a href="#Retrofit的源码解析" class="headerlink" title="Retrofit的源码解析"></a>Retrofit的源码解析</h2><p>首先我们心里要有个概念，Retrofit的核心关键词：注解、动态代理、转换器、适配器</p>
<p>Retrofit就是基于这四个关键词搭建起来的充分解耦，灵活，可插拔的优秀框架。</p>
<p>下面我们结合Retrofit设计图流程来解读代码。 还记得流程吗？ Builder -&gt; Proxy -&gt; Invocation -&gt; RawCall.</p>
<blockquote>
<p>Flow - Builder</p>
</blockquote>
<p><code>Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
    ...
    .build();</code><br><a href="https://en.wikipedia.org/wiki/Builder_pattern" target="_blank" rel="external">Tips.设计模式之Builder模式</a></p>
<p>基于Builder模式,装配一系列零部件，比如base请求地址，gson转换器，Rxjava适配器，HTTP请求client（比如装配OKHTTP）等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java -&gt; class Builder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      </div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">          callbackExecutor, validateEagerly);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>返回一个装配了 callFactory，converterFactories，adapterFactories，callbackExecutor 和指定了 baseUrl 的 Retrofit 实例。<br>注：<code>validateEagerly</code>，用于指定是否预先解析注解，加速接口访问效率。</p>
<blockquote>
<p>Flow - Proxy</p>
</blockquote>
<p><code>GitHubService service = retrofit.create(GitHubService.class);</code><br>我们知道，Java 接口是不可以直接 new 实例的，那么这个 create 方法看起来又像是返回了一个 GitHubService 接口类型的实现实例，这是怎么回事呢？我们来看下 create 的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>create方法主要就一个return,返回了一个Proxy.newProxyInstance生成的动态代理对象。原来这里是通过动态代理的方式生成了 GitHubService 接口的代理实例，那么后续 GitHubService 接口的方法都可以通过代理去调用了。<br>为什么用动态代理？<br>这是Retrofit设计的核心思路，基于动态代理，可以为后续在调用 GitHubService 接口的相关方法时先拦截下来，做完一系列工作后（即注解解析，请求转换，适配等），再去完成方法本尊想要完成的工作，这就是动态代理的魅力。</p>
<blockquote>
<p>Tips.<a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="external">动态代理</a></p>
</blockquote>
<p><code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code><br>通过代理对象 service 调用接口方法 listRepos ，会被动态代理拦截，调用Proxy.newProxyInstance方法中的InvocationHandler对象的 invoke 方法。</p>
<p>invoke中主要由ServiceMethod和CallAdapter完成了三件事：</p>
<ul>
<li>请求方法的注解解析</li>
<li>创建OkHttpCall实例，为后续流程中的HTTP请求执行做准备，详见 Flow - Invocation.</li>
<li>适配Call的响应类型，将默认响应类型R转换为类型T</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p>ServiceMethod.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      callAdapter = createCallAdapter();</div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">      </div><div class="line">	  ...</div><div class="line"></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">        Type parameterType = parameterTypes[p];</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>获取callAdapter、responseType、responseConverter接口对象</p>
<p>解析Method的注解</p>
<p>解析Method的参数注解</p>
<p>解析Method的参数中使用了依赖请求API的动态参数的注解，交由ParameterHandler处理</p>
<p>CallAdapter.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>适配Call的响应类型，将默认响应类型R转换为类型T.比如官方的RxJavaCallAdapter可以结合Rxjava特性对Call的响应做RxJava观察者模式转换，进一步解放生产力。</p>
<p>注：未在Builder阶段指定CallAdapter(如 RxJavaCallAdapterFactory )的情况下，默认的 CallAdapter 不对Call做任何处理。<br>见 DefaultCallAdapterFactory:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CallAdapter.Factory INSTANCE = <span class="keyword">new</span> DefaultCallAdapterFactory();</div><div class="line"></div><div class="line">  ...</div><div class="line">	  ...</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> call;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Flow - Invocation</p>
</blockquote>
<p><code>Response&lt;List&lt;Repo&gt;&gt; response = repos.execute();</code></p>
<p>这一步开始基于同步的方式执行HTTP请求，并得到返回的HTTP响应数据.</p>
<p>本质上是执行了 OkHttpCall 的 execute方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">     </div><div class="line">     ...</div><div class="line">        ...</div><div class="line">          call = rawCall = createRawCall();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parseResponse(call.execute());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，这里创建了RawCall，即真正的去执行HTTP请求任务的对象。<br>这里还负责HTTP请求的响应数据解析。<br>我们看下<code>createRawCall()</code>干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OkHttpCall.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = serviceMethod.toRequest(args);</div><div class="line">    okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> call;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>serviceMethod.toRequest()的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceMethod.java</span></div><div class="line"></div><div class="line"><span class="comment">/** Builds an HTTP request from method arguments. */</span></div><div class="line">  <span class="function">Request <span class="title">toRequest</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,</div><div class="line">        contentType, hasBody, isFormEncoded, isMultipart);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> requestBuilder.build();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>toRequest 方法通过 RequestBuilder 创建了 okhttp3 做 HTTP 请求时需要的 Request 对象。</p>
<p>serviceMethod.callFactory.newCall(request)的功能：<br>建立一个请求通道，为执行HTTP请求做准备。<br>这里callFactory可以由使用者指定，默认为 OkHttpClient，见：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit.java</span></div><div class="line"></div><div class="line">okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>回头看下 OkHttpCall 中 execute 方法最后一句: <code>return parseResponse(call.execute());</code><br>这里调用真正的HTTP请求客户端的请求执行方法。也就是来到了接下来的一个流程。</p>
<blockquote>
<p>Flow - RawCall</p>
</blockquote>
<p>上个 Flow 中最后一步， <code>call.execute()</code>,开启了真正的HTTP请求，即通过 okhttp3 完成HTTP请求。<br>这个部分没什么代码可讲，属于面向接口开发的典范，要讲就该去讲 Okhttp 框架的源码了。</p>
<p>这个部分引出了 Retrofit 的开源拥有者-Square 公司的另一个优秀的开源项目 Okhttp,是不是也很想一探究竟？</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>最后我想拿 Retrofit 官方的一段话来结束：</p>
<p>Contributing</p>
<p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
<p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running mvn clean verify.</p>
<p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>
<p>纳尼？</p>
<p>Cos 我想把亲手画的两副图贡献给 Retrofit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit&lt;/a&gt; A type-safe HTTP client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Retrofit,是一个基于http请求库二次封装的HTTP客户端，将 REST API 转换为 Java 接口。&lt;/p&gt;
&lt;p&gt;基于注解，进一步解放了生产力，使得http请求就像调用方法一样简单，如丝般顺滑。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/retrofit/architecture.png&quot; alt=&quot;architecture&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Retrofit" scheme="https://wangfuda.github.io/tags/Retrofit/"/>
    
      <category term="okhttp" scheme="https://wangfuda.github.io/tags/okhttp/"/>
    
      <category term="http" scheme="https://wangfuda.github.io/tags/http/"/>
    
      <category term="restful api" scheme="https://wangfuda.github.io/tags/restful-api/"/>
    
  </entry>
  
  <entry>
    <title>todo-mvp-dagger 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/todo-mvp-dagger-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-07-01T08:53:39.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>The Android Architecture Blueprints project demonstrates strategies to help solve or avoid these common problems. This project implements the same app using different architectural concepts and tools.</p>
</blockquote>
<p>敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/googlesamples/android-archite
    
    </summary>
    
    
      <category term="mvp" scheme="https://wangfuda.github.io/tags/mvp/"/>
    
      <category term="dagger" scheme="https://wangfuda.github.io/tags/dagger/"/>
    
      <category term="android architecture" scheme="https://wangfuda.github.io/tags/android-architecture/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 源码解读</title>
    <link href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/"/>
    <id>https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/</id>
    <published>2017-05-14T00:55:00.000Z</published>
    <updated>2017-05-14T09:48:44.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="external">HackerNews</a>是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。</p>
</blockquote>
<p>vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。</p>
<h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><p><img src="/assets/postImg/hn-architecture.png" alt="hn-architecture"></p>
<p>项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. </p>
<p>服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。</p>
<p>客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过<code>app.$mount(&#39;#app&#39;)</code>挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行<a href="https://ssr.vuejs.org/en/hydration.html" target="_blank" rel="external">Hydration</a>（合并）</p>
<a id="more"></a>
<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="string">│</span>  <span class="string">manifest.json</span>				<span class="comment"># progressive web apps配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">package.json</span>					<span class="comment"># 项目配置文件</span></div><div class="line"><span class="string">│</span>  <span class="string">server.js</span>					<span class="comment"># 服务端渲染</span></div><div class="line"><span class="string">│</span>  </div><div class="line"><span class="string">├─public</span>                                    	<span class="comment"># 静态资源</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-120.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-144.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-152.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-192.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-384.png</span></div><div class="line"><span class="string">│</span>      <span class="string">logo-48.png</span></div><div class="line"><span class="string">│</span>      </div><div class="line"><span class="string">└─src</span></div><div class="line">    <span class="string">│</span>  <span class="string">app.js</span>					<span class="comment"># 整合 router,filters,vuex 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">App.vue</span>					<span class="comment"># 根 vue 组件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-client.js</span>				<span class="comment"># client 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">entry-server.js</span>				<span class="comment"># server 的入口文件</span></div><div class="line">    <span class="string">│</span>  <span class="string">index.template.html</span>			<span class="comment"># html 模板</span></div><div class="line">    <span class="string">│</span>  </div><div class="line">    <span class="string">├─api</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-client.js</span>			<span class="comment"># Client数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">create-api-server.js</span>			<span class="comment"># server数据源配置</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 数据请求API</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─components</span></div><div class="line">    <span class="string">│</span>      <span class="string">Comment.vue</span>				<span class="comment"># 评论组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Item.vue</span>				<span class="comment"># </span></div><div class="line">    <span class="string">│</span>      <span class="string">ProgressBar.vue</span>			<span class="comment"># 进度条组件</span></div><div class="line">    <span class="string">│</span>      <span class="string">Spinner.vue</span>				<span class="comment"># 加载提示组件</span></div><div class="line">    <span class="string">│</span>     </div><div class="line">    <span class="string">├─router</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># router配置</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─store</span>					<span class="comment"># Vue store模块</span></div><div class="line">    <span class="string">│</span>      <span class="string">actions.js</span>				<span class="comment"># 根级别的 action</span></div><div class="line">    <span class="string">│</span>      <span class="string">getters.js</span>				<span class="comment"># 属性接口</span></div><div class="line">    <span class="string">│</span>      <span class="string">index.js</span>				<span class="comment"># 我们组装模块并导出 store 的地方</span></div><div class="line">    <span class="string">│</span>      <span class="string">mutations.js</span>				<span class="comment"># 根级别的 mutation</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">├─util</span></div><div class="line">    <span class="string">│</span>      <span class="string">filters.js</span>				<span class="comment"># 过滤器</span></div><div class="line">    <span class="string">│</span>      <span class="string">title.js</span>				<span class="comment"># 工具类</span></div><div class="line">    <span class="string">│</span>      </div><div class="line">    <span class="string">└─views</span></div><div class="line">            <span class="string">CreateListView.js</span>			<span class="comment"># 动态生成列表界面的工厂方法</span></div><div class="line">            <span class="string">ItemList.vue</span>			<span class="comment"># List界面组件</span></div><div class="line">            <span class="string">ItemView.vue</span>			<span class="comment"># 单List项组件</span></div><div class="line">            <span class="string">UserView.vue</span>			<span class="comment"># 用户界面组件</span></div></pre></td></tr></table></figure>
<p>本项目包含开发环境及生产环境，我们先学习开发环境。</p>
<h2 id="开发环境的服务端渲染流程"><a href="#开发环境的服务端渲染流程" class="headerlink" title="开发环境的服务端渲染流程"></a>开发环境的服务端渲染流程</h2><p>让我们从node环境下执行命令开始。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line"><span class="string">$npm</span> <span class="string">run</span> <span class="string">dev</span></div></pre></td></tr></table></figure></p>
<p>然后发生了什么？我们来看一张图。<br><img src="/assets/postImg/rundev.png" alt="rundev"></p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">package.json解读</a></p>
</blockquote>
<p>上述执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">···</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"><span class="comment">// 服务端渲染的HTML模板</span></div><div class="line"><span class="keyword">const</span> template = fs.readFileSync(resolve(<span class="string">'./src/index.template.html'</span>), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">  <span class="comment">// 调用vue-server-renderer的createBundleRenderer方法创建渲染器，并设置HTML模板，以后后续将服务端预取的数据填充至模板中</span></div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line"></div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> renderer</div><div class="line"><span class="keyword">let</span> readyPromise</div><div class="line"><span class="keyword">if</span> (isProd) &#123;</div><div class="line">  <span class="comment">// 生产环境下，webpack结合vue-ssr-webpack-plugin插件生成的server bundle</span></div><div class="line">  <span class="keyword">const</span> bundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</div><div class="line">  <span class="comment">//client manifests是可选项，但他允许渲染器自动插入preload/prefetch特性至后续渲染的HTML中，以改善客户端性能</span></div><div class="line">  <span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</div><div class="line">  <span class="comment">//vue-server-renderer创建bundle渲染器并绑定server bundle</span></div><div class="line">  renderer = createRenderer(bundle, &#123;</div><div class="line">    clientManifest</div><div class="line">  &#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回</span></div><div class="line">  <span class="comment">// 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新</span></div><div class="line">  <span class="comment">//以及通过webpack的watch功能实现服务端代码的热更新</span></div><div class="line">  readyPromise = <span class="built_in">require</span>(<span class="string">'./build/setup-dev-server'</span>)(app, (bundle, options) =&gt; &#123;</div><div class="line">	<span class="comment">// 基于热更新，回调生成最新的bundle渲染器</span></div><div class="line">    renderer = createRenderer(bundle, options)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//依次装载一系列Express中间件，用来处理静态资源，数据压缩等</span></div><div class="line">···</div><div class="line">app.use(···)</div><div class="line">···</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  ···</div><div class="line"> </div><div class="line">  <span class="comment">// 设置请求的url</span></div><div class="line">  <span class="keyword">const</span> context = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'Vue HN 2.0'</span>, <span class="comment">// default title</span></div><div class="line">    url: req.url</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 为渲染器绑定的server bundle（即entry-server.js）设置入参context</span></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    ···</div><div class="line">    res.end(html)</div><div class="line">	···</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//启动一个服务并监听从 8080 端口进入的所有连接请求。</span></div><div class="line">app.get(<span class="string">'*'</span>, isProd ? render : <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">  readyPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> render(req, res))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">8080</span></div><div class="line">app.listen(port, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`server started at localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips<br>1.<a href="https://ssr.vuejs.org" target="_blank" rel="external">vue-server-renderer</a>(Vue服务端渲染，同时支持prefetch、prerender特性)<br>2.<a href="https://webpack.js.org/guides/development/#webpack-dev-server" target="_blank" rel="external">webpack-dev-server</a>(webpack-dev-middleware/webpack-hot-middleware)<br>3.此项目全面使用<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6语法</a>，包括箭头函数，解构赋值，Promise等特性。</p>
</blockquote>
<p><code>server.js</code>最终监听8080端口等待处理客户端请求，此时在浏览器访问localhost:8080<br>请求经由<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">express</a>路由接收后，执行处理逻辑:<code>readyPromise.then(() =&gt; render(req, res))</code><br>沿着Promise的调用链处理：<br>开发环境下<br>1.调用setup-dev-server.js 模块，根据上图中webpack config文件实现入口文件打包，热替换功能实现。<br>最终通过回调把生成在内存中的server bundle传回。<br>2.创建渲染器，绑定server bundle，设置渲染模板，缓存等<br>3.依次装载一系列Express中间件，用来处理静态资源，数据压缩等<br>4.最后将渲染好的HTML写入http响应体，传回浏览器。</p>
<p>接下来分解解读下这几个的实现。</p>
<h3 id="setup-dev-server"><a href="#setup-dev-server" class="headerlink" title="setup-dev-server"></a>setup-dev-server</h3><p>看一张server.js的模块依赖关系图，只看项目自文件依赖即可（黄色）<br><img src="/assets/postImg/serverjs.png" alt="serverjs"></p>
<p><code>build/setup-dev-server.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setup-dev-server.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'./webpack.client.config'</span>)</div><div class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'./webpack.server.config'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">setupDevServer</span> (<span class="params">app, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> bundle, clientManifest</div><div class="line">  <span class="keyword">let</span> resolve</div><div class="line">  <span class="keyword">const</span> readyPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123; resolve = r &#125;)</div><div class="line">  <span class="keyword">const</span> ready = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">    resolve()</div><div class="line">    cb(...args)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem</span></div><div class="line">  <span class="comment">// 读取内存中的bundle 并通过传入的回调更新server.js中的bundle</span></div><div class="line">  clientCompiler.plugin(<span class="string">'done'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> fs = devMiddleware.fileSystem</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> fs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line">    clientManifest = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-client-manifest.json'</span>))</div><div class="line">    <span class="keyword">if</span> (bundle) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// hot middleware</span></div><div class="line">  app.use(<span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(clientCompiler))</div><div class="line"></div><div class="line">  <span class="comment">// watch and update server renderer</span></div><div class="line">  <span class="keyword">const</span> serverCompiler = webpack(serverConfig)</div><div class="line">  <span class="comment">// 获取基于memory-fs创建的内存文件系统对象</span></div><div class="line">  <span class="keyword">const</span> mfs = <span class="keyword">new</span> MFS()</div><div class="line">  serverCompiler.outputFileSystem = mfs</div><div class="line">  <span class="comment">// 设置文件重新编译监听并通过传入的回调更新server.js中的bundle</span></div><div class="line">  serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">    stats = stats.toJson()</div><div class="line">    stats.errors.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div><div class="line">    stats.warnings.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.warn(err))</div><div class="line">    <span class="keyword">const</span> readFile = <span class="function"><span class="params">file</span> =&gt;</span> mfs.readFileSync(path.join(clientConfig.output.path, file), <span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// read bundle generated by vue-ssr-webpack-plugin</span></div><div class="line">    bundle = <span class="built_in">JSON</span>.parse(readFile(<span class="string">'vue-ssr-server-bundle.json'</span>))</div><div class="line">    <span class="keyword">if</span> (clientManifest) &#123;</div><div class="line">      ready(bundle, &#123;</div><div class="line">        clientManifest</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> readyPromise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.base.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.base.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map</span></div><div class="line">  devtool: isProd</div><div class="line">    ? <span class="literal">false</span></div><div class="line">    : <span class="string">'#cheap-module-source-map'</span>,</div><div class="line">  <span class="comment">// 打包输出配置</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    <span class="attr">publicPath</span>: <span class="string">'/dist/'</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[chunkhash].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'public'</span>: path.resolve(__dirname, <span class="string">'../public'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line"></div><div class="line">    ···</div><div class="line">	<span class="comment">// 一系列加载器</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="attr">plugins</span>:[</div><div class="line">    <span class="comment">// 压缩js的插件</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      <span class="attr">compress</span>: &#123; <span class="attr">warnings</span>: <span class="literal">false</span> &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来</span></div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>build/webpack.client.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.client.config.js</span></div><div class="line"></div><div class="line"><span class="comment">// 基于webpack-merge工具合并base以及client特定配置项</span></div><div class="line"><span class="keyword">const</span> config = merge(base, &#123;</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: &#123;</div><div class="line">    <span class="attr">app</span>: <span class="string">'./src/entry-client.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置客户端数据请求API为create-api-client.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-client.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"client"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 设置打包时公共模块的提取规则</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="attr">minChunks</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">        <span class="comment">// a module is extracted into the vendor chunk if...</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="comment">// it's inside node_modules</span></div><div class="line">          /node_modules/.test(<span class="built_in">module</span>.context) &amp;&amp;</div><div class="line">          <span class="comment">// and not a CSS file (due to extract-text-webpack-plugin limitation)</span></div><div class="line">          !<span class="regexp">/\.css$/</span>.test(<span class="built_in">module</span>.request)</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 因为 webpack 在编译打包时都会生成一个 webpack runtime 代码，因为 wepack 允许设置一个未指定的name，</span></div><div class="line">    <span class="comment">// 来独立提取 runtime 代码,从而避免每次编译都会导致 vendor chunk hash 值变更</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'manifest'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> VueSSRClientPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>bulid/webpack.server.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// build/webpack.server.config.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</div><div class="line">  <span class="comment">// 指定生成后的运行环境在node</span></div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  <span class="comment">// 设置代码调试map</span></div><div class="line">  devtool: <span class="string">'#source-map'</span>,</div><div class="line">  <span class="comment">// 配置编译的入口文件</span></div><div class="line">  entry: <span class="string">'./src/entry-server.js'</span>,</div><div class="line">  <span class="comment">// 设置输出文件名，并设置模块导出为commonjs2类型</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'server-bundle.js'</span>,</div><div class="line">    <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在alias设置好服务端数据请求API为create-api-server.js模块</span></div><div class="line">  resolve: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="string">'create-api'</span>: <span class="string">'./create-api-server.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置不打包排除规则</span></div><div class="line">  externals: nodeExternals(&#123;</div><div class="line">    <span class="comment">// do not externalize CSS files in case we need to import it from a dep</span></div><div class="line">    whitelist: <span class="regexp">/\.css$/</span></div><div class="line">  &#125;),</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">	<span class="comment">// 设置环境变量</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'development'</span>),</div><div class="line">      <span class="string">'process.env.VUE_ENV'</span>: <span class="string">'"server"'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">//设置VueSSRServerPlugin插件</span></div><div class="line">    <span class="keyword">new</span> VueSSRServerPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上，基于 webpack config 的<code>setup-dev-server</code>就到这里，接下来说<code>创建渲染器</code>。</p>
<h3 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">bundle, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`createRenderer`</span>)</div><div class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, <span class="built_in">Object</span>.assign(options, &#123;</div><div class="line">    template,</div><div class="line">   </div><div class="line">	···</div><div class="line"></div><div class="line">  &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建渲染器时重点两件事：<br>1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件<code>entry-server.js</code>打包生成的。<br>当渲染器调用<code>renderer.renderToString</code>开始渲染时，会执行该入口文件的默认方法。<br>2.传入了一个html模板<code>index.template.html</code>，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。</p>
<blockquote>
<p>Tips:<a href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/">index.template.html解读</a></p>
</blockquote>
<p>顺着readyPromise.then的调用链，接下来调用render方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">···</div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line">    res.end(html)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>renderer.renderToString</code>方法内部会先调用入口模块<code>entry-server.js</code>的默认方法，我们看下<code>entry-server.js</code>主要做了什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This exported function will be called by `bundleRenderer`.</span></div><div class="line"><span class="comment">// This is where we perform data-prefetching to determine the</span></div><div class="line"><span class="comment">// state of our application before actually rendering it.</span></div><div class="line"><span class="comment">// Since data fetching is async, this function is expected to</span></div><div class="line"><span class="comment">// return a Promise that resolves to the app instance.</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> s = isDev &amp;&amp; <span class="built_in">Date</span>.now()</div><div class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</div><div class="line"></div><div class="line">    <span class="comment">// set router's location</span></div><div class="line">    <span class="comment">// 手动路由切换到请求的url，即'/'</span></div><div class="line">    router.push(context.url)</div><div class="line"></div><div class="line">    <span class="comment">// wait until router has resolved possible async hooks</span></div><div class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 获取该url路由下的所有Component，这些组件定义在Vue Router中。 /src/router/index.js</span></div><div class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</div><div class="line">      <span class="comment">// no matched routes</span></div><div class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</div><div class="line">        reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Call fetchData hooks on components matched by the route.</span></div><div class="line">      <span class="comment">// A preFetch hook dispatches a store action and returns a Promise,</span></div><div class="line">      <span class="comment">// which is resolved when the action is complete and store state has been</span></div><div class="line">      <span class="comment">// updated.</span></div><div class="line">      <span class="comment">// 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据</span></div><div class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> component.asyncData &amp;&amp; component.asyncData(&#123;</div><div class="line">          store,</div><div class="line">          <span class="attr">route</span>: router.currentRoute</div><div class="line">        &#125;)</div><div class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        isDev &amp;&amp; <span class="built_in">console</span>.log(<span class="string">`data pre-fetch: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - s&#125;</span>ms`</span>)</div><div class="line">        <span class="comment">// After all preFetch hooks are resolved, our store is now</span></div><div class="line">        <span class="comment">// filled with the state needed to render the app.</span></div><div class="line">        <span class="comment">// Expose the state on the render context, and let the request handler</span></div><div class="line">        <span class="comment">// inline the state in the HTML response. This allows the client-side</span></div><div class="line">        <span class="comment">// store to pick-up the server-side state without having to duplicate</span></div><div class="line">        <span class="comment">// the initial data fetching on the client.</span></div><div class="line">        <span class="comment">// 把vuex的state设置到传入的context.initialState上</span></div><div class="line">        context.state = store.state</div><div class="line">        <span class="comment">// 返回state, router已经设置好的Vue实例app</span></div><div class="line">        resolve(app)</div><div class="line">      &#125;).catch(reject)</div><div class="line">    &#125;, reject)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>entry-server.js</code>的主要工作：<br>0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。<br>1.手动路由切换到请求的url，即’/‘<br>2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据<br>3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js）</p>
<blockquote>
<p>Tips:下一章节我们会详细介绍这部分内容实现 稍后见于：<code>服务端渲染时的数据预取流程</code></p>
</blockquote>
<p>还记得<code>index.template.html</code>被设置到<code>template</code>属性中吗？<br>此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就是这里，这个<code>&lt;!--vue-ssr-outlet--&gt;</code>Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。<br>如果改动，服务端渲染时会有错误提示：<code>Error: Content placeholder not found in template.</code></p>
<p>接下来，Vue渲染器会回调callback方法，我们回到<code>server.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">	</div><div class="line">  ···</div><div class="line"></div><div class="line">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class="line"></div><div class="line">    res.end(html)</div><div class="line"></div><div class="line">    ···</div><div class="line"></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时只需要将渲染好的<code>html</code>写入http响应体就结束了，浏览器客户端就可以看到页面了。</p>
<p>接下来我们看看服务端数据预取的实现</p>
<h2 id="服务端渲染时的数据预取流程"><a href="#服务端渲染时的数据预取流程" class="headerlink" title="服务端渲染时的数据预取流程"></a>服务端渲染时的数据预取流程</h2><p>上文提到，服务端渲染时，会手动将路由导航到请求地址即<code>&#39;/&#39;</code>下，然后调用该路由组件的asyncData方法来预取数据</p>
<p>那么我们看看路由配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/router/index.js</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="comment">// route-level code splitting</span></div><div class="line"><span class="keyword">const</span> createListView = <span class="function"><span class="params">id</span> =&gt;</span> () =&gt; System.import(<span class="string">'../views/CreateListView'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.default(id))</div><div class="line"><span class="keyword">const</span> ItemView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/ItemView.vue'</span>)</div><div class="line"><span class="keyword">const</span> UserView = <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'../views/UserView.vue'</span>)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">    <span class="attr">mode</span>: <span class="string">'history'</span>,</div><div class="line">    <span class="attr">scrollBehavior</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</div><div class="line">    <span class="attr">routes</span>: [</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/top/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'top'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/new/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'new'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/show/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'show'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/ask/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'ask'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/job/:page(\\d+)?'</span>, <span class="attr">component</span>: createListView(<span class="string">'job'</span>) &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/item/:id(\\d+)'</span>, <span class="attr">component</span>: ItemView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: UserView &#125;,</div><div class="line">      &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/top'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>地址<code>&#39;/&#39;</code>是做了redirect到<code>&#39;/top&#39;</code>,其实就是默认地址就是到top页面，在看第一条路由配置，<code>&#39;/top&#39;</code>路由对应的组件是<code>createListView(&#39;top&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createListView</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;type&#125;</span>-stories-view`</span>,</div><div class="line"></div><div class="line">    asyncData (&#123; store &#125;) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView asyncData`</span>)</div><div class="line">      <span class="keyword">return</span> store.dispatch(<span class="string">'FETCH_LIST_DATA'</span>, &#123; type &#125;)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">title</span>: camelize(type),</div><div class="line"></div><div class="line">    render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Tips: <a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">Vuex状态管理</a><br>1.dispatch对应Action，commit对应mutation<br>2.Action 类似于 mutation，不同在于：Action是异步事件，mutation是同步事件。</p>
</blockquote>
<p><code>Vuex state状态变更流程</code><br><img src="/assets/postImg/vuex_state.jpg" alt="vuex_state"></p>
<p>asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store.</p>
<p>最后数据就都保存在store这里了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/store/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">      <span class="attr">activeType</span>: <span class="literal">null</span>,</div><div class="line">      <span class="attr">itemsPerPage</span>: <span class="number">20</span>,</div><div class="line">      <span class="attr">items</span>: &#123;<span class="comment">/* [id: number]: Item */</span>&#125;,</div><div class="line">      <span class="attr">users</span>: &#123;<span class="comment">/* [id: string]: User */</span>&#125;,</div><div class="line">      <span class="attr">lists</span>: &#123;</div><div class="line">        <span class="attr">top</span>: [<span class="comment">/* number */</span>],</div><div class="line">        <span class="attr">new</span>: [],</div><div class="line">        <span class="attr">show</span>: [],</div><div class="line">        <span class="attr">ask</span>: [],</div><div class="line">        <span class="attr">job</span>: []</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    actions,</div><div class="line">    mutations,</div><div class="line">    getters</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将开始通过<a href="https://cn.vuejs.org/v2/guide/render-function.html#main" target="_blank" rel="external">Render 函数</a>创建HTML。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/views/CreateListView.js</span></div><div class="line"></div><div class="line">render (h) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`createListView render`</span>)</div><div class="line">      <span class="keyword">return</span> h(ItemList, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// /src/views/ItemList.vue</div><div class="line">···</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-view"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list-nav"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"page &gt; 1"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page - 1)"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>&amp;lt; prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">"hasMore"</span> <span class="attr">:to</span>=<span class="string">"'/' + type + '/' + (page + 1)"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"disabled"</span>&gt;</span>more &amp;gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"transition"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-list"</span> <span class="attr">:key</span>=<span class="string">"displayedPage"</span> <span class="attr">v-if</span>=<span class="string">"displayedPage &gt; 0"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">v-for</span>=<span class="string">"item in displayedItems"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span> <span class="attr">:item</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line">···</div></pre></td></tr></table></figure>
<p>这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的<code>&lt;!--vue-ssr-outlet--&gt;</code>,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。</p>
<blockquote>
<p>Tips:<br>后续更新内容规划：<br>1.生产环境下的服务端渲染逻辑流程<br>2.客户端渲染逻辑流程<br>3.客户端vue组件细节解读</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-hackernews-2.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HackerNews&lt;/a&gt;是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-hackernews项目，涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。这也是写这个项目解读的初衷，希望为阅读该项目提供一些指引。&lt;/p&gt;
&lt;h2 id=&quot;结构概览&quot;&gt;&lt;a href=&quot;#结构概览&quot; class=&quot;headerlink&quot; title=&quot;结构概览&quot;&gt;&lt;/a&gt;结构概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/postImg/hn-architecture.png&quot; alt=&quot;hn-architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. &lt;/p&gt;
&lt;p&gt;服务端：当 Node Server 收到来自Browser的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的Vue实例，接下来Vue渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的html发送到浏览器。&lt;/p&gt;
&lt;p&gt;客户端：Browser收到HTML后，客户端加载了 client bundle(即entry-client.js) ，通过&lt;code&gt;app.$mount(&amp;#39;#app&amp;#39;)&lt;/code&gt;挂载Vue实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML 进行&lt;a href=&quot;https://ssr.vuejs.org/en/hydration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hydration&lt;/a&gt;（合并）&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue-hackernews-2.0 细节解读</title>
    <link href="https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/"/>
    <id>https://wangfuda.github.io/2017/05/13/vue-hackernews-2.0-code-detail/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2017-05-13T12:47:02.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对<a href="https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/">项目源码解读</a>的细节补充。</p>
<h2 id="package-json解读"><a href="#package-json解读" class="headerlink" title="package.json解读"></a>package.json解读</h2><p>该文件提供了四种命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install dependencies</span></div><div class="line">npm install <span class="comment"># or yarn</span></div><div class="line"></div><div class="line"><span class="comment"># serve in dev mode, with hot reload at localhost:8080</span></div><div class="line">npm run dev</div><div class="line"></div><div class="line"><span class="comment"># build for production</span></div><div class="line">npm run build</div><div class="line"></div><div class="line"><span class="comment"># serve in production mode</span></div><div class="line">npm start</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>执行<code>npm install</code><br>查找package.json中的dependencies和devDependencies字段，然后依次安装里面的模块。</p>
<blockquote>
<p>Tips:dependencies与devDependencies的区别<br>devDependencies下的模块，是开发环境需要的依赖项，主要是webpack打包，js语言转码(ES6代码转为ES5代码)等模块，这些模块不会被部署到生产环境。<br>dependencies下的模块，是生产环境需要的依赖项，即运行该包时所需要的依赖项。<br>这里可能有疑问，难道生产环境不需要webpack，js语言转码等模块吗？<br>答案是：需要，但这些模块不需要部署到生产环境，仅仅在生成生产环境所需的部署文件时被使用。</p>
</blockquote>
<p>执行<code>npm run dev</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line"><span class="string">"dev"</span>: <span class="string">"node server"</span>,</div><div class="line"><span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node server"</span>,</div><div class="line"><span class="string">"build"</span>: <span class="string">"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server"</span>,</div><div class="line"><span class="string">"build:client"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress --hide-modules"</span>,</div><div class="line"><span class="string">"build:server"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress --hide-modules"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>查找package.json中的scripts字段对应的对象，找到dev属性，并执行dev属性对应的脚本：<code>node server</code>即<code>node server.js</code>，即执行server.js</p>
<p>执行<code>npm run build</code><br>同样，找到build属性，并执行：<code>rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server</code>，即删除dist目录并执行<code>npm run build:client</code>和<code>npm run build:server</code><br>对应功能是：设置环境变量为production，同时webpack根据config.js配置打包生产环境所需的部署文件</p>
<p>执行<code>npm start</code><br>同样，找到start属性，并执行：<code>cross-env NODE_ENV=production node server</code>，即通过cross-env模块设置NODE_ENV环境变量为production，并执行<code>node server</code></p>
<blockquote>
<p>Tips:为什么是<code>npm start</code>而不是<code>npm run start</code>?<br>1.两者都可以，因为start为npm内置支持的命令，所以可以直接执行，参见<code>npm --help</code><br>2.其他三个命令都不是内置命令，需要经由<code>npm run</code>去执行。</p>
</blockquote>
<h2 id="index-template-html解读"><a href="#index-template-html解读" class="headerlink" title="index.template.html解读"></a>index.template.html解读</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">sizes</span>=<span class="string">"48x48"</span> <span class="attr">href</span>=<span class="string">"/public/logo-48.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#f60"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这段html代码功能：移动端浏览器适配及PWA适配</p>
<blockquote>
<p>Tips:<a href="https://developer.mozilla.org/en-US/Apps/Progressive" target="_blank" rel="external">PWA (progressive web apps)</a>-本质上仍然是个网站，但允许直接被放置到移动设备的桌面上（例如通过chrome浏览器的Add to HomeScreen），而不需要用户去app store下载安装应用才能使用，而这与一个网址的快捷方式完全不同，因为这种web app提供了一种接近原生app的用户体验。</p>
</blockquote>
<p>接下来我们在手机(Nexus 6P/Android 7.1)上分别示范下浏览器体验及PWA体验分别是怎样的。<br>浏览器体验：<br>在Chrome浏览器地址栏中输入项目地址，效果如下：</p>
<p><img src="/assets/postImg/open_by_chrome.png" alt="open_by_chrome"></p>
<p>PWA体验：<br>通过Chrome的<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="external">Add to Homescreen</a>功能，将该站点添加到桌面。效果如下：</p>
<p><img src="/assets/postImg/chrome_menu.png" alt="chrome_menu">  <img src="/assets/postImg/chrome_menu_add_to_homescrren.png" alt="chrome_menu_add_to_homescrren">  <img src="/assets/postImg/chrome_add_to_homescrren_pwa.png" alt="chrome_add_to_homescrren_pwa">  </p>
<p>点击桌面生成的应用图标后，可以看到具备了过渡启动图界面，而且进入后，不再是浏览器内看网站的体验，地址栏消失了，看起来像是一个原生应用。</p>
<p><img src="/assets/postImg/pwa_flash_white.png" alt="pwa_flash_white">  <img src="/assets/postImg/pwa_homepage.png" alt="pwa_homepage"></p>
<p>现在我们对manifest.json配置做一下改动，来学习几个参数的作用。以下三张电机图标后的启动图界面变更分别对应manifest.json的如下三种配置改动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 主题色：绿色 启动图背景色：白色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f2f3f5"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//2. 主题色：绿色 启动图背景色：绿色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#48BB74"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#48BB74"</span></div><div class="line"><span class="comment">//3. 主题色：橙色 启动图背景色：橙色</span></div><div class="line"><span class="string">"background_color"</span>: <span class="string">"#f60"</span>,</div><div class="line"><span class="string">"display"</span>: <span class="string">"standalone"</span>,</div><div class="line"><span class="string">"theme_color"</span>: <span class="string">"#f60"</span></div></pre></td></tr></table></figure></p>
<p><img src="/assets/postImg/pwa_flash.png" alt="pwa_flash">  <img src="/assets/postImg/pwa_flash_green.png" alt="pwa_flash_green">  <img src="/assets/postImg/pwa_flash_orange.png" alt="pwa_flash_orange"></p>
<blockquote>
<p>Tips:<br>这里用到的<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="external">manifest.json</a>不要与作为离线缓存的<a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">manifest</a>混淆。</p>
</blockquote>
<p>最后来对比感受下<code>非PWA的百度站点</code>Vs<code>PWA站点的hackernews</code>在Add to HomeScreen后，体验上的差异。</p>
<p><img src="/assets/postImg/pwa.gif" alt="pwa.gif"></p>
<p>概括下主要的差异：<br>1.增加了同原生应用一样的启动图过渡界面<br>2.进入站点后，像是原生应用一样，没有了地址栏等浏览器体验的痕迹。<br>3.从点击图标开始到浏览页面，整体的体验上，PWA更接近原生应用。<br>注：PWA更多的特性这里并未应用，其实PWA可以做的更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文按源码文件分解解读了vue-hackernews-2.0开源项目中的一些知识点，作为对&lt;a href=&quot;https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/&quot;&gt;项目源码解读&lt;/a&gt;的细节补充。&lt;/p&gt;
&lt;h2 id=&quot;package-json解读&quot;&gt;&lt;a href=&quot;#package-json解读&quot; class=&quot;headerlink&quot; title=&quot;package.json解读&quot;&gt;&lt;/a&gt;package.json解读&lt;/h2&gt;&lt;p&gt;该文件提供了四种命令&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# install dependencies&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install &lt;span class=&quot;comment&quot;&gt;# or yarn&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in dev mode, with hot reload at localhost:8080&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build for production&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run build&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# serve in production mode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://wangfuda.github.io/tags/vue/"/>
    
      <category term="Vuex" scheme="https://wangfuda.github.io/tags/Vuex/"/>
    
      <category term="vue-router" scheme="https://wangfuda.github.io/tags/vue-router/"/>
    
      <category term="ssr" scheme="https://wangfuda.github.io/tags/ssr/"/>
    
      <category term="webpack" scheme="https://wangfuda.github.io/tags/webpack/"/>
    
      <category term="node" scheme="https://wangfuda.github.io/tags/node/"/>
    
  </entry>
  
</feed>
